--- cg_o/cgminer.c	2014-04-06 10:43:59.015486731 +0300
+++ cgminer/cgminer.c	2014-04-10 10:37:32.217862132 +0300
@@ -84,6 +84,31 @@
 #include "driver-cointerra.h"
 #endif
 
+#ifdef USE_HEXMINERA
+#include "driver-hexminera.h"
+#endif
+
+#ifdef USE_HEXMINERB
+#include "driver-hexminerb.h"
+#endif
+
+#ifdef USE_HEXMINERC
+#include "driver-hexminerc.h"
+#endif
+
+#ifdef USE_HEXMINERU
+#include "driver-hexmineru.h"
+#endif
+
+#ifdef USE_HEXMINER8
+#include "driver-hexminer8.h"
+#endif
+
+
+#ifdef USE_HEXMINER3
+#include "driver-hexminer3.h"
+#endif
+
 #ifdef USE_HASHFAST
 #include "driver-hashfast.h"
 #endif
@@ -143,8 +168,8 @@
 bool opt_compact;
 const int opt_cutofftemp = 95;
 int opt_log_interval = 5;
-int opt_queue = 9999;
-static int max_queue = 1;
+int opt_queue = 60;
+static int max_queue = 2;
 int opt_scantime = -1;
 int opt_expiry = 120;
 static const bool opt_time = true;
@@ -195,7 +220,8 @@
 bool opt_api_network;
 bool opt_delaynet;
 bool opt_disable_pool;
-static bool no_work;
+//static 
+bool no_work;
 #ifdef USE_ICARUS
 char *opt_icarus_options = NULL;
 char *opt_icarus_timing = NULL;
@@ -213,6 +239,24 @@
 static char *opt_set_avalon2_fan;
 static char *opt_set_avalon2_voltage;
 #endif
+#ifdef USE_HEXMINERA
+char *opt_hexminera_options = NULL;
+#endif
+#ifdef USE_HEXMINERB
+char *opt_hexminerb_options = NULL;
+#endif
+#ifdef USE_HEXMINERC
+char *opt_hexminerc_options = NULL;
+#endif
+#ifdef USE_HEXMINERU
+char *opt_hexmineru_options = NULL;
+#endif
+#ifdef USE_HEXMINER8
+char *opt_hexminer8_options = NULL;
+#endif
+#ifdef USE_HEXMINER3
+char *opt_hexminer3_options = NULL;
+#endif
 #ifdef USE_KLONDIKE
 char *opt_klondike_options = NULL;
 #endif
@@ -309,7 +353,8 @@
 double total_diff_accepted, total_diff_rejected, total_diff_stale;
 static int staged_rollable;
 unsigned int new_blocks;
-static unsigned int work_block;
+//static
+unsigned int work_block;
 unsigned int found_blocks;
 
 unsigned int local_work;
@@ -320,6 +365,11 @@
 
 int total_pools, enabled_pools;
 enum pool_strategy pool_strategy = POOL_FAILOVER;
+
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+enum default_hex_miner default_hex_miner = D_HEXA;
+#endif
+
 int opt_rotate_period;
 static int total_urls, total_users, total_passes, total_userpasses;
 
@@ -672,9 +722,11 @@
 {
 	struct pool *pool;
 
-	cg_rlock(&control_lock);
+	//cg_rlock
+	cg_wlock(&control_lock);
 	pool = currentpool;
-	cg_runlock(&control_lock);
+	cg_wunlock(&control_lock);
+	//cg_runlock
 
 	return pool;
 }
@@ -747,6 +799,47 @@
 		*val2 = *val1;
 }
 
+
+#ifdef USE_HEXMINERA
+static char *set_default_to_a(enum default_hex_miner *which)
+{
+	*which = D_HEXA;
+	return NULL;
+}
+#endif
+
+
+#ifdef USE_HEXMINERB
+static char *set_default_to_b(enum default_hex_miner *which)
+{
+	*which = D_HEXB;
+	return NULL;
+}
+#endif
+
+#ifdef USE_HEXMINERC
+static char *set_default_to_c(enum default_hex_miner *which)
+{
+	*which = D_HEXC;
+	return NULL;
+}
+#endif
+
+#ifdef USE_HEXMINER8
+static char *set_default_to_8(enum default_hex_miner *which)
+{
+	*which = D_HEX8;
+	return NULL;
+}
+#endif
+
+#ifdef USE_HEXMINER3
+static char *set_default_to_3(enum default_hex_miner *which)
+{
+	*which = D_HEX3;
+	return NULL;
+}
+#endif
 static char *set_balance(enum pool_strategy *strategy)
 {
 	*strategy = POOL_BALANCE;
@@ -1034,6 +1127,57 @@
 	return NULL;
 }
 
+#ifdef USE_HEXMINERA
+static char *set_hexminera_options(const char *arg)
+{
+       opt_set_charp(arg, &opt_hexminera_options);
+
+       return NULL;
+}
+#endif
+
+#ifdef USE_HEXMINERB
+static char *set_hexminerb_options(const char *arg)
+{
+       opt_set_charp(arg, &opt_hexminerb_options);
+
+       return NULL;
+}
+#endif
+
+#ifdef USE_HEXMINER8
+static char *set_hexminer8_options(const char *arg)
+{
+       opt_set_charp(arg, &opt_hexminer8_options);
+
+       return NULL;
+}
+#endif
+#ifdef USE_HEXMINER3
+static char *set_hexminer3_options(const char *arg)
+{
+       opt_set_charp(arg, &opt_hexminer3_options);
+
+       return NULL;
+}
+#endif
+#ifdef USE_HEXMINERC
+static char *set_hexminerc_options(const char *arg)
+{
+       opt_set_charp(arg, &opt_hexminerc_options);
+
+       return NULL;
+}
+#endif
+#ifdef USE_HEXMINERU
+static char *set_hexmineru_options(const char *arg)
+{
+       opt_set_charp(arg, &opt_hexmineru_options);
+
+       return NULL;
+}
+#endif
+
 /* These options are available from config file or commandline */
 static struct opt_table opt_config_table[] = {
 #ifdef USE_ICARUS
@@ -1287,6 +1431,75 @@
 		     opt_set_charp, NULL, &opt_klondike_options,
 		     "Set klondike options clock:temptarget"),
 #endif
+#ifdef USE_HEXMINERA
+	OPT_WITH_ARG("--hexminera-options",
+		     set_hexminera_options, NULL, NULL,
+		     "Set HEXMinerA options asic_count:freq"),
+	OPT_WITH_ARG("--hexminera-voltage",
+		     libhexa_set_config_voltage, NULL, NULL,
+		     "Set HEXMinerA core voltage, in millivolts"),
+	OPT_WITHOUT_ARG("--set_default_to_a",
+		     set_default_to_a, &default_hex_miner,
+		     "Handle USB detect errors as hexA"),
+#endif
+#ifdef USE_HEXMINERB
+	OPT_WITH_ARG("--hexminerb-options",
+		     set_hexminerb_options, NULL, NULL,
+		     "Set HEXMinerB options asic_count:freq"),
+	OPT_WITH_ARG("--hexminerb-voltage",
+		     libhexb_set_config_voltage, NULL, NULL,
+		     "Set HEXMinerB core voltage, in millivolts"),
+  OPT_WITHOUT_ARG("--set_default_to_b",
+		     set_default_to_b, &default_hex_miner,
+		     "Handle USB detect errors as hexB"),
+#endif
+#ifdef USE_HEXMINERC
+	OPT_WITH_ARG("--hexminerc-options",
+		     set_hexminerc_options, NULL, NULL,
+		     "Set HEXMinerC options asic_count:freq"),
+	OPT_WITH_ARG("--hexminerc-voltage",
+		     libhexc_set_config_voltage, NULL, NULL,
+		     "Set HEXMinerC core voltage, in millivolts"),
+  OPT_WITHOUT_ARG("--set_default_to_c",
+		     set_default_to_c, &default_hex_miner,
+		     "Handle USB detect errors as hexC"),
+#endif
+#ifdef USE_HEXMINERU
+	OPT_WITH_ARG("--hexmineru-frequency",
+		     set_hexmineru_options, NULL, NULL,
+		     "Set HEXMinerU frequency"),
+#endif
+#ifdef USE_HEXMINER8
+OPT_WITH_ARG("--hexminer8-options",
+		     set_hexminer8_options, NULL, NULL,
+		     "Set HEXMiner8 options asic_count:freq"),
+	OPT_WITH_ARG("--hexminer8-voltage",
+		     libhex8_set_config_voltage, NULL, NULL,
+		     "Set HEXMiner8 core voltage, in millivolts"),
+	OPT_WITHOUT_ARG("--set_default_to_8",
+		     set_default_to_8, &default_hex_miner,
+		     "Handle USB detect errors as hex8"),
+	OPT_WITH_ARG("--hexminer8-chip-mask",
+		     libhex8_set_config_chip_mask, NULL, NULL,
+		     "Set HEXMiner8 eneable or disable chips"),	     
+	OPT_WITH_ARG("--hexminer8-set-diff-to-one",
+		     libhex8_set_config_diff_to_one, NULL, NULL,
+		     "Set HEXMiner8 ASIC difficulty to one"),	     
+#endif
+#ifdef USE_HEXMINER3
+OPT_WITH_ARG("--hexminer3-options",
+		     set_hexminer3_options, NULL, NULL,
+		     "Set HEXMiner3 options asic_count:freq"),
+	OPT_WITH_ARG("--hexminer3-voltage",
+		     libhex3_set_config_voltage, NULL, NULL,
+		     "Set HEXMiner3 core voltage, in millivolts"),
+	OPT_WITHOUT_ARG("--set_default_to_3",
+		     set_default_to_8, &default_hex_miner,
+		     "Handle USB detect errors as hex3"),
+	OPT_WITH_ARG("--hexminer3-chip-mask",
+		     libhex3_set_config_chip_mask, NULL, NULL,
+		     "Set HEXMiner3 eneable or disable chips"),	          
+#endif
 	OPT_WITHOUT_ARG("--load-balance",
 		     set_loadbalance, &pool_strategy,
 		     "Change multipool strategy from failover to quota based balance"),
@@ -1632,6 +1845,24 @@
 #ifdef USE_MINION
 		"minion "
 #endif
+#ifdef USE_HEXMINERA
+		"hexminera "
+#endif
+#ifdef USE_HEXMINERB
+		"hexminerb "
+#endif
+#ifdef USE_HEXMINERC
+		"hexminerc "
+#endif
+#ifdef USE_HEXMINERU
+		"hexmineru "
+#endif
+#ifdef USE_HEXMINER8
+		"hexminer8 "
+#endif
+#ifdef USE_HEXMINER3
+		"hexminer3 "
+#endif
 #ifdef USE_MODMINER
 		"modminer "
 #endif
@@ -1722,6 +1953,7 @@
 	int ret;
 
 	cg_wlock(&control_lock);
+	local_work++;
 	ret = total_work++;
 	cg_wunlock(&control_lock);
 
@@ -1879,7 +2111,7 @@
 	}
 
 	calc_midstate(work);
-	local_work++;
+	//local_work++;
 	work->pool = pool;
 	work->gbt = true;
 	work->id = total_work_inc();
@@ -2370,7 +2602,7 @@
 
 /* Convert a uint64_t value into a truncated string for displaying with its
  * associated suitable for Mega, Giga etc. Buf array needs to be long enough */
-static void suffix_string(uint64_t val, char *buf, size_t bufsiz, int sigdigits)
+void suffix_string(uint64_t val, char *buf, size_t bufsiz, int sigdigits)
 {
 	const double  dkilo = 1000.0;
 	const uint64_t kilo = 1000ull;
@@ -2571,7 +2803,8 @@
 
 static void curses_print_devstatus(struct cgpu_info *cgpu, int devno, int count)
 {
-	static int devno_width = 1, dawidth = 1, drwidth = 1, hwwidth = 1, wuwidth = 1;
+	//static int devno_width = 1, dawidth = 1, drwidth = 1, hwwidth = 1, wuwidth = 1;
+	static int devno_width = 1, dawidth = 1, drwidth = 1, hwwidth = 1, hwwidthp = 1, prwidthp = 1, wuwidth = 1;
 	char logline[256], unique_id[12];
 	struct timeval now;
 	double dev_runtime, wu;
@@ -2600,20 +2833,28 @@
 	wu = cgpu->diff1 / dev_runtime * 60;
 
 	wmove(statuswin,devcursor + count, 0);
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+	double hwp = (cgpu->hw_errors + cgpu->diff1) ?
+		     (double)100 *(double)(cgpu->hw_errors) / (double)(cgpu->hw_errors + cgpu->diff1) : 0;
+		     
+ double prp = (cgpu->diff_accepted + cgpu->diff_rejected) ?
+		     (double)100 *(double)(cgpu->diff_rejected) / (double)(cgpu->diff_rejected + cgpu->diff_accepted) : 0;
+#endif
 	adj_width(devno, &devno_width);
 	if (cgpu->unique_id) {
 		unique_id[8] = '\0';
 		memcpy(unique_id, blanks, 8);
 		strncpy(unique_id, cgpu->unique_id, 8);
 	} else
-		sprintf(unique_id, "%-8d", cgpu->device_id);
-	cg_wprintw(statuswin, " %*d: %s %-8s: ", devno_width, devno, cgpu->drv->name,
+		sprintf(unique_id, "%-3d", cgpu->device_id);
+		unique_id[3] = '\0';
+	cg_wprintw(statuswin, " %*d: %s %-3s: ", devno_width, devno, cgpu->drv->name,
 		   unique_id);
 	logline[0] = '\0';
 	cgpu->drv->get_statline_before(logline, sizeof(logline), cgpu);
 	devstatlen = strlen(logline);
-	if (devstatlen < STATBEFORELEN)
-		strncat(logline, blanks, STATBEFORELEN - devstatlen);
+	if (devstatlen < STATBEFORELEN - 7)
+		strncat(logline, blanks, STATBEFORELEN - 7 - devstatlen);
 	cg_wprintw(statuswin, "%s | ", logline);
 
 
@@ -2664,13 +2905,39 @@
 		adj_fwidth(cgpu->diff_accepted, &dawidth);
 		adj_fwidth(cgpu->diff_rejected, &drwidth);
 		adj_width(cgpu->hw_errors, &hwwidth);
-		cg_wprintw(statuswin, "A:%*.0f R:%*.0f HW:%*d",
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+	if(usb_ident(cgpu) == IDENT_HEXA || usb_ident(cgpu) == IDENT_HEXB || usb_ident(cgpu) == IDENT_HEXC || usb_ident(cgpu) == IDENT_HEXU || usb_ident(cgpu) == IDENT_HEX8 || usb_ident(cgpu) == IDENT_HEX3) {
+		adj_width(prp, &prwidthp);
+		adj_width(hwp, &hwwidthp);
+	}
+#endif
+ 	
+ 		adj_width(wu, &wuwidth);
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+	if(usb_ident(cgpu) == IDENT_HEXA || usb_ident(cgpu) == IDENT_HEXB || usb_ident(cgpu) == IDENT_HEXC || usb_ident(cgpu) == IDENT_HEXU || usb_ident(cgpu) == IDENT_HEX8 || usb_ident(cgpu) == IDENT_HEX3) {
+		cg_wprintw(statuswin, "A:%*.0f R:%*.0f/%*.2f%% HW:%*d/%*.2f%%",
 				dawidth, cgpu->diff_accepted,
 				drwidth, cgpu->diff_rejected,
-				hwwidth, cgpu->hw_errors);
+				prwidthp +1, prp,
+				hwwidth, cgpu->hw_errors,
+				hwwidthp + 1, hwp);
+	} else {
+		cg_wprintw(statuswin, "A:%*.0f R:%*.0f HW:%*d",
+			dawidth, cgpu->diff_accepted,
+			drwidth, cgpu->diff_rejected,
+			hwwidth, cgpu->hw_errors);
 	}
+#else
+ 		cg_wprintw(statuswin, "A:%*.0f R:%*.0f HW:%*d",
+ 				dawidth, cgpu->diff_accepted,
+ 				drwidth, cgpu->diff_rejected,
+ 				hwwidth, cgpu->hw_errors);
+#endif
 
-	logline[0] = '\0';
+ 	}
+ 
+ 	logline[0] = '\0';
+	
 	cgpu->drv->get_statline(logline, sizeof(logline), cgpu);
 	cg_wprintw(statuswin, "%s", logline);
 
@@ -3848,7 +4115,8 @@
 	mutex_unlock(&pool->pool_lock);
 }
 
-static bool stale_work(struct work *work, bool share);
+//static 
+bool stale_work(struct work *work, bool share);
 
 static inline bool should_roll(struct work *work)
 {
@@ -3902,7 +4170,7 @@
 	ntime = be32toh(*work_ntime);
 	ntime++;
 	*work_ntime = htobe32(ntime);
-	local_work++;
+	//local_work++;
 	work->rolls++;
 	work->nonce = 0;
 	applog(LOG_DEBUG, "Successfully rolled work");
@@ -3977,6 +4245,7 @@
 
 static bool clone_available(void)
 {
+	return false;
 	struct work *work_clone = NULL, *work, *tmp;
 	bool cloned = false;
 
@@ -3998,7 +4267,7 @@
 	mutex_unlock(stgd_lock);
 
 	if (cloned) {
-		applog(LOG_DEBUG, "Pushing cloned available work to stage thread");
+		applog(LOG_ERR, "Pushing cloned available work to stage thread");
 		stage_work(work_clone);
 	}
 	return cloned;
@@ -4009,6 +4278,7 @@
  * the future */
 static struct work *clone_work(struct work *work)
 {
+	return work;
 	int mrs = mining_threads + opt_queue - total_staged();
 	struct work *work_clone;
 	bool cloned;
@@ -4019,7 +4289,7 @@
 	cloned = false;
 	work_clone = make_clone(work);
 	while (mrs-- > 0 && can_roll(work) && should_roll(work)) {
-		applog(LOG_DEBUG, "Pushing rolled converted work to stage thread");
+		applog(LOG_ERR, "Pushing rolled converted work to stage thread");
 		stage_work(work_clone);
 		roll_work(work);
 		work_clone = make_clone(work);
@@ -4122,7 +4392,50 @@
 
 	return work;
 }
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
 
+struct work *copy_work_noffset_fast_no_id(struct work *base_work, int noffset)
+{
+	
+  struct work *work = calloc(1, sizeof(struct work));
+
+	if (unlikely(!work))
+		quit(1, "Failed to calloc work in make_work");
+ 
+
+	memcpy(work, base_work, sizeof(struct work));
+	/* Keep the unique new id assigned during make_work to prevent copied
+	 * work from having the same id. */
+	if (base_work->job_id)
+		work->job_id = strdup(base_work->job_id);
+	if (base_work->nonce1)
+		work->nonce1 = strdup(base_work->nonce1);
+	if (base_work->ntime) {
+		/* If we are passed an noffset the binary work->data ntime and
+		 * the work->ntime hex string need to be adjusted. */
+		if (noffset) {
+			uint32_t *work_ntime = (uint32_t *)(work->data + 68);
+			uint32_t ntime = be32toh(*work_ntime);
+
+			ntime += noffset;
+			*work_ntime = htobe32(ntime);
+			work->ntime = offset_ntime(base_work->ntime, noffset);
+		} else
+			work->ntime = strdup(base_work->ntime);
+	} else if (noffset) {
+		uint32_t *work_ntime = (uint32_t *)(work->data + 68);
+		uint32_t ntime = be32toh(*work_ntime);
+
+		ntime += noffset;
+		*work_ntime = htobe32(ntime);
+	}
+	if (base_work->coinbase)
+		work->coinbase = strdup(base_work->coinbase);
+
+	return work;
+}
+
+#endif
 static void pool_died(struct pool *pool)
 {
 	if (!pool_tset(pool, &pool->idle)) {
@@ -4135,7 +4448,8 @@
 	}
 }
 
-static bool stale_work(struct work *work, bool share)
+//static 
+bool stale_work(struct work *work, bool share)
 {
 	struct timeval now;
 	time_t work_expiry;
@@ -4146,7 +4460,7 @@
 		return false;
 
 	if (work->work_block != work_block) {
-		applog(LOG_DEBUG, "Work stale due to block mismatch");
+		//applog(LOG_DEBUG, "Work stale due to block mismatch");
 		return true;
 	}
 
@@ -4164,19 +4478,19 @@
 		bool same_job;
 
 		if (!pool->stratum_active || !pool->stratum_notify) {
-			applog(LOG_DEBUG, "Work stale due to stratum inactive");
+			//applog(LOG_DEBUG, "Work stale due to stratum inactive");
 			return true;
 		}
 
 		same_job = true;
-
-		cg_rlock(&pool->data_lock);
+    cg_wlock(&pool->data_lock);
+	
 		if (strcmp(work->job_id, pool->swork.job_id))
 			same_job = false;
-		cg_runlock(&pool->data_lock);
+		cg_wunlock(&pool->data_lock);
 
 		if (!same_job) {
-			applog(LOG_DEBUG, "Work stale due to stratum job_id mismatch");
+			//applog(LOG_DEBUG, "Work stale due to stratum job_id mismatch");
 			return true;
 		}
 	}
@@ -4190,13 +4504,13 @@
 
 	cgtime(&now);
 	if ((now.tv_sec - work->tv_staged.tv_sec) >= work_expiry) {
-		applog(LOG_DEBUG, "Work stale due to expiry");
+		//applog(LOG_DEBUG, "Work stale due to expiry");
 		return true;
 	}
 
 	if (opt_fail_only && !share && pool != current_pool() && !work->mandatory &&
 	    pool_strategy != POOL_LOADBALANCE && pool_strategy != POOL_BALANCE) {
-		applog(LOG_DEBUG, "Work stale due to fail only pool mismatch");
+		//applog(LOG_DEBUG, "Work stale due to fail only pool mismatch");
 		return true;
 	}
 
@@ -4466,7 +4780,10 @@
 	/* Cancels any cancellable usb transfers. Flagged as such it means they
 	 * are usualy waiting on a read result and it's safe to abort the read
 	 * early. */
+	#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+	#else
 	cancel_usb_transfers();
+	#endif
 #endif
 	return NULL;
 }
@@ -4688,8 +5005,8 @@
 	bool rc = true;
 
 	mutex_lock(stgd_lock);
-	if (work_rollable(work))
-		staged_rollable++;
+	//if (work_rollable(work))
+		//staged_rollable++;
 	if (likely(!getq->frozen)) {
 		HASH_ADD_INT(staged_work, id, work);
 		HASH_SORT(staged_work, tv_sort);
@@ -6593,14 +6910,14 @@
 static struct work *hash_pop(bool blocking)
 {
 	struct work *work = NULL, *tmp;
-	int hc;
+	//int hc;
 
 	mutex_lock(stgd_lock);
 	if (!HASH_COUNT(staged_work)) {
 		/* Increase the queue if we reach zero and we know we can reach
 		 * the maximum we're asking for. */
 		if (work_filled && max_queue < opt_queue) {
-			max_queue++;
+			if(max_queue < most_devices * 2) max_queue++;
 			work_filled = false;
 		}
 		work_emptied = true;
@@ -6631,18 +6948,18 @@
 		no_work = false;
 	}
 
-	hc = HASH_COUNT(staged_work);
+	//hc = HASH_COUNT(staged_work);
 	/* Find clone work if possible, to allow masters to be reused */
-	if (hc > staged_rollable) {
-		HASH_ITER(hh, staged_work, work, tmp) {
-			if (!work_rollable(work))
-				break;
-		}
-	} else
+	//if (hc > staged_rollable) {
+		//HASH_ITER(hh, staged_work, work, tmp) {
+			//if (!work_rollable(work))
+				//break;
+		//}
+	//} else
 		work = staged_work;
 	HASH_DEL(staged_work, work);
-	if (work_rollable(work))
-		staged_rollable--;
+	//if (work_rollable(work))
+		//staged_rollable--;
 
 	/* Signal the getwork scheduler to look for more work */
 	pthread_cond_signal(&gws_cond);
@@ -6754,7 +7071,7 @@
 	memcpy(pool->coinbase + pool->nonce2_offset, &nonce2le, pool->n2size);
 	work->nonce2 = pool->nonce2++;
 	work->nonce2_len = pool->n2size;
-
+  work->job_id = strdup(pool->swork.job_id);
 	/* Downgrade to a read lock to read off the pool variables */
 	cg_dwlock(&pool->data_lock);
 
@@ -6779,7 +7096,7 @@
 	work->sdiff = pool->sdiff;
 
 	/* Copy parameters required for share submission */
-	work->job_id = strdup(pool->swork.job_id);
+//	work->job_id = strdup(pool->swork.job_id);
 	work->nonce1 = strdup(pool->nonce1);
 	work->ntime = strdup(pool->ntime);
 	cg_runlock(&pool->data_lock);
@@ -6800,7 +7117,7 @@
 	calc_midstate(work);
 	set_target(work->target, work->sdiff);
 
-	local_work++;
+	//local_work++;
 	work->pool = pool;
 	work->stratum = true;
 	work->nonce = 0;
@@ -6942,7 +7259,7 @@
 
 	calc_midstate(work);
 
-	local_work++;
+	//local_work++;
 	work->gbt = true;
 	work->pool = pool;
 	work->nonce = 0;
@@ -6965,14 +7282,16 @@
 	return last_getwork - cgpu->last_device_valid_work;
 }
 
+
+
 struct work *get_work(struct thr_info *thr, const int thr_id)
 {
 	struct work *work = NULL;
-	time_t diff_t;
+	//time_t diff_t;
 
 	thread_reportout(thr);
-	applog(LOG_DEBUG, "Popping work from get queue to get work");
-	diff_t = time(NULL);
+	//applog(LOG_DEBUG, "Popping work from get queue to get work");
+	//diff_t = time(NULL);
 	while (!work) {
 		work = hash_pop(true);
 		if (stale_work(work, false)) {
@@ -6981,15 +7300,15 @@
 			wake_gws();
 		}
 	}
-	diff_t = time(NULL) - diff_t;
+	//diff_t = time(NULL) - diff_t;
 	/* Since this is a blocking function, we need to add grace time to
 	 * the device's last valid work to not make outages appear to be
 	 * device failures. */
-	if (diff_t > 0) {
-		applog(LOG_DEBUG, "Get work blocked for %d seconds", (int)diff_t);
-		thr->cgpu->last_device_valid_work += diff_t;
-	}
-	applog(LOG_DEBUG, "Got work from get queue to get work for thread %d", thr_id);
+	//if (diff_t > 0) {
+		//applog(LOG_DEBUG, "Get work blocked for %d seconds", (int)diff_t);
+		//thr->cgpu->last_device_valid_work += diff_t;
+	//}
+	//applog(LOG_DEBUG, "Got work from get queue to get work for thread %d", thr_id);
 
 	work->thr_id = thr_id;
 	thread_reportin(thr);
@@ -7054,6 +7373,18 @@
 	thr->cgpu->drv->hw_error(thr);
 }
 
+void inc_hw_errors_hex8(struct thr_info *thr, int diff)
+{
+	applog(LOG_INFO, "%s%d: invalid nonce - HW error", thr->cgpu->drv->name,
+	       thr->cgpu->device_id);
+
+	mutex_lock(&stats_lock);
+	hw_errors-=diff;
+	thr->cgpu->hw_errors-=diff;
+	mutex_unlock(&stats_lock);
+
+	thr->cgpu->drv->hw_error(thr);
+}
 /* Fills in the work nonce and builds the output data in work->hash */
 static void rebuild_nonce(struct work *work, uint32_t nonce)
 {
@@ -7100,9 +7431,23 @@
 	}
 
 	mutex_lock(&stats_lock);
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+if(work->ping) {
 	total_diff1 += work->device_diff;
 	thr->cgpu->diff1 += work->device_diff;
 	work->pool->diff1 += work->device_diff;
+ } else {
+ 	total_diff1 += work->work_difficulty;
+	thr->cgpu->diff1 += work->work_difficulty;
+	work->pool->diff1 += work->work_difficulty;
+ }
+#else
+	total_diff1 += work->device_diff;
+	thr->cgpu->diff1 += work->device_diff;
+	work->pool->diff1 += work->device_diff;
+#endif
+
+	
 	thr->cgpu->last_device_valid_work = time(NULL);
 	mutex_unlock(&stats_lock);
 }
@@ -7124,6 +7469,25 @@
 	return true;
 }
 
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+bool submit_tested_work_no_clone(struct thr_info *thr, struct work *work, bool diff1)
+{
+	
+	update_work_stats(thr, work);
+  if(diff1) {
+		if (!fulltest(work->hash, work->target)) {
+			applog(LOG_INFO, "%s %d: Share above target",
+				thr->cgpu->drv->name, thr->cgpu->device_id);
+				free_work(work);
+			return false;
+		}
+	}
+	
+	submit_work_async(work);
+	return true;
+}
+#endif
+
 /* Returns true if nonce for work was a valid share */
 bool submit_nonce(struct thr_info *thr, struct work *work, uint32_t nonce)
 {
@@ -7219,9 +7583,10 @@
 	while (likely(!cgpu->shutdown)) {
 		struct work *work = get_work(mythr, thr_id);
 		int64_t hashes;
-
+		
 		mythr->work_restart = false;
 		cgpu->new_work = true;
+		
 
 		cgtime(&tv_workstart);
 		work->nonce = 0;
@@ -7575,6 +7940,7 @@
 		free_work(work);
 		applog(LOG_DEBUG, "Discarded queued work item");
 	}
+	
 }
 
 /* This version of hash work is for devices that are fast enough to always
@@ -7592,17 +7958,18 @@
 	while (likely(!cgpu->shutdown)) {
 		struct timeval diff;
 		int64_t hashes;
-
+    
 		mythr->work_update = false;
-
+  	
 		fill_queue(mythr, cgpu, drv, thr_id);
 
 		hashes = drv->scanwork(mythr);
 
 		/* Reset the bool here in case the driver looks for it
 		 * synchronously in the scanwork loop. */
+		
 		mythr->work_restart = false;
-
+  	
 		if (unlikely(hashes == -1 )) {
 			applog(LOG_ERR, "%s %d failure, disabling!", drv->name, cgpu->device_id);
 			cgpu->deven = DEV_DISABLED;
@@ -7624,7 +7991,7 @@
 		if (unlikely(mythr->pause || cgpu->deven != DEV_ENABLED))
 			mt_disable(mythr, thr_id, drv);
 
-		if (mythr->work_update)
+ 		if (mythr->work_update)
 			drv->update_work(cgpu);
 	}
 	cgpu->deven = DEV_DISABLED;
@@ -7679,7 +8046,7 @@
 		if (unlikely(mythr->pause || cgpu->deven != DEV_ENABLED))
 			mt_disable(mythr, thr_id, drv);
 
-		if (mythr->work_update)
+    if (mythr->work_update)
 			drv->update_work(cgpu);
 	}
 	cgpu->deven = DEV_DISABLED;
@@ -8410,9 +8777,12 @@
 static void clean_up(bool restarting)
 {
 #ifdef USE_USBUTILS
-	usb_polling = false;
-	pthread_join(usb_poll_thread, NULL);
-        libusb_exit(NULL);
+ usb_polling = false;
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+#else
+ pthread_join(usb_poll_thread, NULL);      
+#endif
+ libusb_exit(NULL);
 #endif
 
 	cgtime(&total_tv_end);
@@ -9051,6 +9421,126 @@
 #define DRIVER_DRV_DETECT_ALL(X) X##_drv.drv_detect(false);
 
 #ifdef USE_USBUTILS
+//UGLY but if hotplug is ok we are disabling it. Something is happening here and we do not need it.
+//This breaks badly cgminer code (MIPS - TPLINK) and other device support but whoever wants please do enable it.
+//What happens is that for some reason pooling touches usbdev even though reads/writes are performed under lock like in usb-utils
+// same function actualy
+
+/*
+
+(gdb) c
+Continuing.
+[New Thread 887]
+
+Program received signal SIGSEGV, Segmentation fault.
+[Switching to Thread 887]
+usbi_hotplug_match (dev=0x3, event=(unknown: 0)) at hotplug.c:166
+166             struct libusb_context *ctx = dev->ctx;
+(gdb) bt full
+#0  usbi_hotplug_match (dev=0x3, event=(unknown: 0)) at hotplug.c:166
+        hotplug_cb = <optimized out>
+        next = <optimized out>
+        ctx = <optimized out>
+#1  0x0043f43c in handle_events (ctx=0x468258, tv=0x767f76d8) at io.c:1954
+        message = {event = (unknown: 0), device = 0x3}
+        ret = <optimized out>
+        r = 2
+        ipollfd = 0x4682e8
+        nfds = 7
+        fds = 0x70fce8
+        i = <optimized out>
+        timeout_ms = <optimized out>
+        __FUNCTION__ = "handle_events"
+#2  0x0043fcbc in libusb_handle_events_timeout_completed (ctx=0x468258, tv=<optimized out>, completed=0x767f7738) at io.c:2070
+        r = 0
+        poll_timeout = {tv_sec = 60, tv_usec = 0}
+#3  0x0043fd88 in libusb_handle_events_completed (ctx=<optimized out>, completed=<optimized out>) at io.c:2169
+        tv = {tv_sec = 60, tv_usec = 0}
+#4  0x00440468 in do_sync_bulk_transfer (dev_handle=0x47d390, endpoint=<optimized out>, buffer=<optimized out>, length=1, transferred=0x767f77b0,
+    timeout=0, type=2 '\002') at sync.c:182
+        transfer = 0x723f4c
+        completed = 0
+        r = 0
+        __FUNCTION__ = "do_sync_bulk_transfer"
+#5  0x00440810 in libusb_bulk_transfer (dev_handle=<optimized out>, endpoint=<optimized out>, data=<optimized out>, length=<optimized out>,
+    transferred=0x767f77b0, timeout=0) at sync.c:270
+No locals.
+#6  0x00434bd8 in libhexa_readHashData (hash_write_pos=<synthetic pointer>, hash=0x767f77d4 "S\fR", hexminera=0x479098, timeout=<optimized out>,
+    read_once=<optimized out>) at libhexa.c:354
+        info = <optimized out>
+        read = 0
+        err = 0
+        timeout = 0
+        usbdev = 0x47b338
+        read_once = true
+        total = <optimized out>
+#7  hexminera_get_results (userdata=0x479098) at driver-hexminera.c:462
+        ts_start = {tv_sec = 11437, tv_nsec = 862254175}
+        hexminera = 0x479098
+        info = 0x47d410
+        readbuf = "S\fR\000\060\025\307A\314\336\000\023\a\000\000\000\000\021", '\000' <repeats 11 times>, "\323S\002R\224d\025\307AÌS\004R\234dC\000O\000O\000\000\000\212S\001W\000@.\000\031S\001R\004\060\336\000\270S\001R\004\060\336\000\270S\001R\000h\024\a)S\fR\000\060z\257\255\351\337\000\022\a\000\000\000\000\021", '\000' <repeats 11 times>, "\251S\002R\224dz\257\255\351^S\004R\234dC\000O\000O\000\000\000\212S\001W\000@.\000\031S\001R\004\060\337\000\271S\001R\004\060\337\000\271S\001R\000h\024\a)S\004R\234dC\000O\000O\000\000\000\212S\001W\000@.\000\031S\001R\004\060\337\000"...
+        wr = 0x49f2a8
+        array_nonce_cache = 0x4ac7c8
+        thr = 0x472840
+        i = <optimized out>
+        lastchippos = 10
+        nonce = <optimized out>
+        found = <optimized out>
+        usb_r_reset = 0
+        threadname = "hexa_recv/1", '\000' <repeats 12 times>
+        ret_r = <optimized out>
+        hash_read_pos = 256
+        hash_write_pos = 258
+        need_work_reset = 0
+        __func__ = "hexminera_get_results"
+---Type <return> to continue, or q <return> to quit---
+#8  0x77eefc94 in start_thread (arg=0x767f8530) at libpthread/nptl/pthread_create.c:297
+        pd = 0x767f8530
+        unwind_buf = {cancel_jmp_buf = {{jmp_buf = {{__pc = 0x77eefbb8 <start_thread+184>, __sp = 0x767f8020, __regs = {1988068656, 2012246048, 2012174776,
+                    1988067584, 0, 0, 4096, 2097152}, __fp = 0x767f8020, __gp = 0x77ec33b0, __fpc_csr = 0, __fpregs = {0, 0, 0, 0, 0, 0}}},
+              mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, canceltype = 0}}}
+        not_first_call = 0
+        robust = <optimized out>
+        pagesize_m1 = <optimized out>
+        sp = 0x767f8020 ""
+        freesize = <optimized out>
+#9  0x77ee80e0 in __thread_start () at ./libc/sysdeps/linux/mips/clone.S:146
+No locals.
+Backtrace stopped: frame did not save the PC
+
+
+Program received signal SIG32, Real-time event 32.
+[Switching to Thread 978]
+clock_nanosleep (clock_id=1, flags=1, req=0x751f7fa8, rem=0x0) at librt/clock_nanosleep.c:51
+51            LIBC_CANCEL_RESET (oldstate);
+(gdb) bt full
+#0  clock_nanosleep (clock_id=1, flags=1, req=0x751f7fa8, rem=0x0) at librt/clock_nanosleep.c:51
+        oldstate = 2
+        err = <optimized out>
+        r = <optimized out>
+#1  0x0041e238 in nanosleep_abstime (ts_end=0x751f7fa8) at util.c:1001
+        ret = 514
+#2  0x00420aa0 in cgsleep_ms_r (ts_start=0x751f7fd0, ms=<optimized out>) at util.c:1014
+        ts_end = {tv_sec = 11737, tv_nsec = 388217180}
+#3  0x00420b10 in cgsleep_ms (ms=5000) at util.c:1155
+        ts_start = {tv_sec = 11732, tv_nsec = 388217180}
+#4  0x0041cb94 in hotplug_thread (userdata=<optimized out>) at cgminer.c:7979
+No locals.
+#5  0x77eefc94 in start_thread (arg=0x751f8530) at libpthread/nptl/pthread_create.c:297
+        pd = 0x751f8530
+        unwind_buf = {cancel_jmp_buf = {{jmp_buf = {{__pc = 0x77eefbb8 <start_thread+184>, __sp = 0x751f8020, __regs = {1964999984, 2012246048, 2012174776,
+                    1964998912, 0, 0, 4096, 2097152}, __fp = 0x751f8020, __gp = 0x77ec33b0, __fpc_csr = 0, __fpregs = {0, 0, 0, 0, 0, 0}}},
+              mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, canceltype = 0}}}
+        not_first_call = 0
+        robust = <optimized out>
+        pagesize_m1 = <optimized out>
+        sp = 0x751f8020 ""
+        freesize = <optimized out>
+#6  0x77ee80e0 in __thread_start () at ./libc/sysdeps/linux/mips/clone.S:146
+No locals.
+Backtrace stopped: frame did not save the PC
+*/
+
 static void *libusb_poll_thread(void __maybe_unused *arg)
 {
 	struct timeval tv_end = {1, 0};
@@ -9082,7 +9572,11 @@
 	}
 	initialise_usblocks();
 	usb_polling = true;
+	#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB)  || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+	#else
+	
 	pthread_create(&usb_poll_thread, NULL, libusb_poll_thread, NULL);
+	#endif
 }
 #else
 #define initialise_usb() {}
@@ -9505,8 +9999,8 @@
 
 		/* If the primary pool is a getwork pool and cannot roll work,
 		 * try to stage one extra work per mining thread */
-		if (!pool_localgen(cp) && !staged_rollable)
-			max_staged += mining_threads;
+		//if (!pool_localgen(cp) && !staged_rollable)
+			//max_staged += mining_threads;
 
 		mutex_lock(stgd_lock);
 		ts = __total_staged();
@@ -9517,7 +10011,7 @@
 		/* Wait until hash_pop tells us we need to create more work */
 		if (ts > max_staged) {
 			if (work_emptied && max_queue < opt_queue) {
-				max_queue++;
+				if(max_queue < most_devices * 2) max_queue++;
 				work_emptied = false;
 			}
 			work_filled = true;
@@ -9526,12 +10020,12 @@
 		}
 		mutex_unlock(stgd_lock);
 
-		if (ts > max_staged) {
+		if (ts > max_staged ) {
 			/* Keeps slowly generating work even if it's not being
 			 * used to keep last_getwork incrementing and to see
 			 * if pools are still alive. */
 			if (work_emptied && max_queue < opt_queue) {
-				max_queue++;
+				if(max_queue < most_devices * 2) max_queue++;
 				work_emptied = false;
 			}
 			work_filled = true;
@@ -9540,7 +10034,7 @@
 				discard_work(work);
 			continue;
 		}
-
+    //applog(LOG_ERR, "GEN WORK");
 		work = make_work();
 
 		if (lagging && !pool_tset(cp, &cp->lagging)) {
--- cg_o/configure.ac	2014-04-06 10:43:59.019486949 +0300
+++ cgminer/configure.ac	2014-04-10 10:37:32.217862132 +0300
@@ -293,6 +293,72 @@
 fi
 AM_CONDITIONAL([HAS_MINION], [test x$minion = xyes])
 
+hexminera="no"
+
+AC_ARG_ENABLE([hexminera],
+	[AC_HELP_STRING([--enable-hexminera],[Compile support for hexminera (default disabled)])],
+	[hexminera=$enableval]
+	)
+if test "x$hexminera" = xyes; then
+	AC_DEFINE([USE_HEXMINERA], [1], [Defined to 1 if hexminera support is wanted])
+fi
+AM_CONDITIONAL([HAS_HEXMINERA], [test x$hexminera = xyes])
+
+hexminerb="no"
+
+AC_ARG_ENABLE([hexminerb],
+	[AC_HELP_STRING([--enable-hexminerb],[Compile support for hexminerb (default disabled)])],
+	[hexminerb=$enableval]
+	)
+if test "x$hexminerb" = xyes; then
+	AC_DEFINE([USE_HEXMINERB], [1], [Defined to 1 if hexminerb support is wanted])
+fi
+AM_CONDITIONAL([HAS_HEXMINERB], [test x$hexminerb = xyes])
+
+hexmineru="no"
+
+AC_ARG_ENABLE([hexmineru],
+	[AC_HELP_STRING([--enable-hexmineru],[Compile support for hexmineru (default disabled)])],
+	[hexmineru=$enableval]
+	)
+if test "x$hexmineru" = xyes; then
+	AC_DEFINE([USE_HEXMINERU], [1], [Defined to 1 if hexmineru support is wanted])
+fi
+AM_CONDITIONAL([HAS_HEXMINERU], [test x$hexmineru = xyes])
+
+hexminerc="no"
+
+AC_ARG_ENABLE([hexminerc],
+	[AC_HELP_STRING([--enable-hexminerc],[Compile support for hexminerc (default disabled)])],
+	[hexminerc=$enableval]
+	)
+if test "x$hexminerc" = xyes; then
+	AC_DEFINE([USE_HEXMINERC], [1], [Defined to 1 if hexminerc support is wanted])
+fi
+AM_CONDITIONAL([HAS_HEXMINERC], [test x$hexminerc = xyes])
+
+hexminer8="no"
+
+AC_ARG_ENABLE([hexminer8],
+	[AC_HELP_STRING([--enable-hexminer8],[Compile support for hexminer8 (default disabled)])],
+	[hexminer8=$enableval]
+	)
+if test "x$hexminer8" = xyes; then
+	AC_DEFINE([USE_HEXMINER8], [1], [Defined to 1 if hexminer8 support is wanted])
+fi
+AM_CONDITIONAL([HAS_HEXMINER8], [test x$hexminer8 = xyes])
+
+hexminer3="no"
+
+AC_ARG_ENABLE([hexminer3],
+	[AC_HELP_STRING([--enable-hexminer3],[Compile support for hexminer3 (default disabled)])],
+	[hexminer3=$enableval]
+	)
+if test "x$hexminer3" = xyes; then
+	AC_DEFINE([USE_HEXMINER3], [1], [Defined to 1 if hexminer3 support is wanted])
+fi
+AM_CONDITIONAL([HAS_HEXMINER3], [test x$hexminer3 = xyes])
+
 modminer="no"
 
 AC_ARG_ENABLE([modminer],
@@ -328,7 +394,7 @@
 	])
 fi
 
-if test x$avalon$bitforce$bitfury$modminer$bflsc$icarus$hashfast$klondike$drillbit$cointerra$ants1 != xnonononononononononono; then
+if test x$hexminera$hexminerb$hexminerc$hexmineru$hexminer8$hexminer3$avalon$bitforce$bitfury$modminer$bflsc$icarus$hashfast$klondike$drillbit$cointerra$ants1 != xnonononononononononono; then
 	want_usbutils=true
 else
 	want_usbutils=false
@@ -538,6 +604,42 @@
 	echo "  BlackArrow.ASICs.....: Disabled"
 fi
 
+if test "x$hexminera" = xyes; then
+	echo "  HEX16A.ASICs.........: Enabled"
+else
+	echo "  HEX16A.ASICs.........: Disabled"
+fi
+
+if test "x$hexminerb" = xyes; then
+	echo "  HEX16B.ASICs.........: Enabled"
+else
+	echo "  HEX16B.ASICs.........: Disabled"
+fi
+
+if test "x$hexminerc" = xyes; then
+	echo "  HEX16C.ASICs.........: Enabled"
+else
+	echo "  HEX16C.ASICs.........: Disabled"
+fi
+
+if test "x$hexminer8" = xyes; then
+	echo "  HEX8A1.ASICs.........: Enabled"
+else
+	echo "  HEX8A1.ASICs.........: Disabled"
+fi
+
+if test "x$hexminer3" = xyes; then
+	echo "  HEX3A3.ASICs.........: Enabled"
+else
+	echo "  HEX3A3.ASICs.........: Disabled"
+fi
+
+if test "x$hexmineru" = xyes; then
+	echo "  HEX16U.ASICs.........: Enabled"
+else
+	echo "  HEX16U.ASICs.........: Disabled"
+fi
+
 if test "x$bflsc" = xyes; then
 	echo "  BFL.ASICs............: Enabled"
 else
@@ -604,7 +706,7 @@
 	echo "  ModMiner.FPGAs.......: Disabled"
 fi
 
-if test "x$avalon$avalon2$bab$bflsc$bitforce$bitfury$hashfast$icarus$klondike$knc$modminer$drillbit$minion$cointerra$bitmine_A1$ants1" = xnononononononononononononononono; then
+if test "$hexminera$hexminerb$hexminerc$hexmineru$hexminer8$hexminer3$avalon$avalon2$bab$bflsc$bitforce$bitfury$hashfast$icarus$klondike$knc$modminer$drillbit$minion$cointerra$bitmine_A1$ants1" = xnononononononononononononononono; then
 	AC_MSG_ERROR([No mining configured in])
 fi
 
--- cg_o/driver-hexminerb.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer/driver-hexminerb.c	2014-04-11 11:33:18.853851446 +0300
@@ -0,0 +1,601 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:19:47 */
+/*
+ * Copyright 2013 Con Kolivas <kernel@kolivas.org> Copyright 2012-2013 Xiangfu
+ * <xiangfu@openmobilefree.com> Copyright 2012 Luke Dashjr Copyright 2012 Andrew
+ * Smith This program is free software;
+ * you can redistribute it and/or modify it under the terms of the GNU General
+ * Public License as published by the Free Software Foundation;
+ * either version 3 of the License, or (at your option) any later version. See
+ * COPYING for more details. Thank you guys!
+ */
+#include "config.h"
+#include <limits.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <ctype.h>
+#include <dirent.h>
+#include <unistd.h>
+#ifndef WIN32
+#include <sys/select.h>
+#include <termios.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#ifndef O_CLOEXEC
+#define O_CLOEXEC	0
+#endif
+#else
+#include "compat.h"
+#include <windows.h>
+#include <io.h>
+#endif
+#include "elist.h"
+#include "miner.h"
+#include "usbutils.h"
+#include "driver-hexminerb.h"
+#include "util.h"
+
+extern unsigned int work_block;
+extern struct work *copy_work_noffset_fast_no_id(struct work *base_work, int noffset);
+static int option_offset = -1;
+struct device_drv hexminerb_drv;
+int opt_hexminerb_core_voltage = HEXB_DEFAULT_CORE_VOLTAGE;
+#include "libhexb.c"
+/*
+    We use a replacement algorithm to only remove references to work done from the buffer when we need the extra space
+    for new work. Thanks to Avalon code with some mods
+ */
+
+
+static void
+hexminerb_flush_work (struct cgpu_info *hexminerb)
+{
+  struct hexminerb_info *info = hexminerb->device_data;
+
+
+  cgsem_post (&info->wsem);
+#ifdef DBG_HEXB
+  applog (LOG_ERR, "HEXb%i hexminerb_flush_work", hexminerb->device_id);
+#endif
+
+}
+
+static int
+hexminerb_send_task (struct hexminerb_task *ht, struct cgpu_info *hexminerb)
+{
+  int ret = 0;
+  size_t nr_len = HEXMINERB_TASK_SIZE;
+  struct hexminerb_info *info;
+  info = hexminerb->device_data;
+
+  libhexb_csum (&ht->startbyte, &ht->csum, &ht->csum);
+
+
+  ret = libhexb_sendHashData (hexminerb, &ht->startbyte, nr_len);
+
+  if (ret != nr_len)
+    {
+      libhexb_reset (hexminerb);
+      info->usb_w_errors++;
+      return -1;
+    }
+
+  return ret;
+}
+
+
+static inline void
+hexminerb_create_task (bool reset_work, struct hexminerb_task *ht,
+                       struct work *work)
+{
+  if (reset_work)
+    {
+      ht->status = HEXB_STAT_NEW_WORK_CLEAR_OLD;
+    }
+  else
+    {
+      ht->status = HEXB_STAT_NEW_WORK;
+    }
+  memcpy (ht->midstate, work->midstate, 32);
+  memcpy (ht->merkle, work->data + 64, 12);
+  ht->id = (uint8_t) work->subid;
+  BITFURY_MS3compute (work, ht);
+}
+
+static inline void
+hexminerb_init_task (struct hexminerb_task *ht, struct hexminerb_info *info)
+{
+
+  ht->startbyte = 0x53;
+  ht->datalength = (uint8_t) ((HEXMINERB_TASK_SIZE - 6) / 2);
+  ht->command = 0x57;
+  ht->address = htole16 (HEXB_WORKQUEUE_ADR);
+  libhexb_setvoltage (info->core_voltage, &ht->refvoltage);
+  ht->chipcount = htole16 (info->asic_count);
+  ht->hashclock = htole16 ((uint16_t) info->frequency);
+}
+static void *
+hexminerb_send_tasks (void *userdata)
+{
+  struct cgpu_info *hexminerb = (struct cgpu_info *) userdata;
+  struct hexminerb_info *info = hexminerb->device_data;
+  struct hexminerb_task *ht;
+  struct thr_info *thr = info->thr;
+  struct work *work = NULL;
+  struct work *tmpwork = NULL;
+  unsigned int work_block_local;
+  char threadname[24];
+  int write_pos = 0;
+  int jobs_to_send = 1;
+  bool reset_work = true;
+  int send_jobs, roll, ret;
+  
+  snprintf (threadname, 24, "hexb_send/%d", hexminerb->device_id);
+  RenameThread (threadname);
+  //libhexb_reset (hexminerb);
+  ht = calloc (sizeof (struct hexminerb_task), 1);
+  
+  hexminerb_init_task (ht, info);
+
+  while (!libhexb_usb_dead (hexminerb))
+    {
+      send_jobs = 0;
+                
+      while ((work_block_local != work_block) || (send_jobs < jobs_to_send && (info->wr_status == HEXB_STAT_IDLE
+                                || info->wr_status == HEXB_STAT_NEW_WORK))
+             || reset_work)
+        {
+        again:
+          if (!work)
+            {
+              roll = 0;
+              work = get_work (thr, thr->id);
+              work->ping = 1;
+              if(work_block_local != work_block) {
+        	 			reset_work = true;
+        	 			work_block_local = work_block;
+        			}
+            }
+            
+        if (stale_work (work, false))
+        {
+          free_work (work);
+          work = NULL;
+          goto again;
+        }   
+          
+          if (write_pos >= HEXMINERB_ARRAY_SIZE_REAL || reset_work)
+            write_pos = 0;
+          
+              work->subid = write_pos;
+              tmpwork = copy_work_noffset_fast_no_id (work, roll++);
+              hexminerb_create_task (reset_work, ht,
+                                 tmpwork);
+              
+              mutex_lock (&info->lock);
+          		free_work (info->hexworks[write_pos]);
+              info->hexworks[write_pos] = tmpwork;
+              mutex_unlock (&info->lock);
+              
+              if (work->drv_rolllimit)
+                {
+                  work->drv_rolllimit--;
+#ifdef DBG_HEXB
+                  info->roled++;
+#endif
+                }
+              else
+                {
+                  free_work (work);
+                  work = NULL;
+                }
+              ret = hexminerb_send_task (ht, hexminerb);
+#ifdef DBG_HEXB
+          info->write_pos = write_pos;
+#endif
+          write_pos++;
+          send_jobs++;
+
+          if (ret == HEXMINERB_TASK_SIZE && reset_work)
+            {
+              reset_work = false; 
+              send_jobs-=2;
+            }
+        }
+//330
+     if(!reset_work)
+      cgsem_mswait (&info->wsem, 44);
+    }
+  if (work)
+    free_work (work);
+  free (ht);
+  pthread_exit (NULL);
+}
+
+static struct cgpu_info *
+hexminerb_detect_one (libusb_device * dev, struct usb_find_devices *found)
+{
+
+  int miner_count, asic_count, frequency;
+  int this_option_offset = ++option_offset;
+  struct hexminerb_info *info;
+  struct cgpu_info *hexminerb;
+  bool configured;
+  int i = 0;
+
+  hexminerb = usb_alloc_cgpu (&hexminerb_drv, HEXB_MINER_THREADS);
+  if (!usb_init (hexminerb, dev, found))
+    {
+      usb_uninit (hexminerb);
+      return NULL;
+    }
+  hexminerb->device_data = calloc (sizeof (struct hexminerb_info), 1);
+
+  if (unlikely (!(hexminerb->device_data)))
+    {
+      hexminerb->device_data = NULL;
+      usb_uninit (hexminerb);
+      return NULL;
+    }
+  configured =
+    libhexb_get_options (this_option_offset, &asic_count, &frequency);
+  if (opt_hexminerb_core_voltage < HEXB_MIN_COREMV
+      || opt_hexminerb_core_voltage > HEXB_MAX_COREMV)
+    {
+
+      applog
+        (LOG_ERR,
+         "Invalid hexminerb-voltage %d must be %dmV - %dmV",
+         opt_hexminerb_core_voltage, HEXB_MIN_COREMV, HEXB_MAX_COREMV);
+      free (hexminerb->device_data);
+      hexminerb->device_data = NULL;
+      usb_uninit (hexminerb);
+      return NULL;
+    }
+  info = hexminerb->device_data;
+  info->hexworks = calloc (sizeof (struct work *), HEXMINERB_ARRAY_SIZE);
+  if (unlikely (!(info->hexworks)))
+    {
+      free (hexminerb->device_data);
+      hexminerb->device_data = NULL;
+      usb_uninit (hexminerb);
+      return NULL;
+    }
+  
+  info->wr = (struct workb_result *) malloc (sizeof (struct workb_result));
+  info->array_nonce_cache = calloc (16, sizeof (struct chip_resultsb));
+  info->readbuf = calloc (HEXB_HASH_BUF_SIZE, sizeof (unsigned char));
+  
+  info->hash_read_pos = 0;
+  info->hash_write_pos = 0;
+  info->shut_read = false;
+  info->shut_write = false;
+  info->shut_reset = false;
+  info->wr_status = HEXB_STAT_IDLE;
+  info->miner_count = HEXB_DEFAULT_MINER_NUM;
+  info->asic_count = HEXB_DEFAULT_ASIC_NUM;
+  info->frequency = HEXB_DEFAULT_FREQUENCY;
+  info->pic_voltage_readings = HEXB_DEFAULT_CORE_VOLTAGE;
+  info->core_voltage = opt_hexminerb_core_voltage;
+  if (configured)
+    {
+      info->asic_count = asic_count;
+      info->frequency = frequency;
+    }
+  if (!add_cgpu (hexminerb))
+    {
+      free (info->hexworks);
+      free (hexminerb->device_data);
+      hexminerb->device_data = NULL;
+      hexminerb = usb_free_cgpu (hexminerb);
+      usb_uninit (hexminerb);
+      return NULL;
+    }
+  while (i < HEXMINERB_ARRAY_SIZE)
+    {
+      info->hexworks[i] = calloc (1, sizeof (struct work));
+      info->hexworks[i]->pool = NULL;
+      i++;
+    }
+
+  return hexminerb;
+}
+
+static void
+hexminerb_detect (bool __maybe_unused hotplug)
+{
+  usb_detect (&hexminerb_drv, hexminerb_detect_one);
+}
+
+static void
+do_hexminerb_close (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerb = thr->cgpu;
+  struct hexminerb_info *info = hexminerb->device_data;
+  int i = 0;
+  cgsleep_ms (500);
+  
+  pthread_join (info->write_thr, NULL);
+  pthread_mutex_destroy (&info->lock);
+#ifdef DBG_HEXB
+  pthread_join (info->dbg_thr, NULL);
+#endif
+  cgsem_destroy (&info->wsem);
+  
+  while (i < HEXMINERB_ARRAY_SIZE)
+    {
+      free_work (info->hexworks[i]);
+      i++;
+    }
+  free (info->hexworks);
+  free (info->readbuf);
+  free (info->array_nonce_cache);
+  free (info->wr);
+  //usb_uninit(hexminerb);
+  //Hotplug fucks on full mem free :) 
+  //free (hexminerb->device_data);
+  //hexminerb->device_data = NULL;
+  //thr->cgpu = usb_free_cgpu(hexminerb);
+
+}
+
+static void
+hexminerb_shutdown (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerb = thr->cgpu;
+  struct hexminerb_info *info = hexminerb->device_data;
+
+  cgsem_post (&info->wsem);
+  
+  do_hexminerb_close (thr);
+  
+  usb_nodev(hexminerb);
+}
+
+
+#ifdef DBG_HEXB
+static void *
+hexminerb_get_stats (void *userdata)
+{
+  struct cgpu_info *hexminerb = (struct cgpu_info *) userdata;
+  struct hexminerb_info *info = hexminerb->device_data;
+  char threadname[24];
+  snprintf (threadname, 24, "hexb_dbg/%d", hexminerb->device_id);
+  RenameThread (threadname);
+
+  while (!libhexb_usb_dead (hexminerb))
+    {
+
+      cgsleep_ms (30 * 1000);
+
+
+    }
+  pthread_exit (NULL);
+}
+#endif
+
+static bool
+hexminerb_thread_init (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerb = thr->cgpu;
+  struct hexminerb_info *info = hexminerb->device_data;
+  info->thr = thr;
+  
+ mutex_init (&info->lock);
+ cgsem_init (&info->wsem);
+
+  if (pthread_create
+      (&info->write_thr, NULL, hexminerb_send_tasks, (void *) hexminerb))
+    quit (1, "Failed to create hexminerb write_thr");
+
+  return true;
+}
+
+
+static int64_t
+hexminerb_scanhash (struct thr_info *thr)
+{
+
+  struct cgpu_info *hexminerb = thr->cgpu;
+  struct hexminerb_info *info = hexminerb->device_data;
+  
+  uint32_t nonce;
+  int found;
+ 
+  int ret_r = 0;
+  
+  int64_t hash_count = 0;
+  
+  if (libhexb_usb_dead (hexminerb))
+    return -1;
+
+  if (info->hash_write_pos + HEXB_USB_R_SIZE >= HEXB_HASH_BUF_SIZE)
+        {
+          info->hash_write_pos = info->hash_write_pos - info->hash_read_pos;
+          memcpy (info->readbuf, info->readbuf + info->hash_read_pos, info->hash_write_pos);
+          info->hash_read_pos = 0;
+   }
+   
+   
+   if (info->hash_write_pos - info->hash_read_pos > 7)
+        {
+        again:
+          ret_r =
+            libhexb_eatHashData (info->wr, info->readbuf, &info->hash_read_pos,
+                                 &info->hash_write_pos);
+          if (ret_r > HEXB_BUF_DATA)
+            goto out;
+
+          info->wr_status = info->wr->status;
+          if (info->wr->datalength == 1)
+            goto done;
+
+          if (info->wr->lastnonceid > HEXMINERB_ARRAY_SIZE_REAL)
+            info->wr->lastnonceid = 0;
+
+          if (info->wr->prevnonceid > HEXMINERB_ARRAY_SIZE_REAL)
+            info->wr->prevnonceid = 0;
+
+          if (info->wr->lastchippos > 15)
+            info->wr->lastchippos = 15;
+
+          if (libhexb_cachenonce
+              (&info->array_nonce_cache[info->wr->lastchippos], info->wr->lastnonce))
+            {
+              nonce = decnonce (htole32 (info->wr->lastnonce));
+
+              found = hexminerb_predecode_nonce (hexminerb, thr, nonce,
+                                                 info->wr->lastnonceid);
+#ifdef DBG_HEXB
+              if (found > 0)
+                info->read_pos = info->wr->lastnonceid;
+
+#endif
+              if (found == 0)
+                {
+                  found = hexminerb_predecode_nonce (hexminerb, thr, nonce,
+                                                     info->wr->prevnonceid);
+#ifdef DBG_HEXB
+                  if (found > 0)
+                    info->read_pos = info->wr->prevnonceid;
+
+#endif
+                }
+
+              if (found > 0)
+                {
+                  if (hash_count == 0)
+                    libhexb_getvoltage (htole16 (info->wr->lastvoltage),
+                                        &info->pic_voltage_readings);
+                  
+                  hash_count += found;
+                  
+                  info->matching_work[info->wr->lastchippos]++;
+                }
+              else
+                {
+                  //Due to implementation there is no way for now to count them. 
+                  //The number is inaccurate and too big!
+
+                  //inc_hw_errors (thr);
+                }
+            }
+          else
+            {
+              info->dupe[info->wr->lastchippos]++;
+            }
+        out:
+          if (ret_r == HEXB_BUF_ERR)
+            {
+              info->usb_r_errors++;
+            }
+        done:
+          //More nonces 
+          if (info->hash_write_pos - info->hash_read_pos >= HEXB_MAX_WORK_SIZE)
+            goto again;
+        }
+
+
+      ret_r =
+        libhexb_readHashData (hexminerb, info->readbuf, &info->hash_write_pos,
+                              HEXMINERB_BULK_READ_TIMEOUT, true);
+   
+  
+      hash_count = (int64_t) (0xffffffffull * hash_count);
+      
+  
+  
+  
+  if (libhexb_usb_dead (hexminerb))
+    return -1;
+
+  return hash_count;
+
+}
+
+static void
+get_hexminerb_statline_before (char *buf, size_t bufsiz,
+                               struct cgpu_info *hexminerb)
+{
+  if (!hexminerb->device_data)
+		return;
+  struct hexminerb_info *info = hexminerb->device_data;
+  tailsprintf (buf, bufsiz, "%3d %4d/%4dmV", info->frequency,
+               info->core_voltage, info->pic_voltage_readings);
+}
+
+static struct api_data *
+hexminerb_api_stats (struct cgpu_info *cgpu)
+{
+
+  struct api_data *root = NULL;
+  struct hexminerb_info *info = cgpu->device_data;
+  if (!info)
+		return NULL;
+  uint64_t dh64, dr64;
+  double dev_runtime;
+  struct timeval now;
+  int i;
+  char displayed_hashes[16], displayed_rolling[16];
+  double hwp =
+    (cgpu->hw_errors +
+     cgpu->diff1) ? (double) (cgpu->hw_errors) / (double) (cgpu->hw_errors +
+                                                           cgpu->diff1) : 0;
+  if (cgpu->dev_start_tv.tv_sec == 0)
+    dev_runtime = total_secs;
+  else
+    {
+      cgtime (&now);
+      dev_runtime = tdiff (&now, &(cgpu->dev_start_tv));
+    }
+  if (dev_runtime < 1.0)
+    dev_runtime = 1.0;
+  dh64 = (double) cgpu->total_mhashes / dev_runtime * 1000000ull;
+  dr64 = (double) cgpu->rolling * 1000000ull;
+  suffix_string (dh64, displayed_hashes, sizeof (displayed_hashes), 4);
+  suffix_string (dr64, displayed_rolling, sizeof (displayed_rolling), 4);
+  root = api_add_string (root, "MHS 5s", displayed_rolling, true);
+  root = api_add_string (root, "MHS av", displayed_hashes, true);
+  root = api_add_int (root, "Hardware Errors", &(cgpu->hw_errors), true);
+  root = api_add_percent (root, "Hardware Errors%", &hwp, true);
+  root = api_add_int (root, "USB Read Errors", &(info->usb_r_errors), true);
+  root = api_add_int (root, "USB Write Errors", &(info->usb_w_errors), true);
+  root =
+    api_add_int (root, "USB Reset Count", &(info->usb_reset_count), true);
+
+  root =
+    api_add_time (root, "Last Share Time", &(cgpu->last_share_pool_time),
+                  true);
+  root = api_add_int (root, "Chip Count", &(info->asic_count), true);
+  root = api_add_int (root, "Frequency", &(info->frequency), true);
+  root = api_add_int (root, "Core Voltage", &(info->core_voltage), true);
+  root =
+    api_add_int (root, "PIC Voltage Readings", &(info->pic_voltage_readings),
+                 true);
+  for (i = 0; i < info->asic_count; i++)
+    {
+      char mcw[24];
+      sprintf (mcw, "Chip%d Nonces", i + 1);
+      root = api_add_int (root, mcw, &(info->matching_work[i]), true);
+      sprintf (mcw, "Chip%d Dupes", i + 1);
+      root = api_add_int (root, mcw, &(info->dupe[i]), true);
+    }
+  return root;
+}
+
+
+
+struct device_drv hexminerb_drv = {
+  .drv_id = DRIVER_hexminerb,
+  .dname = "hexminerb",
+  .name = "HEXb",
+  .thread_init = hexminerb_thread_init,
+  .drv_detect = hexminerb_detect,
+  .hash_work = hash_queued_work,
+  .scanwork = hexminerb_scanhash,
+  .flush_work = hexminerb_flush_work,
+  .get_api_stats = hexminerb_api_stats,
+  .get_statline_before = get_hexminerb_statline_before,
+  .thread_shutdown = hexminerb_shutdown,
+};
--- cg_o/driver-hexminerb.h	1970-01-01 02:00:00.000000000 +0200
+++ cgminer/driver-hexminerb.h	2014-04-11 11:33:18.853851446 +0300
@@ -0,0 +1,148 @@
+/*$T indentinput.h GC 1.140 10/16/13 10:20:01 */
+/*
+ * Copyright 2013 Avalon project Copyright 2013 Con Kolivas <kernel@kolivas.org>
+ * This program is free software;
+ * you can redistribute it and/or modify it under the terms of the GNU General
+ * Public License as published by the Free Software Foundation;
+ * either version 3 of the License, or (at your option) any later version. See
+ * COPYING for more details. Thank you guys!
+ */
+#ifndef HEXB_H
+#define HEXB_H
+#ifdef USE_HEXMINERB
+//#define DBG_HEXB 
+#include "util.h"
+/* hexminerb_task/work_reply status Definitions: */
+#define HEXB_STAT_IDLE					0       /* Idle or data already Sent to the buffer */
+#define HEXB_STAT_NEW_WORK				6       /* Request for write in the buffer */
+#define HEXB_STAT_WAITING				2       /* Wait For Buffer Empty Position */
+#define HEXB_STAT_CLR_BUFF				3       /* Force Buffer Empty */
+#define HEXB_STAT_STOP_REQ				4       /* Stop Request */
+#define HEXB_STAT_NEW_WORK_CLEAR_OLD		5       /* Clear Buffers and after that fill the first buffer */
+#define HEXB_STAT_UNUSED					7
+
+/* libhexb_eatHashData/BUF_reply status Definitions: */
+#define HEXB_BUF_DATA 0
+#define HEXB_BUF_ERR  1
+#define HEXB_BUF_SKIP 2
+
+
+#define HEXMINERB_ARRAY_PIC_SIZE		64
+#define HEXMINERB_ARRAY_SIZE                  HEXMINERB_ARRAY_PIC_SIZE * 4
+#define HEXMINERB_ARRAY_SIZE_REAL	HEXMINERB_ARRAY_SIZE - 2
+//#define HEXMINERB_ARRAY_SIZE 253
+#define HEXB_NONCE_CASH_SIZE				16
+#define HEXMINERB_PUSH_THRESH		8       /* At least 2 queued works available to be written to PIC */
+#define HEXMINERB_ARRAY_MAX_POP		1
+#define HEXB_USB_R_SIZE					64
+#define HEXB_USB_WR_SIZE					64
+#define HEXB_HASH_BUF_SIZE				2048
+#define HEXB_USB_R_BAD_ID					32
+#define HEXB_USB_WR_TIME_OUT				500
+#define HEXMINERB_BULK_READ_TIMEOUT 1000
+#define HEXB_MINER_THREADS			1
+#define HEXB_DEFAULT_MINER_NUM		0x01
+#define HEXB_DEFAULT_ASIC_NUM		0x10
+#define HEXB_MIN_FREQUENCY			0       //Bits / 10
+#define HEXB_MAX_FREQUENCY			610     //Bits / 10
+#define HEXB_DEFAULT_FREQUENCY		540     //Bits / 10 - That is Max which works 40 GHs for 16 chips
+#define HEXB_DEFAULT_CORE_VOLTAGE	840     /* in millivolts */
+#define HEXB_MIN_COREMV				700     /* in millivolts */
+#define HEXB_MAX_COREMV	1101    /* in millivolts */
+struct chip_resultsb
+{
+  uint8_t nonce_cache_write_pos;
+  uint32_t nonces[HEXB_NONCE_CASH_SIZE];
+};
+struct workb_result
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint32_t lastnonce;           //1x32
+  uint8_t lastnonceid;          //1x32
+  uint8_t status;
+  uint16_t lastvoltage;         //1x32
+  uint8_t lastchippos;          //1x32
+  uint8_t prevnonceid;          //16 bit words aligned with lastchippos
+  uint8_t csum;
+
+} __attribute__ ((packed, aligned (4)));
+
+struct hexminerb_info
+{
+  int miner_count;
+  int asic_count;
+  int core_voltage;
+  int frequency;
+  int usb_r_errors;
+  int usb_w_errors;
+  int usb_reset_count;
+  bool shut_read;
+  bool shut_write;
+  bool shut_reset;
+  int pic_voltage_readings;
+  int hash_read_pos;
+  int hash_write_pos;
+  int dupe[HEXB_DEFAULT_ASIC_NUM];
+  int matching_work[HEXB_DEFAULT_ASIC_NUM];
+  unsigned char *readbuf;
+  struct workb_result *wr;
+  struct chip_resultsb *array_nonce_cache;
+  uint8_t wr_status;
+  pthread_t write_thr;
+  pthread_mutex_t lock;
+  cgsem_t wsem;
+  struct thr_info *thr;
+  struct work **hexworks;
+  #ifdef DBG_HEXB
+  pthread_t dbg_thr;
+  int read_pos;
+  int write_pos;
+  uint64_t totworks;
+  uint64_t sub_nonces;
+  uint64_t hwerr;
+  int roled;
+  #endif
+};
+
+struct hexminerb_task
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint32_t merkle[3];
+  uint32_t a1;                  //midstate3[0]
+  uint32_t a0;                  //midstate3[1]
+  uint32_t e2;                  //midstate3[2]
+  uint32_t e1;                  //midstate3[3]
+  uint32_t e0;                  //midstate3[4]
+  uint8_t midstate[32];
+  uint32_t a2;                  //midstate3[5]
+  uint32_t startnonce;          //midstate3[6]
+  uint8_t id;
+  uint8_t status;
+  uint16_t hashclock;
+  uint16_t chipcount;
+  uint16_t refvoltage;
+  uint16_t reftemperature;      //midstate3[7]
+  uint16_t reffanrpm;           //midstate3[7]
+  uint8_t csum;
+  uint8_t pad[2];
+} __attribute__ ((packed, aligned (4)));
+#define HEXB_WORKANSWER_ADR	0x3000
+#define HEXB_WORKQUEUE_ADR	0x4008
+#define HEXB_PTCON_ADR		0x0C00
+#define HEXB_START_STOP_ADR	0x646E
+#define HEXMINERB_TASK_SIZE	(sizeof(struct hexminerb_task) - 2)
+#define HEXB_MAX_WORK_SIZE		(sizeof(struct workb_result))
+#define HEXB_BASE_WORK_SIZE		6       /* Min uint8_t startbyte + uint8_t datalength + uint8_t command + uint16_t
+                                                 * address;
+                                                 * + uint8_t csum */
+extern int opt_hexminerb_core_voltage;
+extern char *libhexb_set_config_voltage (char *arg);
+extern struct hexminerb_info **hexminerb_info;
+#endif /* USE_HEXMINERB */
+#endif /* HEXB_H */
--- cg_o/libhexb.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer/libhexb.c	2014-04-11 11:33:09.005309322 +0300
@@ -0,0 +1,452 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:20:34 */
+const uint32_t SHA_M[64] = {
+  0x428a2f98, 0x71374491, 0xb5c0fbcf
+};
+
+#define Ch(x, y, z) ((x & (y ^ z)) ^ z)
+#define Maj(x, y, z) ((x & (y | z)) | (y & z))
+#define ROTR(x, n) ((x >> n) | (x << (32 - n)))
+#define S0(x) (ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22))
+#define S1(x) (ROTR(x, 6) ^ ROTR(x, 11) ^ ROTR(x, 25))
+//0x2800000, 0x2C00000, 0x400000 - CPU wasteed No valid results for the moment
+#define BT_OFFSETS_B 6
+//static const uint32_t bf_offsetsu[] = {-0x800000, 0, 0xffc00000, 0xff800000, 0x02800000, 0x02C00000, 0x00400000};
+const uint32_t bf_offsetsb[] =
+  { -0x800000, 0, -0x400000, 0x2800000, 0x2C00000, 0x400000 };
+
+static void
+BITFURY_MS3compute (struct work *work, struct hexminerb_task *ht)
+{
+  uint32_t state[8];
+  uint32_t data[3];
+  memcpy (&state, work->midstate, 32);
+  memcpy (&data, work->data + 64, 12);
+  uint32_t a, b, c, d, e, f, g, h, ne, na;
+  int i;
+#if defined(__BIG_ENDIAN__) || defined(MIPSEB)
+  for (i = 0; i < 8; i++)
+    state[i] = htole32 (state[i]);
+  for (i = 0; i < 3; i++)
+    data[i] = htole32 (data[i]);
+#endif
+  a = state[0];
+  b = state[1];
+  c = state[2];
+  d = state[3];
+  e = state[4];
+  f = state[5];
+  g = state[6];
+  h = state[7];
+  for (i = 0; i < 3; i++)
+    {
+      ne = data[i] + SHA_M[i] + h + Ch (e, f, g) + S1 (e) + d;
+      na = data[i] + SHA_M[i] + h + Ch (e, f, g) + S1 (e) + S0 (a) +
+        Maj (a, b, c);
+      d = c;
+      c = b;
+      b = a;
+      a = na;
+      h = g;
+      g = f;
+      f = e;
+      e = ne;
+    }
+#if defined(__BIG_ENDIAN__) || defined(MIPSEB)
+  a = htole32 (a);
+  b = htole32 (b);
+  c = htole32 (c);
+  d = htole32 (d);
+  e = htole32 (e);
+  f = htole32 (f);
+  g = htole32 (g);
+  h = htole32 (h);
+#endif
+  memcpy (&ht->a1, &h, 4);
+  memcpy (&ht->a0, &g, 4);
+  memcpy (&ht->e2, &f, 4);
+  memcpy (&ht->e1, &e, 4);
+  memcpy (&ht->e0, &d, 4);
+  memcpy (&ht->a2, &c, 4);
+  memcpy (&ht->startnonce, &b, 4);
+  memcpy (&ht->reftemperature, &a, 4);
+}
+
+static bool
+libhexb_cachenonce (struct chip_resultsb *nonce_cache, uint32_t nonce)
+{
+  int i = 0;
+  while (i < HEXB_NONCE_CASH_SIZE && nonce_cache->nonces[i] != nonce)
+    i++;
+  if (i < HEXB_NONCE_CASH_SIZE)
+    return false;
+  //Rotate
+  if (nonce_cache->nonce_cache_write_pos == HEXB_NONCE_CASH_SIZE)
+    nonce_cache->nonce_cache_write_pos = 0;
+  nonce_cache->nonces[nonce_cache->nonce_cache_write_pos++] = nonce;
+  return true;
+}
+
+char *
+libhexb_set_config_voltage (char *arg)
+{
+  int val1, ret;
+  ret = sscanf (arg, "%d", &val1);
+  if (ret < 1)
+    return "No values passed to hexminerb-voltage";
+  if (val1 < HEXB_MIN_COREMV || val1 > HEXB_MAX_COREMV)
+    return "Invalid value passed to hexminerb-voltage";
+  opt_hexminerb_core_voltage = val1;
+  return NULL;
+}
+
+static void
+libhexb_csum (unsigned char *startptr, unsigned char *endptr,
+              unsigned char *resptr)
+{
+  unsigned char *b = startptr;
+  uint8_t sum = 0;
+  while (b < endptr)
+    sum += *b++;
+  memcpy (resptr, &sum, 1);
+}
+
+static bool
+libhexb_get_options (int this_option_offset, int *asic_count, int *frequency)
+{
+  char buf[BUFSIZ + 1];
+  char *ptr, *comma, *colon, *colon2, *colon3, *colon4;
+  bool timeout_default;
+  size_t max;
+  int i, tmp;
+
+  if (opt_hexminerb_options == NULL)
+    buf[0] = '\0';
+  else
+    {
+      ptr = opt_hexminerb_options;
+      for (i = 0; i < this_option_offset; i++)
+        {
+          comma = strchr (ptr, ',');
+          if (comma == NULL)
+            break;
+          ptr = comma + 1;
+        }
+      comma = strchr (ptr, ',');
+      if (comma == NULL)
+        max = strlen (ptr);
+      else
+        max = comma - ptr;
+      if (max > BUFSIZ)
+        max = BUFSIZ;
+      strncpy (buf, ptr, max);
+      buf[max] = '\0';
+    }
+  if (!(*buf))
+    return false;
+  colon = strchr (buf, ':');
+  if (colon)
+    *(colon++) = '\0';
+  tmp = atoi (buf);
+  if (tmp > 0 && tmp <= HEXB_DEFAULT_ASIC_NUM)
+    *asic_count = tmp;
+  else
+    {
+      quit (1,
+            "Invalid hexminerb-options for " "asic_count (%s) must be 1 ~ %d",
+            buf, HEXB_DEFAULT_ASIC_NUM);
+    }
+  if (colon && *colon)
+    {
+      tmp = atoi (colon);
+      if (tmp < HEXB_MIN_FREQUENCY || tmp > HEXB_MAX_FREQUENCY)
+        {
+          quit
+            (1,
+             "Invalid hexminerb-options for frequency (%s) must be %d <= frequency <= %d",
+             colon, HEXB_MIN_FREQUENCY, HEXB_MAX_FREQUENCY);
+        }
+      *frequency = tmp;
+    }
+  return true;
+}
+
+static bool
+libhexb_usb_dead (struct cgpu_info *hexminerb)
+{
+  struct cg_usb_device *usbdev;
+  struct hexminerb_info *info = hexminerb->device_data;
+  
+  usbdev = hexminerb->usbdev;
+  bool ret = (usbdev == NULL
+          || usbdev->handle == NULL
+          || hexminerb->shutdown
+          || info->shut_read  || info->shut_write || info->shut_reset
+          || hexminerb->usbinfo.nodev || hexminerb->deven != DEV_ENABLED);
+  if(ret)        
+  	hexminerb->shutdown = true;
+  	
+  return ret;
+}
+
+
+static int
+libhexb_sendHashData (struct cgpu_info *hexminerb, unsigned char *sendbuf,
+                      size_t buf_len)
+{
+  struct hexminerb_info *info = hexminerb->device_data;
+  struct cg_usb_device *usbdev;
+  int wrote = 0, written = 0;
+  int err = LIBUSB_SUCCESS;
+
+  usbdev = hexminerb->usbdev;
+  if (libhexb_usb_dead (hexminerb))
+    goto out;
+  while (written < buf_len && err == LIBUSB_SUCCESS)
+    {
+      err = libusb_bulk_transfer
+        (usbdev->handle,
+         0x02,
+         sendbuf + written,
+         MIN (HEXB_USB_WR_SIZE, buf_len - written), &wrote,
+         HEXB_USB_WR_TIME_OUT);
+      if (err == LIBUSB_SUCCESS)
+        written += wrote;
+    }
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+  	info->shut_write = true; 
+	    
+  return written;
+}
+
+static void
+libhexb_reset (struct cgpu_info *hexminerb)
+{
+
+  struct hexminerb_info *info = hexminerb->device_data;
+  struct cg_usb_device *usbdev;
+  int err = LIBUSB_SUCCESS;
+
+  usbdev = hexminerb->usbdev;
+  if (libhexb_usb_dead (hexminerb))
+    goto out;
+  err = libusb_reset_device (usbdev->handle);
+out:
+ 
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+	   info->shut_reset = true; 
+     
+  info->usb_reset_count++;
+}
+
+static int libhexb_readHashData
+  (struct cgpu_info *hexminerb,
+   unsigned char *hash, int *hash_write_pos, int timeout, bool read_once)
+{
+  struct hexminerb_info *info = hexminerb->device_data;
+  struct cg_usb_device *usbdev;
+  int read = 0, total = 0;
+  int err = LIBUSB_SUCCESS;
+
+  usbdev = hexminerb->usbdev;
+  if (libhexb_usb_dead (hexminerb))
+    goto out;
+  while (*hash_write_pos + HEXB_USB_R_SIZE < HEXB_HASH_BUF_SIZE
+         && err == LIBUSB_SUCCESS)
+    {
+      err =
+        libusb_bulk_transfer (usbdev->handle, 0x82, hash + *hash_write_pos,
+                              HEXB_USB_R_SIZE, &read, timeout);
+      if (err == LIBUSB_SUCCESS)
+        {
+          *hash_write_pos += read;
+          total += read;
+        }
+      if (read_once)
+        break;
+    }
+
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    {
+      info->shut_read = true; 
+      cgsem_post (&info->wsem);    
+    }
+  
+  return err;
+}
+
+static uint32_t
+decnonce (uint32_t in)
+{
+  uint32_t out;
+  /* First part load */
+  out = (in & 0xFF) << 24;
+  in >>= 8;
+  /* Byte reversal */
+  in = (((in & 0xaaaaaaaa) >> 1) | ((in & 0x55555555) << 1));
+  in = (((in & 0xcccccccc) >> 2) | ((in & 0x33333333) << 2));
+  in = (((in & 0xf0f0f0f0) >> 4) | ((in & 0x0f0f0f0f) << 4));
+  out |= (in >> 2) & 0x3FFFFF;
+  /* Extraction */
+  if (in & 1)
+    out |= (1 << 23);
+  if (in & 2)
+    out |= (1 << 22);
+  out -= 0x800004;
+  return out;
+}
+
+  /*
+  double pool_diff;
+  char *mjob_id;
+  cg_rlock(&work->pool->data_lock);
+	pool_diff = work->pool->sdiff;
+	mjob_id = strdup(work->pool->swork.job_id);
+	
+	cg_runlock(&work->pool->data_lock);
+  //work->gbt
+    	  if(work->sdiff != pool_diff) {
+    	  	//free(work->job_id);
+          //work->job_id = mjob_id; 	
+          	applog(LOG_ERR, "Retarget work->work_difficulty %f,work->sdiff %f, pool_diff %f, work->job_id %s, mjob_id %s",
+          	work->work_difficulty, work->sdiff,pool_diff, work->job_id,mjob_id);
+           //work->sdiff = pool_diff;
+           //set_target(work->target, work->sdiff);
+           //work->work_difficulty = work->sdiff;
+           //calc_diff(work, work->sdiff); 
+        }
+  */
+
+static int
+bitfury_checkresults (struct thr_info *thr, struct work *work, uint32_t nonce)
+{
+	#ifdef DBG_HEXB
+	struct cgpu_info *hexminerb = thr->cgpu;
+  struct hexminerb_info *info = hexminerb->device_data;
+  #endif
+  int i;
+  
+  for (i = 0; i < BT_OFFSETS_B; i++)
+    {
+    	
+      if (test_nonce (work, nonce + bf_offsetsb[i]))
+        {
+       
+          submit_tested_work_no_clone (thr, work, true);
+          
+          return 1;
+        }
+    }
+  free_work (work);
+          
+  return 0;
+}
+
+static int
+hexminerb_predecode_nonce (struct cgpu_info *hexminerb, struct thr_info *thr,
+                           uint32_t nonce, uint8_t work_id)
+{
+  struct hexminerb_info *info = hexminerb->device_data;
+  struct work *work_sub;
+  mutex_lock (&info->lock);
+  if(info->hexworks[work_id]->pool==NULL) {
+  	mutex_unlock (&info->lock);
+  	return 0;
+	}
+
+  work_sub = copy_work_noffset_fast_no_id (info->hexworks[work_id], 0);
+  mutex_unlock (&info->lock);
+
+
+  return bitfury_checkresults (thr, work_sub, nonce);
+
+}
+
+static void
+libhexb_getvoltage (uint16_t wr_bukvoltage, int *info_pic_voltage_readings)
+{
+  float voltagehuman;
+  voltagehuman =
+    (float) ((float) wr_bukvoltage * (float) 1000 * (float) 3.3 /
+             ((1 << 12) - 1));
+  *info_pic_voltage_readings = (int) voltagehuman;
+}
+
+static void
+libhexb_setvoltage (int info_voltage, uint16_t * refvoltage)
+{
+  uint16_t voltageadc;
+  voltageadc =
+    (uint16_t) ((float) info_voltage / (float) 1000 / (float) 3.3 *
+                ((1 << 12) - 1));
+  *refvoltage = htole16 (voltageadc);
+}
+
+static int
+libhexb_eatHashData (struct workb_result *wr, unsigned char *hash,
+                     int *hash_read_pos, int *hash_write_pos)
+{
+  uint8_t psum;
+  int wrpos;
+  unsigned char *csum_pos;
+  bool ok;
+eat:
+  while (*hash_read_pos < *hash_write_pos && hash[*hash_read_pos] != 0x53)
+    {
+      *hash_read_pos += 1;
+    }
+  if (*hash_write_pos - *hash_read_pos < HEXB_BASE_WORK_SIZE + 2)
+    return HEXB_BUF_SKIP;
+  memcpy ((char *) &wr->startbyte, &hash[*hash_read_pos],
+          HEXB_BASE_WORK_SIZE - 1);
+
+  wr->address = htole16 (wr->address);
+
+  /* Address is outside be strict to avoid mem corruption - not fancy but it works */
+
+  ok = (wr->command == 0x52) &&
+    ((wr->address == HEXB_WORKANSWER_ADR && wr->datalength == 0x05)
+     || (wr->address == HEXB_WORKANSWER_ADR + 4 && wr->datalength == 1));
+  if (!ok)
+    {
+      *hash_read_pos += 1;
+      goto eat;
+    }
+  if (*hash_write_pos - *hash_read_pos <
+      HEXB_BASE_WORK_SIZE + wr->datalength * 2)
+    return HEXB_BUF_SKIP;
+  csum_pos =
+    hash + *hash_read_pos + HEXB_BASE_WORK_SIZE + wr->datalength * 2 - 1;
+  //Crap?
+  if (csum_pos - hash < HEXB_HASH_BUF_SIZE)
+    {
+//That was writing somewhere and corrupting memory because of faulty usb reads....
+      libhexb_csum (hash + *hash_read_pos, csum_pos, &psum);
+      if (psum != *csum_pos)
+        {
+
+          *hash_read_pos += 1;
+          return HEXB_BUF_ERR;
+        }
+    }
+  else
+    {
+#ifdef DBG_HEXB_BUF
+      applog (LOG_ERR,
+              "Lost Nonce/Status due to incomplete usb read?? wr->datalength = %i csum_pos=%i, *hash_write_pos%i, left=%i",
+              wr->datalength, csum_pos, *hash_write_pos,
+              HEXB_HASH_BUF_SIZE - *hash_write_pos);
+#endif
+      *hash_read_pos += 1;
+      return HEXB_BUF_ERR;
+    }
+
+  wrpos = (wr->address - HEXB_WORKANSWER_ADR) + HEXB_BASE_WORK_SIZE - 1;
+  memcpy
+    ((char *) &wr->startbyte + wrpos,
+     &hash[*hash_read_pos + HEXB_BASE_WORK_SIZE - 1], wr->datalength * 2);
+  *hash_read_pos += HEXB_BASE_WORK_SIZE + wr->datalength * 2;
+  return HEXB_BUF_DATA;
+
+}
--- cg_o/Makefile.am	2014-04-06 10:43:59.023487169 +0300
+++ cgminer/Makefile.am	2014-04-10 10:37:32.217862132 +0300
@@ -54,9 +54,9 @@
 cgminer_SOURCES += usbutils.c usbutils.h
 endif
 
-if WANT_LIBBITFURY
-cgminer_SOURCES += libbitfury.c libbitfury.h mcp2210.c mcp2210.h
-endif
+#if WANT_LIBBITFURY
+#cgminer_SOURCES += libbitfury.c libbitfury.h mcp2210.c mcp2210.h
+#endif
 
 # Device drivers
 if HAS_AVALON
@@ -120,6 +120,30 @@
 cgminer_SOURCES += driver-bitmain.c driver-bitmain.h
 endif
 
+if HAS_HEXMINERA
+cgminer_SOURCES += driver-hexminera.c driver-hexminera.h
+endif
+
+if HAS_HEXMINERB
+cgminer_SOURCES += driver-hexminerb.c driver-hexminerb.h
+endif
+
+if HAS_HEXMINERC
+cgminer_SOURCES += driver-hexminerc.c driver-hexminerc.h
+endif
+
+if HAS_HEXMINER8
+cgminer_SOURCES += driver-hexminer8.c driver-hexminer8.h
+endif
+
+if HAS_HEXMINER3
+cgminer_SOURCES += driver-hexminer3.c driver-hexminer3.h
+endif
+
+if HAS_HEXMINERU
+cgminer_SOURCES += driver-hexmineru.c driver-hexmineru.h
+endif
+
 if HAS_MODMINER
 cgminer_SOURCES += driver-modminer.c
 bitstreamsdir = $(bindir)/bitstreams
--- cg_o/miner.h	2014-04-06 10:43:59.023487169 +0300
+++ cgminer/miner.h	2014-04-10 10:37:32.217862132 +0300
@@ -236,6 +236,12 @@
 	DRIVER_ADD_COMMAND(modminer)
 
 #define ASIC_PARSE_COMMANDS(DRIVER_ADD_COMMAND) \
+	DRIVER_ADD_COMMAND(hexminera) \
+	DRIVER_ADD_COMMAND(hexminerb) \
+	DRIVER_ADD_COMMAND(hexminerc) \
+	DRIVER_ADD_COMMAND(hexminer8) \
+	DRIVER_ADD_COMMAND(hexminer3) \
+	DRIVER_ADD_COMMAND(hexmineru) \
 	DRIVER_ADD_COMMAND(bflsc) \
 	DRIVER_ADD_COMMAND(bitfury) \
 	DRIVER_ADD_COMMAND(cointerra) \
@@ -282,6 +288,17 @@
 	POOL_LOADBALANCE,
 	POOL_BALANCE,
 };
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+
+enum default_hex_miner {
+	D_HEXA,
+	D_HEXB,
+	D_HEXC,
+	D_HEX8,
+	D_HEX3,
+};
+extern enum default_hex_miner default_hex_miner;
+#endif
 
 #define TOP_STRATEGY (POOL_BALANCE)
 
@@ -434,6 +451,12 @@
 	struct cg_usb_info usbinfo;
 	bool blacklisted;
 #endif
+#ifdef USE_HEXMINERU
+	// http://ww1.microchip.com/downloads/en/DeviceDoc/22288A.pdf pg 34
+	uint8_t cfg_spi[0x11];
+	// http://ww1.microchip.com/downloads/en/DeviceDoc/22288A.pdf pg 40
+	uint8_t cfg_gpio[0xf];
+#endif
 #if defined(USE_AVALON) || defined(USE_AVALON2)
 	struct work **works;
 	int work_array;
@@ -1008,6 +1031,25 @@
 extern char *opt_bitmain_options;
 extern bool opt_bitmain_hwerror;
 #endif
+
+#ifdef USE_HEXMINERA
+extern char *opt_hexminera_options;
+#endif
+#ifdef USE_HEXMINERB
+extern char *opt_hexminerb_options;
+#endif
+#ifdef USE_HEXMINERC
+extern char *opt_hexminerc_options;
+#endif
+#ifdef USE_HEXMINER8
+extern char *opt_hexminer8_options;
+#endif
+#ifdef USE_HEXMINER3
+extern char *opt_hexminer3_options;
+#endif
+#ifdef USE_HEXMINERU
+extern char *opt_hexmineru_options;
+#endif
 #ifdef USE_USBUTILS
 extern char *opt_usb_select;
 extern int opt_usbdump;
@@ -1355,6 +1397,10 @@
 	struct timeval	tv_work_start;
 	struct timeval	tv_work_found;
 	char		getwork_mode;
+	
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+	bool ping;
+#endif
 };
 
 #ifdef USE_MODMINER
@@ -1402,6 +1448,9 @@
 extern bool test_nonce(struct work *work, uint32_t nonce);
 extern bool test_nonce_diff(struct work *work, uint32_t nonce, double diff);
 extern bool submit_tested_work(struct thr_info *thr, struct work *work);
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU)  || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+extern bool submit_tested_work_no_clone(struct thr_info *thr, struct work *work, bool diff1);
+#endif
 extern bool submit_nonce(struct thr_info *thr, struct work *work, uint32_t nonce);
 extern bool submit_noffset_nonce(struct thr_info *thr, struct work *work, uint32_t nonce,
 			  int noffset);
--- cg_o/usbutils.c	2014-04-06 10:43:59.023487169 +0300
+++ cgminer/usbutils.c	2014-04-10 10:39:48.693334953 +0300
@@ -262,6 +262,60 @@
 };
 #endif
 
+#ifdef USE_HEXMINERA
+static struct usb_epinfo hexa_epinfos[] = {
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPI(2), 0, 0 },
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPO(2), 0, 0 }
+};
+static struct usb_intinfo hexa_ints[] = {
+	USB_EPS(1, hexa_epinfos)
+};
+#endif
+#ifdef USE_HEXMINERB
+static struct usb_epinfo hexb_epinfos[] = {
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPI(2), 0, 0 },
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPO(2), 0, 0 }
+};
+static struct usb_intinfo hexb_ints[] = {
+	USB_EPS(1, hexb_epinfos)
+};
+#endif
+#ifdef USE_HEXMINER8
+static struct usb_epinfo hex8_epinfos[] = {
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPI(2), 0, 0 },
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPO(2), 0, 0 }
+};
+static struct usb_intinfo hex8_ints[] = {
+	USB_EPS(1, hex8_epinfos)
+};
+#endif
+#ifdef USE_HEXMINER3
+static struct usb_epinfo hex3_epinfos[] = {
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPI(2), 0, 0 },
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPO(2), 0, 0 }
+};
+static struct usb_intinfo hex3_ints[] = {
+	USB_EPS(1, hex3_epinfos)
+};
+#endif
+#ifdef USE_HEXMINERC
+static struct usb_epinfo hexc_epinfos[] = {
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPI(2), 0, 0 },
+	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPO(2), 0, 0 }
+};
+static struct usb_intinfo hexc_ints[] = {
+	USB_EPS(1, hexc_epinfos)
+};
+#endif
+#ifdef USE_HEXMINERU
+static struct usb_epinfo hexu_epinfos[] = {
+	{ LIBUSB_TRANSFER_TYPE_INTERRUPT,	64,	EPI(1), 0, 0 },
+	{ LIBUSB_TRANSFER_TYPE_INTERRUPT,	64,	EPO(1), 0, 0 }
+};
+static struct usb_intinfo hexu_ints[] = {
+	USB_EPS(0, hexu_epinfos)
+};
+#endif
 #ifdef USE_ICARUS
 static struct usb_epinfo ica_epinfos[] = {
 	{ LIBUSB_TRANSFER_TYPE_BULK,	64,	EPI(3), 0, 0 },
@@ -463,6 +517,7 @@
 		.latency = LATENCY_UNUSED,
 		INTINFO(mmq_ints) },
 #endif
+
 #ifdef USE_AVALON
 	{
 		.drv = DRIVER_avalon,
@@ -535,6 +590,95 @@
 		.latency = 10,
 		INTINFO(kli_ints) },
 #endif
+#ifdef USE_HEXMINERB //04d8:000a or //04d8:000b
+	{
+		.drv = DRIVER_hexminerb,
+		.name = "HEXb",
+		.ident = IDENT_HEXB,
+		.idVendor = 0x04D8,
+		.idProduct = 0x000B,
+		.iProduct = "HEX16B-Bitfury ASIC Miner",
+		.config = 1,
+		.timeout = 100,
+		.latency = LATENCY_UNUSED,
+		 INTINFO(hexb_ints) },
+	{	 
+		.drv = DRIVER_hexminerb,
+		.name = "HEXb",
+		.ident = IDENT_HEXB,
+		.idVendor = 0x04D8,
+		.idProduct = 0x000A,
+		.iProduct = "HEX16B-Bitfury ASIC Miner",
+		.config = 1,
+		.timeout = 100,
+		.latency = LATENCY_UNUSED,
+		 INTINFO(hexb_ints) },
+#endif
+#ifdef USE_HEXMINER8 //04d8:000a 
+	{	 
+		.drv = DRIVER_hexminer8,
+		.name = "HEX8",
+		.ident = IDENT_HEX8,
+		.idVendor = 0x04D8,
+		.idProduct = 0x000A,
+		.iProduct = "HEX8A1-CoinCraft ASIC Miner",
+		.config = 1,
+		.timeout = 100,
+		.latency = LATENCY_UNUSED,
+		 INTINFO(hex8_ints) },
+#endif
+
+#ifdef USE_HEXMINER3 //04d8:000a 
+	{	 
+		.drv = DRIVER_hexminer3,
+		.name = "HEX3",
+		.ident = IDENT_HEX3,
+		.idVendor = 0x04D8,
+		.idProduct = 0x000A,
+		.iProduct = "HEX3A3-Avalon3 ASIC Miner",
+		.config = 1,
+		.timeout = 100,
+		.latency = LATENCY_UNUSED,
+		 INTINFO(hex3_ints) },
+#endif
+#ifdef USE_HEXMINERC //04d8:000a
+	{
+		.drv = DRIVER_hexminerc,
+		.name = "HEXc",
+		.ident = IDENT_HEXC,
+		.idVendor = 0x04D8,
+		.idProduct = 0x000A,
+		.iProduct = "HEX16C-Avalon2 ASIC Miner",
+		.config = 1,
+		.timeout = 100,
+		.latency = LATENCY_UNUSED,
+		 INTINFO(hexc_ints) },
+#endif
+#ifdef USE_HEXMINERU //04d8:000a
+	{
+		.drv = DRIVER_hexmineru,
+		.name = "HEXu",
+		.ident = IDENT_HEXU,
+		.idVendor = 0x04D8,
+		.idProduct = 0x00DE,
+		.config = 1,
+		.timeout = 100,
+		.latency = LATENCY_UNUSED,
+		 INTINFO(hexu_ints) },
+#endif
+#ifdef USE_HEXMINERA //04d8:000a
+	{
+		.drv = DRIVER_hexminera,
+		.name = "HEXa",
+		.ident = IDENT_HEXA,
+		.idVendor = 0x04D8,
+		.idProduct = 0x000A,
+		.iProduct = "HEX16A-Avalon1 ASIC Miner",
+		.config = 1,
+		.timeout = 100,
+		.latency = LATENCY_UNUSED,
+		 INTINFO(hexa_ints) },
+#endif 
 #ifdef USE_ICARUS
 	{
 		.drv = DRIVER_icarus,
@@ -939,7 +1083,6 @@
 {
 	char tmp[512];
 	int err;
-
 	err = libusb_set_configuration(handle, cd);
 	if (err) {
 		snprintf(tmp, sizeof(tmp), EOL "  ** dev %d: Failed to set config descriptor to %d, err %d",
@@ -1024,6 +1167,7 @@
 	append(buf, tmp, off, len);
 
 	err = libusb_open(dev, &handle);
+	
 	if (err) {
 		snprintf(tmp, sizeof(tmp), EOL "  ** dev %d: Failed to open, err %d", (int)(*count), err);
 		append(buf, tmp, off, len);
@@ -1659,7 +1803,7 @@
 						 THISIF(cgpu->usbdev->found, ifinfo));
 		}
 #ifdef LINUX
-		libusb_attach_kernel_driver(cgpu->usbdev->handle, THISIF(cgpu->usbdev->found, ifinfo));
+		//libusb_attach_kernel_driver(cgpu->usbdev->handle, THISIF(cgpu->usbdev->found, ifinfo));
 #endif
 		cg_wlock(&cgusb_fd_lock);
 		libusb_close(cgpu->usbdev->handle);
@@ -1806,7 +1950,6 @@
 
 	if (unlikely(!cgpu))
 		quit(1, "Failed to calloc cgpu for %s in usb_alloc_cgpu", drv->dname);
-
 	cgpu->drv = drv;
 	cgpu->deven = DEV_ENABLED;
 	cgpu->threads = threads;
@@ -1963,16 +2106,52 @@
 
 	if (found->iProduct) {
 		unsigned char prod[STRBUFLEN+1];
-
+    
 		err = libusb_get_string_descriptor_ascii(cgusb->handle,
 							 cgusb->descriptor->iProduct,
 							 prod, STRBUFLEN);
 		if (err < 0) {
+		
+			#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+				bzero(prod,STRBUFLEN);
+			#if defined(USE_HEXMINERA)
+			if(found->ident == IDENT_HEXA && default_hex_miner == D_HEXA) {
+				strcpy(prod, "HEX16A-Avalon1 ASIC Miner");
+			} 
+			#endif
+			
+			#if defined(USE_HEXMINERB)
+			if(found->ident == IDENT_HEXB && default_hex_miner == D_HEXB) {
+				strcpy(prod, "HEX16B-Bitfury ASIC Miner");
+			} 
+			#endif
+			
+		  #if defined(USE_HEXMINERC)
+			if(found->ident == IDENT_HEXC && default_hex_miner == D_HEXC) {
+				strcpy(prod, "HEX16C-Avalon2 ASIC Miner");
+			} 
+			#endif
+			
+      #if defined(USE_HEXMINER8)
+			if(found->ident == IDENT_HEX8 && default_hex_miner == D_HEX8) {
+				strcpy(prod, "HEX8A1-CoinCraft ASIC Miner");
+			} 
+			#endif
+			#if defined(USE_HEXMINER3)
+			if(found->ident == IDENT_HEX3 && default_hex_miner == D_HEX3) {
+				strcpy(prod, "HEX3A3-Avalon3 ASIC Miner");
+			} 
+			#endif
+			#else
+			
 			applog(LOG_DEBUG,
 				"USB init, failed to get iProduct, err %d %s",
 				err, devstr);
 			goto cldame;
+			#endif
+			
 		}
+		
 		if (strcmp((char *)prod, found->iProduct)) {
 			applog(LOG_DEBUG, "USB init, iProduct mismatch %s",
 			       devstr);
@@ -2103,11 +2282,34 @@
 
 	err = libusb_get_string_descriptor_ascii(cgusb->handle,
 				cgusb->descriptor->iProduct, strbuf, STRBUFLEN);
+	#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+	  	if (err > 0)
+		cgusb->prod_string = strdup((char *)strbuf);
+	else {
+		#if defined(USE_HEXMINERA)
+		if(default_hex_miner == D_HEXA) cgusb->prod_string = strdup((char *)"HEX16A-Avalon1 ASIC Miner");
+		#endif
+		#if defined(USE_HEXMINERB)
+		if(default_hex_miner == D_HEXB) cgusb->prod_string = strdup((char *)"HEX16B-Bitfury ASIC Miner");
+		#endif
+		#if defined(USE_HEXMINERC)
+		if(default_hex_miner == D_HEXC) cgusb->prod_string = strdup((char *)"HEX16C-Avalon2 ASIC Miner");
+		#endif
+		#if defined(USE_HEXMINER8)
+		if(default_hex_miner == D_HEX8) cgusb->prod_string = strdup((char *)"HEX8A1-CoinCraft ASIC Miner");
+		#endif
+		#if defined(USE_HEXMINER3)
+		if(default_hex_miner == D_HEX3) cgusb->prod_string = strdup((char *)"HEX3A3-Avalon3 ASIC Miner");
+		#endif
+
+		
+	}
+	#else
 	if (err > 0)
 		cgusb->prod_string = strdup((char *)strbuf);
 	else
 		cgusb->prod_string = (char *)BLANK;
-
+  #endif
 	err = libusb_get_string_descriptor_ascii(cgusb->handle,
 				cgusb->descriptor->iManufacturer, strbuf, STRBUFLEN);
 	if (err > 0)
@@ -2155,7 +2357,7 @@
 
 cldame:
 #ifdef LINUX
-	libusb_attach_kernel_driver(cgusb->handle, THISIF(found, ifinfo));
+	//libusb_attach_kernel_driver(cgusb->handle, THISIF(found, ifinfo));
 
 nokernel:
 #endif
@@ -2336,7 +2538,7 @@
 				drv->dname, drv_count[drv->drv_id].limit);
 			break;
 		}
-
+    
 		found = usb_check(drv, list[i]);
 		if (found != NULL) {
 			bool new_dev = false;
@@ -3463,6 +3665,12 @@
 	for (i = 0; i < total_devices; i++) {
 		cgpu = devices[i];
 		switch (cgpu->drv->drv_id) {
+			case DRIVER_hexminera:
+			case DRIVER_hexminerb:
+			case DRIVER_hexminerc:
+			case DRIVER_hexmineru:
+			case DRIVER_hexminer8:
+			case DRIVER_hexminer3:
 			case DRIVER_bflsc:
 			case DRIVER_bitforce:
 			case DRIVER_bitfury:
--- cg_o/usbutils.h	2014-04-06 10:43:59.023487169 +0300
+++ cgminer/usbutils.h	2014-04-10 10:37:32.217862132 +0300
@@ -137,6 +137,12 @@
 	IDENT_AMU,
 	IDENT_ANT,
 	IDENT_ANU,
+	IDENT_HEXA,
+	IDENT_HEXB,
+	IDENT_HEXC,
+	IDENT_HEXU,
+	IDENT_HEX8,
+	IDENT_HEX3,
 	IDENT_AVA,
 	IDENT_BAJ,
 	IDENT_BAL,
@@ -562,5 +568,5 @@
 
 #define usb_transfer_read(cgpu, typ, req, val, idx, buf, bufsiz, read, cmd) \
 	_usb_transfer_read(cgpu, typ, req, val, idx, buf, bufsiz, read, DEVTIMEOUT, cmd)
-
+	
 #endif
--- cg_o/api.c	2014-04-06 10:43:58.939482578 +0300
+++ cgminer/api.c	2014-04-10 10:37:32.217862132 +0300
@@ -25,8 +25,8 @@
 #include "miner.h"
 #include "util.h"
 #include "klist.h"
-
-#if defined(USE_BFLSC) || defined(USE_AVALON) || defined(USE_AVALON2) || \
+#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || \
+	defined(USE_HEXMINER8) || defined(USE_HEXMINER3) || defined(USE_BFLSC) || defined(USE_AVALON) || defined(USE_AVALON2) || \
 	defined(USE_HASHFAST) || defined(USE_BITFURY) || defined(USE_KLONDIKE) || \
 	defined(USE_KNC) || defined(USE_BAB) || defined(USE_DRILLBIT) || \
 	defined(USE_MINION) || defined(USE_COINTERRA) || defined(USE_BITMINE_A1) || \
@@ -39,7 +39,7 @@
 #endif
 
 // BUFSIZ varies on Windows and Linux
-#define TMPBUFSIZ	8192
+#define TMPBUFSIZ	8192 * 8
 
 // Number of requests to queue - normally would be small
 // However lots of PGA's may mean more
@@ -181,6 +181,24 @@
 #ifdef USE_BITMINE_A1
 			"BA1 "
 #endif
+#ifdef USE_HEXMINERA
+			"HEXa "
+#endif
+#ifdef USE_HEXMINERB
+			"HEXb "
+#endif
+#ifdef USE_HEXMINERC
+			"HEXc "
+#endif
+#ifdef USE_HEXMINERU
+			"HEXu "
+#endif
+#ifdef USE_HEXMINER8
+			"HEX8 "
+#endif
+#ifdef USE_HEXMINER3
+			"HEX3 "
+#endif
 #ifdef USE_ICARUS
 			"ICA "
 #endif
@@ -1492,12 +1510,14 @@
 
 #if LOCK_TRACKING
 
+FILE * pFile;
+
 #define LOCK_FMT_FFL " - called from %s %s():%d"
 
-#define LOCKMSG(fmt, ...)	fprintf(stderr, "APILOCK: " fmt "\n", ##__VA_ARGS__)
-#define LOCKMSGMORE(fmt, ...)	fprintf(stderr, "          " fmt "\n", ##__VA_ARGS__)
-#define LOCKMSGFFL(fmt, ...) fprintf(stderr, "APILOCK: " fmt LOCK_FMT_FFL "\n", ##__VA_ARGS__, file, func, linenum)
-#define LOCKMSGFLUSH() fflush(stderr)
+#define LOCKMSG(fmt, ...)	fprintf(pFile, "APILOCK: " fmt "\n", ##__VA_ARGS__)
+#define LOCKMSGMORE(fmt, ...)	fprintf(pFile, "          " fmt "\n", ##__VA_ARGS__)
+#define LOCKMSGFFL(fmt, ...) fprintf(pFile, "APILOCK: " fmt LOCK_FMT_FFL "\n", ##__VA_ARGS__, file, func, linenum)
+#define LOCKMSGFLUSH() fflush(pFile)
 
 typedef struct lockstat {
 	uint64_t lock_id;
@@ -1855,6 +1875,7 @@
 
 void show_locks()
 {
+	pFile = fopen ("/tmp/cglocks","w");
 	LOCKLIST *list;
 
 	locklock();
@@ -1874,6 +1895,8 @@
 	LOCKMSGFLUSH();
 
 	lockunlock();
+	fclose (pFile);
+
 }
 #endif
 
@@ -3162,14 +3185,38 @@
 {
 	struct api_data *root = NULL;
 
+  #if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+	char *enabled;
+	char *status;
+  char *is_hex = NULL;
+  
+  is_hex = strstr(id, "HEX");
+  #endif
 	root = api_add_int(root, "STATS", &i, false);
 	root = api_add_string(root, "ID", id, false);
+	#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+	if(is_hex && cgpu) {
+		if (cgpu->deven != DEV_DISABLED)
+				enabled = (char *)YES;
+			else
+				enabled = (char *)NO;
+		
+		  status = (char *)status2str(cgpu->status);
+			root = api_add_string(root, "Enabled", enabled, false);
+			root = api_add_string(root, "Status", status, false);
+	}
+	#endif
 	root = api_add_elapsed(root, "Elapsed", &(total_secs), false);
+	#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+	if(is_hex == NULL) {
+	#endif
 	root = api_add_uint32(root, "Calls", &(stats->getwork_calls), false);
 	root = api_add_timeval(root, "Wait", &(stats->getwork_wait), false);
 	root = api_add_timeval(root, "Max", &(stats->getwork_wait_max), false);
 	root = api_add_timeval(root, "Min", &(stats->getwork_wait_min), false);
-
+  #if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+	} 
+	#endif
 	if (pool_stats) {
 		root = api_add_uint32(root, "Pool Calls", &(pool_stats->getwork_calls), false);
 		root = api_add_uint32(root, "Pool Attempts", &(pool_stats->getwork_attempts), false);
@@ -3199,6 +3246,10 @@
 
 	if (cgpu) {
 #ifdef USE_USBUTILS
+	#if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+	if(is_hex == NULL) {
+	#endif
+	
 		char details[256];
 
 		if (cgpu->usbinfo.pipe_count)
@@ -3252,6 +3303,10 @@
 		}
 
 		root = api_add_string(root, "USB tmo", details, true);
+ #if defined(USE_HEXMINERA) || defined(USE_HEXMINERB) || defined(USE_HEXMINERC) || defined(USE_HEXMINERU) || defined(USE_HEXMINER8) || defined(USE_HEXMINER3)
+	}
+ #endif
+	
 #endif
 	}
 
@@ -4899,7 +4954,11 @@
 										break;
 									}
 								}
+	#if LOCK_TRACKING
+	if (ISPRIVGROUP(group) || strstr(COMMANDS(group), cmdbuf) || 1)
+	#else
 								if (ISPRIVGROUP(group) || strstr(COMMANDS(group), cmdbuf))
+	#endif
 									(cmds[i].func)(io_data, c, param, isjson, group);
 								else {
 									message(io_data, MSG_ACCDENY, 0, cmds[i].name, isjson);
--- cg_o/driver-hexminera.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer/driver-hexminera.c	2014-04-11 11:33:18.849851190 +0300
@@ -0,0 +1,480 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:19:47 */
+/*
+ * Copyright 2013 Con Kolivas <kernel@kolivas.org> Copyright 2012-2013 Xiangfu
+ * <xiangfu@openmobilefree.com> Copyright 2012 Luke Dashjr Copyright 2012 Andrew
+ * Smith This program is free software;
+ * you can redistribute it and/or modify it under the terms of the GNU General
+ * Public License as published by the Free Software Foundation;
+ * either version 3 of the License, or (at your option) any later version. See
+ * COPYING for more details. Thank you guys!
+ */
+#include "config.h"
+#include <limits.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <ctype.h>
+#include <dirent.h>
+#include <unistd.h>
+#ifndef WIN32
+#include <sys/select.h>
+#include <termios.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#ifndef O_CLOEXEC
+#define O_CLOEXEC	0
+#endif
+#else
+#include "compat.h"
+#include <windows.h>
+#include <io.h>
+#endif
+#include "elist.h"
+#include "miner.h"
+#include "usbutils.h"
+#include "driver-hexminera.h"
+#include "util.h"
+static int option_offset = -1;
+extern unsigned int work_block;
+extern struct work *copy_work_noffset_fast_no_id (struct work *base_work,
+                                                  int noffset);
+struct device_drv hexminera_drv;
+int opt_hexminera_core_voltage = HEXA_DEFAULT_CORE_VOLTAGE;
+#include "libhexa.c"
+
+static int
+hexminera_send_task (struct hexminera_task *ht, struct cgpu_info *hexminera)
+{
+  int ret = 0;
+  size_t nr_len = HEXMINERA_TASK_SIZE;
+  struct hexminera_info *info;
+  info = hexminera->device_data;
+  libhexa_csum (&ht->startbyte, &ht->csum, &ht->csum);
+  ret = libhexa_sendHashData (hexminera, &ht->startbyte, nr_len);
+  if (ret != nr_len)
+    {
+      libhexa_reset (hexminera);
+      info->usb_w_errors++;
+      return -1;
+    } else {
+    	info->last_wr = libhexa_et();
+    }
+  return ret;
+}
+
+static inline void
+hexminera_create_task (bool reset_work, struct hexminera_task *ht,
+                       struct work *work)
+{
+  if (reset_work)
+    {
+      ht->status = HEXA_STAT_NEW_WORK_CLEAR_OLD;
+    }
+  else
+    {
+      ht->status = HEXA_STAT_NEW_WORK;
+    }
+  memcpy (ht->midstate, work->midstate, 32);
+  memcpy (ht->merkle, work->data + 64, 12);
+  ht->id = (uint8_t) work->subid;
+  libhexa_calc_hexminer (work, ht);
+}
+
+static inline void
+hexminera_init_task (struct hexminera_task *ht, struct hexminera_info *info)
+{
+  //bzero (ht, sizeof (struct hexminera_task));
+  ht->startbyte = 0x53;
+  ht->datalength = (uint8_t) ((HEXMINERA_TASK_SIZE - 6) / 2);
+  ht->command = 0x57;
+  ht->address = htole16 (HEXA_WORKQUEUE_ADR);
+  libhexa_generateclk (info->frequency, HEXA_DEFAULT_XCLKIN_CLOCK,
+                       (uint32_t *) & ht->clockcfg[0]);
+  libhexa_setvoltage (info->core_voltage, &ht->refvoltage);
+  ht->chipcount = htole16 (info->asic_count);
+  ht->hashclock = htole16 ((uint16_t) info->frequency);
+  ht->startnonce = 0x00000000;
+}
+
+static void do_write(struct thr_info *thr)
+{
+
+  struct cgpu_info *hexminera = thr->cgpu;
+  struct hexminera_info *info = hexminera->device_data;
+  int ret;
+	
+	      again:
+          if (!info->work)
+            {
+              info->roll = 0;
+              info->work = get_work (thr, thr->id);
+              info->work->ping = 1;
+  						if(work_block != info->work_block) {
+  							info->reset_work = true;
+  							info->work_block = work_block;
+  						}
+  							
+            }
+          if (stale_work (info->work, false))
+            {
+              free_work (info->work);
+              info->work = NULL;
+              goto again;
+            }
+
+          if (info->write_pos >= HEXMINERA_ARRAY_SIZE_REAL || info->reset_work)
+            info->write_pos = 0;
+
+          info->work->subid = info->write_pos;
+          free_work (info->hexworks[info->write_pos]);
+          info->hexworks[info->write_pos] = copy_work_noffset_fast_no_id (info->work, info->roll++);
+          hexminera_create_task (info->reset_work, info->ht, info->hexworks[info->write_pos]);
+
+          if (info->work->drv_rolllimit)
+            {
+              info->work->drv_rolllimit--;
+            }
+          else
+            {
+              free_work (info->work);
+              info->work = NULL;
+            }
+          
+          ret = hexminera_send_task (info->ht, hexminera);
+          info->write_pos++;
+          
+          if (ret == HEXMINERA_TASK_SIZE && info->reset_work)
+            {
+              info->reset_work = false;
+            }
+}
+
+static struct cgpu_info *
+hexminera_detect_one (libusb_device * dev, struct usb_find_devices *found)
+{
+  int miner_count, asic_count, frequency;
+  int this_option_offset = ++option_offset;
+  struct hexminera_info *info;
+  struct cgpu_info *hexminera;
+  bool configured;
+  int i = 0;
+  hexminera = usb_alloc_cgpu (&hexminera_drv, HEXA_MINER_THREADS);
+  if (!usb_init (hexminera, dev, found))
+    {
+      usb_uninit (hexminera);
+      return NULL;
+    }
+  hexminera->device_data = calloc (sizeof (struct hexminera_info), 1);
+  if (unlikely (!(hexminera->device_data)))
+    {
+      hexminera->device_data = NULL;
+      usb_uninit (hexminera);
+      return NULL;
+    }
+  configured =
+    libhexa_get_options (this_option_offset, &asic_count, &frequency);
+  if (opt_hexminera_core_voltage < HEXA_MIN_COREMV
+      || opt_hexminera_core_voltage > HEXA_MAX_COREMV)
+    {
+      applog
+        (LOG_ERR,
+         "Invalid hexminera-voltage %d must be %dmV - %dmV",
+         opt_hexminera_core_voltage, HEXA_MIN_COREMV, HEXA_MAX_COREMV);
+      free (hexminera->device_data);
+      hexminera->device_data = NULL;
+      usb_uninit (hexminera);
+      return NULL;
+    }
+  info = hexminera->device_data;
+  info->hexworks = calloc (sizeof (struct work *), HEXMINERA_ARRAY_SIZE);
+  if (unlikely (!(info->hexworks)))
+    {
+      free (hexminera->device_data);
+      hexminera->device_data = NULL;
+      usb_uninit (hexminera);
+      return NULL;
+    }
+  //NEW
+
+  info->wr = (struct worka_result *) malloc (sizeof (struct worka_result));
+  info->array_nonce_cache = calloc (16, sizeof (struct chip_resultsa));
+
+  info->readbuf = calloc (HEXA_HASH_BUF_SIZE, sizeof (unsigned char));
+
+  info->write_pos = 0;
+  info->hash_read_pos = 0;
+  info->hash_write_pos = 0;
+  info->shut_read = false;
+  info->shut_write = false;
+  info->shut_reset = false;
+  info->work = NULL;
+  info->reset_work = true;
+  info->last_wr = libhexa_et ();
+  info->miner_count = HEXA_DEFAULT_MINER_NUM;
+  info->asic_count = HEXA_DEFAULT_ASIC_NUM;
+  info->frequency = HEXA_DEFAULT_FREQUENCY;
+  info->pic_voltage_readings = HEXA_DEFAULT_CORE_VOLTAGE;
+  info->core_voltage = opt_hexminera_core_voltage;
+  if (configured)
+    {
+      info->asic_count = asic_count;
+      info->frequency = frequency;
+    }
+  //info->ht = (struct hexminera_task *) malloc (sizeof (struct hexminera_task));
+  info->ht = calloc (sizeof (struct hexminera_task), 1);
+  hexminera_init_task (info->ht, info);
+  info->usb_timing =
+    (unsigned long long) (0x80000000ll / 1000 / info->asic_count / info->frequency * 0.93 * 2);
+  if (!add_cgpu (hexminera))
+    {
+      free (info->hexworks);
+      free (hexminera->device_data);
+      hexminera->device_data = NULL;
+      hexminera = usb_free_cgpu (hexminera);
+      usb_uninit (hexminera);
+      return NULL;
+    }
+  while (i < HEXMINERA_ARRAY_SIZE)
+    {
+      info->hexworks[i] = calloc (1, sizeof (struct work));
+      info->hexworks[i]->pool = NULL;
+      i++;
+    }
+  libhexa_generatenrange_new ((unsigned char *) &info->nonces_range,
+                              info->asic_count);
+                            
+  return hexminera;
+}
+
+static void
+hexminera_detect (bool __maybe_unused hotplug)
+{
+  usb_detect (&hexminera_drv, hexminera_detect_one);
+}
+
+static void
+do_hexminera_close (struct thr_info *thr)
+{
+  struct cgpu_info *hexminera = thr->cgpu;
+  struct hexminera_info *info = hexminera->device_data;
+  int i = 0;
+  
+  while (i < HEXMINERA_ARRAY_SIZE)
+    {
+      free_work (info->hexworks[i]);
+      i++;
+    }
+  free (info->hexworks);
+  free (info->readbuf);
+  free (info->array_nonce_cache);
+  free (info->wr);
+  if(info->work)
+	 	free (info->work);
+  
+  free (info->ht);
+  //usb_uninit(hexminera);
+  //Hotplug fucks up on full mem free :)
+  //free (hexminera->device_data);
+  //hexminera->device_data = NULL;
+  //thr->cgpu = usb_free_cgpu(hexminera);
+}
+
+static void
+hexminera_shutdown (struct thr_info *thr)
+{
+  struct cgpu_info *hexminera = thr->cgpu;
+  struct hexminera_info *info = hexminera->device_data;
+ 
+ 	
+ 	do_hexminera_close (thr);
+ 
+  usb_nodev(hexminera);
+   
+  // if(hexminera->device_data)
+   	//	free (hexminera->device_data);
+   
+   //hexminera->device_data = NULL;
+}
+
+static int64_t
+hexminera_scanhash (struct thr_info *thr)
+{
+  struct cgpu_info *hexminera = thr->cgpu;
+  struct hexminera_info *info = hexminera->device_data;
+  int notdupe, found, i, lastchippos;
+  uint32_t nonce;
+  int ret_r = 0;
+  int64_t hash_count = 0;
+
+  if (libhexa_usb_dead (hexminera))	
+    return -1;
+  if ( (libhexa_et() - info->last_wr > info->usb_timing) || (work_block != info->work_block)) {
+  	do_write(thr);
+  	if (libhexa_usb_dead (hexminera))	
+    return -1;
+	}
+  
+  if ((info->hash_write_pos + HEXA_USB_R_SIZE + MAX_REPL_PACKET) >=
+      HEXA_HASH_BUF_SIZE)
+    {
+      info->hash_write_pos = info->hash_write_pos - info->hash_read_pos;
+      memcpy (info->readbuf, info->readbuf + info->hash_read_pos,
+              info->hash_write_pos);
+      info->hash_read_pos = 0;
+    }
+  if (info->hash_write_pos - info->hash_read_pos >= HEXA_BASE_WORK_SIZE + 2)
+    {
+    again:
+      ret_r =
+        libhexa_eatHashData (info->wr, info->readbuf, &info->hash_read_pos,
+                             &info->hash_write_pos);
+      if (ret_r > HEXA_BUF_DATA)
+        goto out;
+     
+      if (info->wr->datalength == 1)
+        goto done;
+      if (info->wr->lastnonceid > HEXMINERA_ARRAY_SIZE_REAL)
+        info->wr->lastnonceid = 0;
+      nonce = htole32 (info->wr->lastnonce);
+      i = 0;
+      while (i < info->asic_count)
+        {
+          if (nonce < info->nonces_range[++i])
+            {
+              lastchippos = --i;
+              break;
+            }
+        }
+      if (i == info->asic_count)
+        lastchippos = info->asic_count - 1;
+      notdupe =
+        libhexa_cachenonce (&info->array_nonce_cache[lastchippos], nonce);
+      if (lastchippos > 0)
+        notdupe &= libhexa_cachenonce (&info->array_nonce_cache[0], nonce);
+
+      if (notdupe)
+        {
+          found = hexminera_predecode_nonce (hexminera, thr, nonce,
+                                             info->wr->lastnonceid);
+          if (found > 0)
+            {
+              if (hash_count == 0)
+                libhexa_getvoltage (htole16 (info->wr->lastvoltage),
+                                    &info->pic_voltage_readings);
+              hash_count += found;
+              info->matching_work[lastchippos]++;
+            }
+          else
+            {
+              inc_hw_errors (thr);
+            }
+        }
+      else
+        {
+          info->dupe[lastchippos]++;
+        }
+    out:
+      if (ret_r == HEXA_BUF_ERR)
+        {
+          info->usb_r_errors++;
+        }
+    done:
+      if (info->hash_write_pos - info->hash_read_pos > HEXA_MAX_WORK_SIZE)
+        goto again;
+    }
+  ret_r =
+    libhexa_readHashData (hexminera, info->readbuf, &info->hash_write_pos,
+                          HEXMINERA_BULK_READ_TIMEOUT, true);
+
+  hash_count = (int64_t) (0xffffffffull * hash_count);
+
+  if (libhexa_usb_dead (hexminera))
+    return -1;
+    
+  cgsleep_us (100);
+  return hash_count;
+}
+
+static void
+get_hexminera_statline_before (char *buf, size_t bufsiz,
+                               struct cgpu_info *hexminera)
+{
+ if (!hexminera->device_data)
+		return;
+ 
+  struct hexminera_info *info = hexminera->device_data;
+  tailsprintf (buf, bufsiz, "%3d %4d/%4dmV", info->frequency,
+               info->core_voltage, info->pic_voltage_readings);
+}
+
+static struct api_data *
+hexminera_api_stats (struct cgpu_info *cgpu)
+{
+  struct api_data *root = NULL;
+  struct hexminera_info *info = cgpu->device_data;
+  if (!info)
+		return NULL;
+		
+  uint64_t dh64, dr64;
+  double dev_runtime;
+  struct timeval now;
+  int i;
+  char displayed_hashes[16], displayed_rolling[16];
+  double hwp =
+    (cgpu->hw_errors +
+     cgpu->diff1) ? (double) (cgpu->hw_errors) / (double) (cgpu->hw_errors +
+                                                           cgpu->diff1) : 0;
+  if (cgpu->dev_start_tv.tv_sec == 0)
+    dev_runtime = total_secs;
+  else
+    {
+      cgtime (&now);
+      dev_runtime = tdiff (&now, &(cgpu->dev_start_tv));
+    }
+  if (dev_runtime < 1.0)
+    dev_runtime = 1.0;
+  dh64 = (double) cgpu->total_mhashes / dev_runtime * 1000000ull;
+  dr64 = (double) cgpu->rolling * 1000000ull;
+  suffix_string (dh64, displayed_hashes, sizeof (displayed_hashes), 4);
+  suffix_string (dr64, displayed_rolling, sizeof (displayed_rolling), 4);
+  root = api_add_string (root, "MHS 5s", displayed_rolling, true);
+  root = api_add_string (root, "MHS av", displayed_hashes, true);
+  root = api_add_int (root, "Hardware Errors", &(cgpu->hw_errors), true);
+  root = api_add_percent (root, "Hardware Errors%", &hwp, true);
+  root = api_add_int (root, "USB Read Errors", &(info->usb_r_errors), true);
+  root = api_add_int (root, "USB Write Errors", &(info->usb_w_errors), true);
+  root =
+    api_add_int (root, "USB Reset Count", &(info->usb_reset_count), true);
+     
+  root =
+    api_add_time (root, "Last Share Time", &(cgpu->last_share_pool_time),
+                  true);
+  root = api_add_int (root, "Chip Count", &(info->asic_count), true);
+  root = api_add_int (root, "Frequency", &(info->frequency), true);
+  root = api_add_int (root, "Core Voltage", &(info->core_voltage), true);
+  root =
+    api_add_int (root, "PIC Voltage Readings", &(info->pic_voltage_readings),
+                 true);
+  for (i = 0; i < info->asic_count; i++)
+    {
+      char mcw[24];
+      sprintf (mcw, "Chip%d Nonces", i + 1);
+      root = api_add_int (root, mcw, &(info->matching_work[i]), true);
+      sprintf (mcw, "Chip%d Dupes", i + 1);
+      root = api_add_int (root, mcw, &(info->dupe[i]), true);
+    }
+  return root;
+}
+
+struct device_drv hexminera_drv = {
+  .drv_id = DRIVER_hexminera,
+  .dname = "hexminera",
+  .name = "HEXa",
+  .drv_detect = hexminera_detect,
+  .hash_work = hash_queued_work,
+  .scanwork = hexminera_scanhash,
+  .get_api_stats = hexminera_api_stats,
+  .get_statline_before = get_hexminera_statline_before,
+  .thread_shutdown = hexminera_shutdown,
+};
--- cg_o/driver-hexminera.h	1970-01-01 02:00:00.000000000 +0200
+++ cgminer/driver-hexminera.h	2014-04-11 11:33:18.853851446 +0300
@@ -0,0 +1,157 @@
+/*$T indentinput.h GC 1.140 10/16/13 10:20:01 */
+
+/*
+ * Copyright 2013 Avalon project Copyright 2013 Con Kolivas <kernel@kolivas.org>
+ * This program is free software;
+ * you can redistribute it and/or modify it under the terms of the GNU General
+ * Public License as published by the Free Software Foundation;
+ * either version 3 of the License, or (at your option) any later version. See
+ * COPYING for more details. Thank you guys!
+ */
+#ifndef HEXA_H
+#define HEXA_H
+
+#ifdef USE_HEXMINERA
+#include "util.h"
+//#define DBG_HEXA
+#define DBG_TIME 10
+/* hexminera_task/work_reply status Definitions: */
+
+#define HEXA_STAT_NEW_WORK				1       /* Request for write in the buffer */
+#define HEXA_STAT_NEW_WORK_CLEAR_OLD		5       /* Clear Buffers and after that fill the first buffer */
+
+
+/* libhexc_eatHashData/BUF_reply status Definitions: */
+#define HEXA_BUF_DATA 0
+#define HEXA_BUF_ERR  1
+#define HEXA_BUF_SKIP 2
+
+#define HEXA_DEFAULT_XCLKIN_CLOCK		32      /* In MHz */
+#define HEXA_CLOCK_LOW_CFG				0x00030017
+#define HEXA_CLOCK_HIGH_CFG				(0x0000002e << 3)       /* = 0x00000170 */
+#define HEXMINERA_ARRAY_PIC_SIZE		64
+#define HEXMINERA_ARRAY_SIZE			HEXMINERA_ARRAY_PIC_SIZE * 4
+#define HEXMINERA_ARRAY_SIZE_REAL	HEXMINERA_ARRAY_SIZE - 2
+#define HEXA_NONCE_CASH_SIZE			32
+
+#define HEXA_USB_R_SIZE					1
+#define MAX_REPL_PACKET					0x0f
+
+#define HEXA_USB_WR_SIZE					60
+#define HEXA_HASH_BUF_SIZE				1024
+#define HEXA_USB_WR_TIME_OUT				100
+
+#define HEXMINERA_BULK_READ_TIMEOUT		10
+#define HEXA_MAX_START_DELAY_MS			1000
+#define HEXA_MINER_THREADS			1
+#define HEXA_DEFAULT_MINER_NUM		0x01
+#define HEXA_DEFAULT_ASIC_NUM		0x10
+#define HEXA_MIN_FREQUENCY			100
+#define HEXA_MAX_FREQUENCY			11650
+#define HEXA_DEFAULT_FREQUENCY		282
+#define HEXA_DEFAULT_CORE_VOLTAGE	1200    /* in millivolts */
+#define HEXA_MIN_COREMV				1000    /* in millivolts */
+
+/* Do not touch it!!! 1.6V is above the chip specs already */
+#define HEXA_MAX_COREMV	1630    /* in millivolts */
+
+struct chip_resultsa
+{
+  uint8_t nonce_cache_write_pos;
+  uint32_t nonces[HEXA_NONCE_CASH_SIZE];
+};
+
+struct worka_result
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint32_t lastnonce;
+  uint8_t lastnonceid;
+  uint8_t status;
+  uint16_t lastvoltage;
+  uint16_t lasttemperature;
+  uint16_t lastfanrpm;
+  uint32_t serial;
+  uint16_t openloadduty;
+  uint16_t workingduty;
+  uint16_t lastworkingduty;
+  uint16_t clockforce;          /* Times Avalons Crashed */
+  uint8_t pad[3];
+} __attribute__ ((packed, aligned (4)));
+
+struct hexminera_info
+{
+	bool shut_read;
+  bool shut_write;
+  bool shut_reset;
+	bool reset_work;
+	int roll;
+  int miner_count;
+  int asic_count;
+  int core_voltage;
+  int frequency;
+  int hash_read_pos;
+  int hash_write_pos;
+  int usb_r_errors;
+  int usb_w_errors;
+  int usb_reset_count;
+  int pic_voltage_readings;
+  int write_pos;
+  int dupe[HEXA_DEFAULT_ASIC_NUM];
+  int matching_work[HEXA_DEFAULT_ASIC_NUM];
+  unsigned int work_block;
+  unsigned long long usb_timing;
+  unsigned long long last_wr;
+  unsigned char *readbuf;
+  uint32_t nonces_range[HEXA_DEFAULT_ASIC_NUM];
+  struct worka_result *wr;
+  struct work **hexworks;
+  struct work *work;
+  struct hexminera_task *ht;
+  struct chip_resultsa *array_nonce_cache;
+};
+
+struct hexminera_task
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint32_t clockcfg[2];
+  uint32_t merkle[3];
+  uint32_t a1;
+  uint32_t a0;
+  uint32_t e2;
+  uint32_t e1;
+  uint32_t e0;
+  uint8_t midstate[32];
+  uint32_t a2;
+  uint32_t startnonce;
+  uint8_t id;
+  uint8_t status;
+  uint16_t hashclock;
+  uint16_t chipcount;
+  uint16_t refvoltage;
+  uint16_t reftemperature;
+  uint16_t reffanrpm;
+  uint8_t csum;
+  uint8_t pad[2];
+} __attribute__ ((packed, aligned (4)));
+
+#define HEXA_WORKANSWER_ADR	0x3000
+#define HEXA_WORKQUEUE_ADR	0x4000
+#define HEXA_PTCON_ADR		0x0C00
+#define HEXA_START_STOP_ADR	0x646E
+#define HEXMINERA_TASK_SIZE	(sizeof(struct hexminera_task)-2)
+#define HEXA_MAX_WORK_SIZE		(sizeof(struct worka_result) - 3)
+#define HEXA_BASE_WORK_SIZE		6       /* Min uint8_t startbyte + uint8_t datalength + uint8_t command + uint16_t
+                                                 * address;
+                                                 * + uint8_t csum */
+#define HEXA_WORKANSWER_STAT_ADR HEXA_BASE_WORK_SIZE + 4
+extern int opt_hexminera_core_voltage;
+extern char *libhexa_set_config_voltage (char *arg);
+extern struct hexminera_info **hexminera_info;
+#endif /* USE_HEXMINERA */
+#endif /* HEXA_H */
--- cg_o/libhexa.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer/libhexa.c	2014-04-11 11:33:09.005309322 +0300
@@ -0,0 +1,481 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:20:34 */
+#define rotate(x, y)	((x << y) | (x >> (sizeof(x) * 8 - y)))
+#define rotr(x, y)		((x >> y) | (x << (sizeof(x) * 8 - y)))
+#define R(a, b, c, d, e, f, g, h, w, k) \
+		h = h + \
+		(rotate(e, 26) ^ rotate(e, 21) ^ rotate(e, 7)) + \
+		(g ^ (e & (f ^ g))) + \
+		k + \
+		w; \
+	d = d + h; \
+	h = h + (rotate(a, 30) ^ rotate(a, 19) ^ rotate(a, 10)) + ((a & b) | (c & (a | b)))
+const uint32_t SHA256_K[3] = { 0x428a2f98, 0x71374491, 0xb5c0fbcf };
+
+static bool
+libhexa_cachenonce (struct chip_resultsa *nonce_cache, uint32_t nonce)
+{
+  int i = 0;
+  while (i < HEXA_NONCE_CASH_SIZE && nonce_cache->nonces[i] != nonce)
+    i++;
+  if (i < HEXA_NONCE_CASH_SIZE)
+    return false;
+  //Rotate
+  if (nonce_cache->nonce_cache_write_pos == HEXA_NONCE_CASH_SIZE)
+    nonce_cache->nonce_cache_write_pos = 0;
+  nonce_cache->nonces[nonce_cache->nonce_cache_write_pos++] = nonce;
+  return true;
+}
+
+static void
+libhexa_generatenrange_new (unsigned char *buf, int asic_num)
+{
+  uint32_t nonceAdd;
+  int noncePos;
+  int64_t nonceCalc = 0x100000000ll;
+  nonceCalc /= asic_num;
+  nonceAdd = (uint32_t) nonceCalc;
+  uint32_t chip_noce;
+  for (noncePos = 0; noncePos < asic_num; noncePos++)
+    {
+      /*
+       * chip_noce = htole32(noncePos * nonceAdd);
+       */
+      chip_noce = noncePos * nonceAdd;
+      memcpy (buf + noncePos * 4, &chip_noce, 4);
+    }
+}
+
+char *
+libhexa_set_config_voltage (char *arg)
+{
+  int val1, ret;
+  ret = sscanf (arg, "%d", &val1);
+  if (ret < 1)
+    return "No values passed to hexminera-voltage";
+  if (val1 < HEXA_MIN_COREMV || val1 > HEXA_MAX_COREMV)
+    return "Invalid value passed to hexminera-voltage";
+  opt_hexminera_core_voltage = val1;
+  return NULL;
+}
+
+/*
+    Thanks to BkkCoins & devileraser!
+ */
+
+static void
+libhexa_calc_hexminer (struct work *work, struct hexminera_task *ht)
+{
+  uint32_t a0a1a2e0e1e2[6];
+  uint32_t A, B, C, D, E, F, G, H, T;
+  uint32_t state[8];
+  uint32_t data[3];
+  memcpy (&state, work->midstate, 32);
+  memcpy (&data, work->data + 64, 12);
+#if defined(__BIG_ENDIAN__) || defined(MIPSEB)
+  int i;
+  for (i = 0; i < 8; i++)
+    state[i] = htole32 (state[i]);
+  for (i = 0; i < 3; i++)
+    data[i] = htole32 (data[i]);
+#endif
+  A = state[0];
+  B = state[1];
+  C = state[2];
+  D = state[3];
+  E = state[4];
+  F = state[5];
+  G = state[6];
+  H = state[7];
+  R (A, B, C, D, E, F, G, H, data[0], SHA256_K[0]);
+  a0a1a2e0e1e2[0] = htole32 (H);
+  a0a1a2e0e1e2[3] = htole32 (D);
+  R (H, A, B, C, D, E, F, G, data[1], SHA256_K[1]);
+  a0a1a2e0e1e2[1] = htole32 (G);
+  a0a1a2e0e1e2[4] = htole32 (C);
+  R (G, H, A, B, C, D, E, F, data[2], SHA256_K[2]);
+  a0a1a2e0e1e2[2] = htole32 (F);
+  a0a1a2e0e1e2[5] = htole32 (B);
+  memcpy (&ht->a0, &a0a1a2e0e1e2[0], 4);
+  memcpy (&ht->a1, &a0a1a2e0e1e2[1], 4);
+  memcpy (&ht->a2, &a0a1a2e0e1e2[2], 4);
+  memcpy (&ht->e0, &a0a1a2e0e1e2[3], 4);
+  memcpy (&ht->e1, &a0a1a2e0e1e2[4], 4);
+  memcpy (&ht->e2, &a0a1a2e0e1e2[5], 4);
+}
+
+/*
+    From Hexminer core developer Thanks!
+ */
+
+static void
+libhexa_generateclk (uint16_t HashClock, uint16_t XCLKIN, uint32_t * res)
+{
+  uint32_t configL = 0;
+  uint32_t configH = 0;
+  int RValue = XCLKIN;
+  int NValue = (HashClock * 2 * RValue / XCLKIN);
+  configL =
+    ((uint32_t) RValue << 29) | ((uint32_t) NValue << 18) |
+    HEXA_CLOCK_LOW_CFG;
+  configH = ((uint32_t) RValue >> 3) | HEXA_CLOCK_HIGH_CFG;
+  res[0] = htole32 (configL);
+  res[1] = htole32 (configH);
+}
+
+static void
+libhexa_csum (unsigned char *startptr, unsigned char *endptr,
+              unsigned char *resptr)
+{
+
+  unsigned char *b = startptr;
+  uint8_t sum = 0;
+  while (b < endptr)
+    sum += *b++;
+  memcpy (resptr, &sum, 1);
+}
+
+static bool
+libhexa_get_options (int this_option_offset, int *asic_count, int *frequency)
+{
+  char buf[BUFSIZ + 1];
+  char *ptr, *comma, *colon, *colon2, *colon3, *colon4;
+  bool timeout_default;
+  size_t max;
+  int i, tmp;
+  if (opt_hexminera_options == NULL)
+    buf[0] = '\0';
+  else
+    {
+      ptr = opt_hexminera_options;
+      for (i = 0; i < this_option_offset; i++)
+        {
+          comma = strchr (ptr, ',');
+          if (comma == NULL)
+            break;
+          ptr = comma + 1;
+        }
+      comma = strchr (ptr, ',');
+      if (comma == NULL)
+        max = strlen (ptr);
+      else
+        max = comma - ptr;
+      if (max > BUFSIZ)
+        max = BUFSIZ;
+      strncpy (buf, ptr, max);
+      buf[max] = '\0';
+    }
+  if (!(*buf))
+    return false;
+  colon = strchr (buf, ':');
+  if (colon)
+    *(colon++) = '\0';
+  tmp = atoi (buf);
+  if (tmp > 0 && tmp <= HEXA_DEFAULT_ASIC_NUM)
+    *asic_count = tmp;
+  else
+    {
+      quit (1,
+            "Invalid hexminera-options for " "asic_count (%s) must be 1 ~ %d",
+            buf, HEXA_DEFAULT_ASIC_NUM);
+    }
+  if (colon && *colon)
+    {
+      tmp = atoi (colon);
+      if (tmp < HEXA_MIN_FREQUENCY || tmp > HEXA_MAX_FREQUENCY)
+        {
+          quit
+            (1,
+             "Invalid hexminera-options for frequency (%s) must be %d <= frequency <= %d",
+             colon, HEXA_MIN_FREQUENCY, HEXA_MAX_FREQUENCY);
+        }
+      *frequency = tmp;
+    }
+  return true;
+}
+
+static bool
+libhexa_usb_dead (struct cgpu_info *hexminera)
+{
+  struct cg_usb_device *usbdev;
+  struct hexminera_info *info = hexminera->device_data;
+  
+  usbdev = hexminera->usbdev;
+  bool ret = (usbdev == NULL
+          || usbdev->handle == NULL
+          || hexminera->shutdown
+          || info->shut_read  || info->shut_write || info->shut_reset || info->shut_read
+          || hexminera->usbinfo.nodev || hexminera->deven != DEV_ENABLED);
+  if(ret)        
+  	hexminera->shutdown = true;
+  	
+  return ret;
+}
+
+
+unsigned long long
+libhexa_et ()
+{
+struct timeval tv;
+
+gettimeofday(&tv, NULL);
+
+return (unsigned long long)(tv.tv_sec) * 1000 + (unsigned long long)(tv.tv_usec) / 1000;
+    
+} 
+  
+static int
+libhexa_sendHashData (struct cgpu_info *hexminera, unsigned char *sendbuf,
+                      size_t buf_len)
+{
+  struct hexminera_info *info = hexminera->device_data;
+  struct cg_usb_device *usbdev;
+  int wrote = 0, written = 0;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminera->usbdev;
+  if (libhexa_usb_dead (hexminera))
+    goto out;
+  while (written < buf_len && err == LIBUSB_SUCCESS)
+    {
+      err = libusb_bulk_transfer
+        (usbdev->handle,
+         0x02,
+         sendbuf + written,
+         MIN (HEXA_USB_WR_SIZE, buf_len - written), &wrote,
+         HEXA_USB_WR_TIME_OUT);
+      if (err == LIBUSB_SUCCESS)
+        written += wrote;
+    }
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+  	info->shut_write = true; 
+	    
+  return written;
+}
+
+static void
+libhexa_reset (struct cgpu_info *hexminera)
+{
+
+  struct hexminera_info *info = hexminera->device_data;
+  struct cg_usb_device *usbdev;
+  int err = LIBUSB_SUCCESS;
+  
+  usbdev = hexminera->usbdev;
+  if (libhexa_usb_dead (hexminera))
+    goto out;
+  err = libusb_reset_device (usbdev->handle);
+out:
+ 
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+	   info->shut_reset = true; 
+     
+  info->usb_reset_count++;
+
+}
+
+static int libhexa_readHashData
+  (struct cgpu_info *hexminera,
+   unsigned char *hash, int *hash_write_pos, int timeout, bool read_once)
+{
+  struct hexminera_info *info = hexminera->device_data;
+  struct cg_usb_device *usbdev;
+  int read = 0, total = 0;
+  int err = LIBUSB_SUCCESS;
+  
+  usbdev = hexminera->usbdev;
+  if (libhexa_usb_dead (hexminera))
+    goto out;
+  while (*hash_write_pos + HEXA_USB_R_SIZE < HEXA_HASH_BUF_SIZE
+         && err == LIBUSB_SUCCESS)
+    {
+      err =
+        libusb_bulk_transfer (usbdev->handle, 0x82, hash + *hash_write_pos,
+                              HEXA_USB_R_SIZE, &read, timeout);
+      if (err == LIBUSB_SUCCESS)
+        {
+          *hash_write_pos += read;
+          total += read;
+        }
+      if (read_once)
+        break;
+    }
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    {
+      info->shut_read = true; 
+    }
+  
+  return err;
+}
+
+static int
+hexminera_predecode_nonce (struct cgpu_info *hexminera, struct thr_info *thr,
+                           uint32_t nonce, uint8_t work_id)
+{
+  struct hexminera_info *info = hexminera->device_data;
+  struct work *work_sub;
+
+  
+  if (info->hexworks[work_id]->pool == NULL)
+      return 0;
+  work_sub = copy_work_noffset_fast_no_id (info->hexworks[work_id], 0);
+  
+  if (test_nonce (work_sub, nonce))
+    {
+      submit_tested_work_no_clone (thr, work_sub, true);
+      return 1;
+    }
+  else
+    {
+      free_work (work_sub);
+    }
+
+  return 0;
+}
+
+/*
+    From Hexminer core developer Thanks!
+ */
+
+static void
+libhexa_getvoltage (uint16_t wr_bukvoltage, int *info_pic_voltage_readings)
+{
+  float voltagehuman;
+  voltagehuman =
+    (float) ((float) wr_bukvoltage * (float) 1000 * (float) 3.3 /
+             ((1 << 12) - 1));
+  *info_pic_voltage_readings = (int) voltagehuman;
+}
+
+/*
+    From Hexminer core developer Thanks!
+ */
+
+static void
+libhexa_setvoltage (int info_voltage, uint16_t * refvoltage)
+{
+  uint16_t voltageadc;
+  voltageadc =
+    (uint16_t) ((float) info_voltage / (float) 1000 / (float) 3.3 *
+                ((1 << 12) - 1));
+  *refvoltage = htole16 (voltageadc);
+}
+
+static int
+libhexa_eatHashData (struct worka_result *wr, unsigned char *hash,
+                     int *hash_read_pos, int *hash_write_pos)
+{
+  uint8_t psum;
+  int wrpos;
+  unsigned char *csum_pos;
+  bool ok;
+eat:
+  while (*hash_read_pos < *hash_write_pos && hash[*hash_read_pos] != 0x53)
+    {
+      *hash_read_pos += 1;
+    }
+  if (*hash_write_pos - *hash_read_pos < HEXA_BASE_WORK_SIZE)
+    return HEXA_BUF_SKIP;
+
+  memcpy ((char *) &wr->startbyte, &hash[*hash_read_pos],
+          HEXA_BASE_WORK_SIZE - 1);
+  wr->address = htole16 (wr->address);
+  /* Address is outside be strict to avoid mem corruption - not fancy but it works */
+  //applog (LOG_ERR , "libhexa_eatHashData wr->command %0x, wr->address %0x,wr->datalength %0x, ", wr->command,wr->address,wr->datalength  ); 
+  ok = (wr->command == 0x52) &&
+    ((wr->address == HEXA_WORKANSWER_ADR && wr->datalength == 0x06)
+     || (wr->address == HEXA_WORKANSWER_ADR && wr->datalength == 0x0C)
+     || (wr->address == HEXA_WORKANSWER_STAT_ADR && wr->datalength == 1));
+  if (!ok)
+    {
+      *hash_read_pos += 1;
+      goto eat;
+    }
+  if (*hash_write_pos - *hash_read_pos <
+      HEXA_BASE_WORK_SIZE + wr->datalength * 2)
+    return HEXA_BUF_SKIP;
+  csum_pos =
+    hash + *hash_read_pos + HEXA_BASE_WORK_SIZE + wr->datalength * 2 - 1;
+  //Crap?
+  if (csum_pos - hash < HEXA_HASH_BUF_SIZE)
+    {
+      //That was writing somewhere and corrupting memory because of faulty usb reads....
+      libhexa_csum (hash + *hash_read_pos, csum_pos, &psum);
+      if (psum != *csum_pos)
+        {
+          *hash_read_pos += 1;
+          return HEXA_BUF_ERR;
+        }
+    }
+  else
+    {
+
+      *hash_read_pos += 1;
+      return HEXA_BUF_ERR;
+    }
+  wrpos = (wr->address - HEXA_WORKANSWER_ADR) + HEXA_BASE_WORK_SIZE - 1;
+
+  memcpy
+    ((char *) &wr->startbyte + wrpos,
+     &hash[*hash_read_pos + HEXA_BASE_WORK_SIZE - 1],
+     MIN (wr->datalength * 2, HEXA_MAX_WORK_SIZE - HEXA_BASE_WORK_SIZE - 1));
+  *hash_read_pos += HEXA_BASE_WORK_SIZE + wr->datalength * 2;
+
+  return HEXA_BUF_DATA;
+
+}
+
+static void
+BitUpdateInRAMAndSend (struct cgpu_info *hexminera, uint16_t address,
+                       uint16_t bitPos, bool value)
+{
+  unsigned char buf[10];
+  uint16_t wr_adr = htole16 (address);
+  buf[0] = 0x53;
+  buf[1] = 0x01;
+  buf[2] = 0x42;
+  memcpy (buf + 3, &wr_adr, 2);
+  if (value == true)
+    {
+      buf[6] = 0x80;
+    }
+  else
+    {
+      buf[6] = 0x00;
+    }
+  buf[5] = bitPos;
+  libhexa_csum (buf, buf + 7, buf + 7);
+  libhexa_sendHashData (hexminera, buf, 8);
+}
+
+static void
+libhexa_get_words (struct cgpu_info *hexminera, uint16_t address,
+                   uint8_t words)
+{
+  unsigned char status[10];
+  uint16_t wr_adr = htole16 (address);
+  status[0] = 0x53;
+  status[1] = 0x01;
+  status[2] = 0x52;
+  memcpy (status + 3, &wr_adr, 2);
+  status[5] = words;
+  status[6] = 0x00;
+  libhexa_csum (status, status + 7, status + 7);
+  libhexa_sendHashData (hexminera, status, 8);
+}
+
+static void
+libhexa_set_word (struct cgpu_info *hexminera, uint16_t address,
+                  uint16_t word)
+{
+  unsigned char status[10];
+  uint16_t wr_adr = htole16 (address);
+  uint16_t ledata = htole16 (word);
+  status[0] = 0x53;
+  status[1] = 0x01;
+  status[2] = 0x57;
+  memcpy (status + 3, &wr_adr, 2);
+  memcpy (status + 5, &ledata, 2);
+  libhexa_csum (status, status + 7, status + 7);
+  libhexa_sendHashData (hexminera, status, 8);
+}
--- cg_o/hubpower.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer/hubpower.c	2014-04-10 10:37:32.217862132 +0300
@@ -0,0 +1,280 @@
+/* hubpower -- control the power settings for a USB hub
+ *
+ * To build: gcc -o hubpower hubpower.c
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+//#include <strings.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+
+#include <asm/byteorder.h>
+#include <linux/usbdevice_fs.h>
+#include <linux/usb/ch9.h>
+
+#define USB_HUB_TIMEOUT     5000    /* milliseconds */
+#define USB_PORT_FEAT_POWER 8
+
+#define USB_DT_HUB      (USB_TYPE_CLASS | 0x09)
+#define USB_DT_HUB_SIZE     7
+
+struct usb_hub_descriptor {
+    __u8  bDescLength;
+    __u8  bDescriptorType;
+    __u8  bNbrPorts;
+    __le16 wHubCharacteristics;
+    __u8  bPwrOn2PwrGood;
+    __u8  bHubContrCurrent;
+} __attribute__ ((packed));
+
+struct usb_port_status {
+    __le16 wPortStatus;
+    __le16 wPortChange;
+} __attribute__ ((packed));
+
+#define USB_PORT_STAT_CONNECTION    0x0001
+#define USB_PORT_STAT_ENABLE        0x0002
+#define USB_PORT_STAT_SUSPEND       0x0004
+#define USB_PORT_STAT_OVERCURRENT   0x0008
+#define USB_PORT_STAT_RESET     0x0010
+#define USB_PORT_STAT_L1        0x0020
+/* bits 6 to 7 are reserved */
+#define USB_PORT_STAT_POWER     0x0100
+#define USB_PORT_STAT_LOW_SPEED     0x0200
+#define USB_PORT_STAT_HIGH_SPEED        0x0400
+#define USB_PORT_STAT_TEST              0x0800
+#define USB_PORT_STAT_INDICATOR         0x1000
+#define USB_PORT_STAT_POWER_3       0x0200  /* USB 3.0 */
+
+
+int fd;     /* Hub device file */
+int usb_level;
+
+
+void usage(void)
+{
+    fprintf(stderr, "Usage:"
+        "\thubpower busnum:devnum power {portnum (on|off)} ...\n"
+        "\thubpower busnum:devnum status\n"
+        "\thubpower busnum:devnum bind\n"
+        );
+    exit(1);
+}
+
+void port_status(int portnum)
+{
+    struct usbdevfs_ctrltransfer ctrl;
+    struct usb_port_status pstat;
+    int rc;
+
+    ctrl.bRequestType = USB_DIR_IN | USB_TYPE_CLASS |
+            USB_RECIP_OTHER;
+    ctrl.bRequest = USB_REQ_GET_STATUS;
+    ctrl.wValue = 0;
+    ctrl.wIndex = portnum;
+    ctrl.wLength = sizeof(pstat);
+    ctrl.timeout = USB_HUB_TIMEOUT;
+    ctrl.data = &pstat;
+    rc = ioctl(fd, USBDEVFS_CONTROL, &ctrl);
+    if (rc == -1) {
+        fprintf(stderr, "Error in ioctl "
+            "(get port %d status): %s\n",
+            portnum, strerror(errno));
+        return;
+    }
+
+    printf("Port %2d status: %04x ", portnum, pstat.wPortStatus);
+
+    if (usb_level <= 2) {
+        if (pstat.wPortStatus & USB_PORT_STAT_INDICATOR)
+            printf(" Indicator");
+        if (pstat.wPortStatus & USB_PORT_STAT_TEST)
+            printf(" Test-Mode");
+        if (pstat.wPortStatus & USB_PORT_STAT_HIGH_SPEED)
+            printf(" High-Speed");
+        if (pstat.wPortStatus & USB_PORT_STAT_LOW_SPEED)
+            printf(" Low-Speed");
+        if (pstat.wPortStatus & USB_PORT_STAT_POWER)
+            printf(" Power-On");
+        else
+            printf(" Power-Off");
+    } else if (usb_level == 3) {
+        if (pstat.wPortStatus & USB_PORT_STAT_POWER_3)
+            printf(" Power-On");
+        else
+            printf(" Power-Off");
+    }
+
+    if (pstat.wPortStatus & USB_PORT_STAT_RESET)
+        printf(" Resetting");
+    if (pstat.wPortStatus & USB_PORT_STAT_OVERCURRENT)
+        printf(" Overcurrent");
+    if (pstat.wPortStatus & USB_PORT_STAT_SUSPEND)
+        printf(" Suspended");
+    if (pstat.wPortStatus & USB_PORT_STAT_ENABLE)
+        printf(" Enabled");
+    if (pstat.wPortStatus & USB_PORT_STAT_CONNECTION)
+        printf(" Connected");
+
+    printf("\n");
+}
+
+int main(int argc, char **argv)
+{
+    int busnum, devnum, numports;
+    enum {DO_POWER, DO_STATUS, DO_BIND} action;
+    char fname1[40], fname2[40];
+    int rc;
+    int portnum;
+    struct usb_device_descriptor dev_descr;
+    struct usb_hub_descriptor hub_descr;
+    struct usbdevfs_ctrltransfer ctrl;
+    struct usbdevfs_ioctl usb_ioctl;
+    int bus_endian;
+
+    if (argc < 3)
+        usage();
+    if (sscanf(argv[1], "%d:%d", &busnum, &devnum) != 2 ||
+            busnum <= 0 || busnum > 255 ||
+            devnum <= 0 || devnum > 255)
+        usage();
+
+    if (strcmp(argv[2], "power") == 0) {
+        action = DO_POWER;
+        if ((argc - 3) % 2 != 0)
+            usage();
+    } else if (strcmp(argv[2], "status") == 0) {
+        action = DO_STATUS;
+        if (argc != 3)
+            usage();
+    } else if (strcmp(argv[2], "bind") == 0) {
+        action = DO_BIND;
+        if (argc != 3)
+            usage();
+    } else {
+        usage();
+    }
+
+    sprintf(fname1, "/dev/bus/usb/%03d/%03d", busnum, devnum);
+    sprintf(fname2, "/proc/bus/usb/%03d/%03d", busnum, devnum);
+
+    bus_endian = 1;
+    fd = open(fname1, O_RDWR);
+    if (fd < 0) {
+        int err1 = errno;
+
+        bus_endian = 0;
+        fd = open(fname2, O_RDWR);
+        if (fd < 0) {
+            fprintf(stderr, "Unable to open device file %s: %s\n",
+                    fname1, strerror(err1));
+            fprintf(stderr, "Unable to open device file %s: %s\n",
+                    fname2, strerror(errno));
+            return 1;
+        }
+    }
+
+    rc = read(fd, &dev_descr, USB_DT_DEVICE_SIZE);
+    if (rc != USB_DT_DEVICE_SIZE) {
+        perror("Error reading device descriptor");
+        return 1;
+    }
+    if (dev_descr.bDeviceClass != USB_CLASS_HUB) {
+        fprintf(stderr, "Device %d:%d is not a hub\n",
+                busnum, devnum);
+        return 1;
+    }
+    if (bus_endian) {
+        dev_descr.bcdUSB = __le16_to_cpu(dev_descr.bcdUSB);
+    }
+    usb_level = dev_descr.bcdUSB >> 8;
+
+    ctrl.bRequestType = USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_DEVICE;
+    ctrl.bRequest = USB_REQ_GET_DESCRIPTOR;
+    ctrl.wValue = USB_DT_HUB << 8;
+    ctrl.wIndex = 0;
+    ctrl.wLength = USB_DT_HUB_SIZE;
+    ctrl.timeout = USB_HUB_TIMEOUT;
+    ctrl.data = &hub_descr;
+    rc = ioctl(fd, USBDEVFS_CONTROL, &ctrl);
+    if (rc == -1) {
+        perror("Error in ioctl (read hub descriptor)");
+        return 1;
+    }
+    numports = hub_descr.bNbrPorts;
+
+    if (action == DO_STATUS) {
+        for (portnum = 1; portnum <= numports; ++portnum)
+            port_status(portnum);
+        return 0;
+    }
+
+    if (action == DO_BIND) {
+        usb_ioctl.ifno = 0;
+        usb_ioctl.ioctl_code = USBDEVFS_CONNECT;
+        usb_ioctl.data = NULL;
+        rc = ioctl(fd, USBDEVFS_IOCTL, &usb_ioctl);
+        if (rc == -1) {
+            perror("Error in ioctl (USBDEVFS_CONNECT)");
+            return 1;
+        }
+        printf("Bind-driver request sent to the kernel\n");
+        return 0;
+    }
+
+    if (action == DO_POWER) {
+        int i;
+
+        usb_ioctl.ifno = 0;
+        usb_ioctl.ioctl_code = USBDEVFS_DISCONNECT;
+        usb_ioctl.data = NULL;
+        rc = ioctl(fd, USBDEVFS_IOCTL, &usb_ioctl);
+        if (rc == -1 && errno != ENODATA) {
+            perror("Error in ioctl (USBDEVFS_DISCONNECT)");
+            return 1;
+        }
+
+        for (i = 3; i < argc; i += 2) {
+            portnum = atoi(argv[i]);
+            if (portnum < 1 || portnum > numports) {
+                fprintf(stderr, "Invalid port number: %d\n",
+                        portnum);
+                continue;
+            }
+
+            if (strcmp(argv[i+1], "on") == 0)
+                ctrl.bRequest = USB_REQ_SET_FEATURE;
+            else if (strcmp(argv[i+1], "off") == 0)
+                ctrl.bRequest = USB_REQ_CLEAR_FEATURE;
+            else {
+                fprintf(stderr, "Invalid port power level: %s\n)",
+                        argv[i+1]);
+                continue;
+            }
+
+            ctrl.bRequestType = USB_DIR_OUT | USB_TYPE_CLASS |
+                    USB_RECIP_OTHER;
+            ctrl.wValue = USB_PORT_FEAT_POWER;
+            ctrl.wIndex = portnum;
+            ctrl.wLength = 0;
+            ctrl.timeout = USB_HUB_TIMEOUT;
+            ctrl.data = NULL;
+            rc = ioctl(fd, USBDEVFS_CONTROL, &ctrl);
+            if (rc == -1) {
+                fprintf(stderr, "Error in ioctl "
+                    "(set/clear port %d feature): %s\n",
+                    portnum, strerror(errno));
+                continue;
+            }
+
+            port_status(portnum);
+        }
+    }
+    return 0;
+}
+
+
--- cg_o/driver-hexminerc.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer/driver-hexminerc.c	2014-04-11 11:33:18.853851446 +0300
@@ -0,0 +1,617 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:19:47 */
+/*
+ * Copyright 2013 Con Kolivas <kernel@kolivas.org> Copyright 2012-2013 Xiangfu
+ * <xiangfu@openmobilefree.com> Copyright 2012 Luke Dashjr Copyright 2012 Andrew
+ * Smith This program is free software;
+ * you can redistribute it and/or modify it under the terms of the GNU General
+ * Public License as published by the Free Software Foundation;
+ * either version 3 of the License, or (at your option) any later version. See
+ * COPYING for more details. Thank you guys!
+ */
+#include "config.h"
+#include <limits.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <ctype.h>
+#include <dirent.h>
+#include <unistd.h>
+#ifndef WIN32
+#include <sys/select.h>
+#include <termios.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#ifndef O_CLOEXEC
+#define O_CLOEXEC	0
+#endif
+#else
+#include "compat.h"
+#include <windows.h>
+#include <io.h>
+#endif
+#include "elist.h"
+#include "miner.h"
+#include "usbutils.h"
+#include "driver-hexminerc.h"
+#include "util.h"
+
+extern unsigned int work_block;
+extern struct work *copy_work_noffset_fast_no_id(struct work *base_work, int noffset);
+static int option_offset = -1;
+struct device_drv hexminerc_drv;
+int opt_hexminerc_core_voltage = HEXC_DEFAULT_CORE_VOLTAGE;
+#include "libhexc.c"
+extern bool no_work;
+static void
+hexminerc_flush_work (struct cgpu_info *hexminerc)
+{
+  struct hexminerc_info *info = hexminerc->device_data;
+  
+  cgsem_post (&info->qsem);
+
+}
+
+static int
+hexminerc_send_task (struct hexminerc_task *ht, struct cgpu_info *hexminerc)
+{
+  int ret = 0;
+  size_t nr_len = HEXMINERC_TASK_SIZE;
+  struct hexminerc_info *info;
+  info = hexminerc->device_data;
+
+  libhexc_csum (&ht->startbyte, &ht->csum, &ht->csum);
+
+
+  ret = libhexc_sendHashData (hexminerc, &ht->startbyte, nr_len);
+
+  if (ret != nr_len)
+    {
+      libhexc_reset (hexminerc);
+      info->usb_w_errors++;
+      return -1;
+    }
+
+  return ret;
+}
+
+static inline void
+hexminerc_create_task (bool reset_work, struct hexminerc_task *ht,
+                       struct work *work)
+{
+  if (reset_work)
+    {
+      ht->status = HEXC_STAT_NEW_WORK_CLEAR_OLD;
+    }
+  else
+    {
+      ht->status = HEXC_STAT_NEW_WORK;
+    }
+  memcpy (ht->midstate, work->midstate, 32);
+  memcpy (ht->merkle, work->data + 64, 12);
+  ht->id = (uint8_t) work->subid;
+  libhexc_calc_hexminer (work, ht);
+}
+
+static inline void
+hexminerc_init_task (struct hexminerc_task *ht, struct hexminerc_info *info)
+{
+  ht->startbyte = 0x53;
+  ht->datalength = (uint8_t) ((HEXMINERC_TASK_SIZE - 6) / 2);
+  ht->command = 0x57;
+  ht->address = htole16 (HEXC_WORKQUEUE_ADR);
+  libhexc_generateclk (info->frequency, HEXC_DEFAULT_XCLKIN_CLOCK,
+                       (uint32_t *) & ht->clockcfg[0]);
+  libhexc_setvoltage (info->core_voltage, &ht->refvoltage);
+  ht->chipcount = htole16 (info->asic_count);
+  ht->hashclock = htole16 ((uint16_t) info->frequency);
+  ht->startnonce = 0x00000000;
+}
+static bool
+need_reset(struct cgpu_info *hexminerc)
+{
+	
+  struct hexminerc_info *info = hexminerc->device_data;
+
+	time_t now = time (NULL);
+	bool ret = false;
+	int i = 0;	
+	int secs = 90;
+	
+	while (i < HEXC_DEFAULT_ASIC_NUM)
+        {
+        	
+        	if(info->matching_work[i] && ((info->last_chip_valid_work[i] + secs) < now)) {
+        		//applog(LOG_ERR, "HEXC %i Chip[%i] last valid work %i secs ago", hexminerc->device_id, i + 1, (int)(now-info->last_chip_valid_work[i]));
+        		ret = true;
+        		break;
+        	}
+        	i++;
+        }	
+        
+   if(ret || no_work) {
+   	ret = !no_work;
+     i = 0; 	
+     while (i < HEXC_DEFAULT_ASIC_NUM)
+      	info->last_chip_valid_work[i++] = now;
+   }
+    
+  return ret;      	
+}
+static void *
+hexminerc_send_tasks (void *userdata)
+{
+  struct cgpu_info *hexminerc = (struct cgpu_info *) userdata;
+  struct hexminerc_info *info = hexminerc->device_data;
+  struct hexminerc_task *ht;
+  struct thr_info *thr = info->thr;
+  struct work *work = NULL;
+  struct work *tmpwork = NULL;
+  char threadname[24];
+  int write_pos = 0;
+  int jobs_to_send = 2;
+  bool reset_work = true;
+  int send_jobs, roll, ret;
+  unsigned int work_block_local;
+  bool power;
+  snprintf (threadname, 24, "hexc_send/%d", hexminerc->device_id);
+  RenameThread (threadname);
+ // libhexc_reset (hexminerc);
+
+  ht = calloc (sizeof (struct hexminerc_task), 1);
+  hexminerc_init_task (ht, info);
+
+
+  while (!libhexc_usb_dead (hexminerc))
+    {
+      send_jobs = 0;
+      
+        	if(time (NULL) - info->power_checked > 30) {
+    	
+    			info->power_checked = time (NULL);
+    			mutex_lock(&info->power);
+    			power = need_reset(hexminerc);
+    			mutex_unlock(&info->power);
+    			if(power) {
+    				libhexc_set_word (hexminerc, HEXC_WORKQUEUE_ADR + 80, 0x0004);
+            reset_work = true;
+            cgsleep_ms (200);
+    			}
+    	}
+      
+      while ((work_block_local != work_block) || (send_jobs < jobs_to_send && (info->wr_status == HEXC_STAT_IDLE
+                                || info->wr_status == HEXC_STAT_NEW_WORK))
+             || reset_work)
+        {
+        again:
+          if (!work)
+            {
+              roll = 0;
+              work = get_work (thr, thr->id);
+							work->ping = 1;
+              if(work_block_local != work_block) {
+        	 			reset_work = true;
+        	 			work_block_local = work_block;
+        			}
+            }
+            
+        if (stale_work (work, false))
+        {
+          free_work (work);
+          work = NULL;
+          goto again;
+        }   
+          
+          if (write_pos >= HEXMINERC_ARRAY_SIZE_REAL || reset_work)
+            write_pos = 0;
+        
+              work->subid = write_pos;
+              tmpwork = copy_work_noffset_fast_no_id (work, roll++);
+              hexminerc_create_task (reset_work, ht,
+                                 tmpwork);
+              
+              mutex_lock (&info->lock);
+          		free_work (info->hexworks[write_pos]);
+              info->hexworks[write_pos] = tmpwork;
+              mutex_unlock (&info->lock);
+              
+              if (work->drv_rolllimit)
+                {
+                  work->drv_rolllimit--;
+                }
+              else
+                {
+                  free_work (work);
+                  work = NULL;
+                }
+          
+          ret = hexminerc_send_task (ht, hexminerc);
+
+          write_pos++;
+          send_jobs++;
+
+          if (ret == HEXMINERC_TASK_SIZE && reset_work)
+            {       
+              reset_work = false; 
+              send_jobs-=2;
+            }
+        }
+ 		if(!reset_work)
+      cgsem_mswait (&info->qsem, info->usb_timing);
+    }
+  if (work)
+    free_work (work);
+  free (ht);
+  pthread_exit (NULL);
+}
+
+
+
+
+static struct cgpu_info *
+hexminerc_detect_one (libusb_device * dev, struct usb_find_devices *found)
+{
+  int miner_count, asic_count, frequency;
+  int this_option_offset = ++option_offset;
+  struct hexminerc_info *info;
+  struct cgpu_info *hexminerc;
+  bool configured;
+  int i = 0;
+  hexminerc = usb_alloc_cgpu (&hexminerc_drv, HEXC_MINER_THREADS);
+  if (!usb_init (hexminerc, dev, found))
+    {
+      usb_uninit (hexminerc);
+      return NULL;
+    }
+  hexminerc->device_data = calloc (sizeof (struct hexminerc_info), 1);
+  if (unlikely (!(hexminerc->device_data)))
+    {
+      hexminerc->device_data = NULL;
+      usb_uninit (hexminerc);
+      return NULL;
+    }
+  configured =
+    libhexc_get_options (this_option_offset, &asic_count, &frequency);
+  if (opt_hexminerc_core_voltage < HEXC_MIN_COREMV
+      || opt_hexminerc_core_voltage > HEXC_MAX_COREMV)
+    {
+      applog
+        (LOG_ERR,
+         "Invalid hexminerc-voltage %d must be %dmV - %dmV",
+         opt_hexminerc_core_voltage, HEXC_MIN_COREMV, HEXC_MAX_COREMV);
+      free (hexminerc->device_data);
+      hexminerc->device_data = NULL;
+      usb_uninit (hexminerc);
+      return NULL;
+    }
+  info = hexminerc->device_data;
+  info->hexworks = calloc (sizeof (struct work *), HEXMINERC_ARRAY_SIZE);
+  if (unlikely (!(info->hexworks)))
+    {
+      free (hexminerc->device_data);
+      hexminerc->device_data = NULL;
+      usb_uninit (hexminerc);
+      return NULL;
+    }
+  info->wr = (struct workc_result *) malloc (sizeof (struct workc_result));
+  info->array_nonce_cache = calloc (16, sizeof (struct chip_resultsc));
+ 
+  info->readbuf = calloc (HEXC_HASH_BUF_SIZE, sizeof (unsigned char));
+  
+  info->hash_read_pos = 0;
+  info->hash_write_pos = 0;
+  info->shut_read = false;
+  info->shut_write = false;
+  info->shut_reset = false;
+  
+  info->wr_status = HEXC_STAT_IDLE;
+  info->miner_count = HEXC_DEFAULT_MINER_NUM;
+  info->asic_count = HEXC_DEFAULT_ASIC_NUM;
+  info->frequency = HEXC_DEFAULT_FREQUENCY;
+  info->pic_voltage_readings = HEXC_DEFAULT_CORE_VOLTAGE;
+  info->core_voltage = opt_hexminerc_core_voltage;
+  if (configured)
+    {
+      info->asic_count = asic_count;
+      info->frequency = frequency;
+    }
+  info->usb_timing =
+    (int64_t) (0x80000000ll / 1000 / info->asic_count / info->frequency *
+               HEXMINERC_WORK_FACTOR * 2);
+  if (!add_cgpu (hexminerc))
+    {
+      free (info->hexworks);
+      free (hexminerc->device_data);
+      hexminerc->device_data = NULL;
+      hexminerc = usb_free_cgpu (hexminerc);
+      usb_uninit (hexminerc);
+      return NULL;
+    }
+   
+    while (i < HEXMINERC_ARRAY_SIZE)
+    {
+      info->hexworks[i] = calloc (1, sizeof (struct work));
+      info->hexworks[i]->pool = NULL;
+      i++;
+    }
+    
+  i = 0; 
+  info->power_checked = time (NULL);
+  while (i < HEXC_DEFAULT_ASIC_NUM)
+    {
+      info->matching_work[i] = 0;
+      info->last_chip_valid_work[i++] = time (NULL);
+    }
+    
+  libhexc_generatenrange_new ((unsigned char *) &info->nonces_range,
+                              info->asic_count);
+  return hexminerc;
+}
+
+static void
+hexminerc_detect (bool __maybe_unused hotplug)
+{
+  usb_detect (&hexminerc_drv, hexminerc_detect_one);
+}
+
+static void
+do_hexminerc_close (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerc = thr->cgpu;
+  struct hexminerc_info *info = hexminerc->device_data;
+  int i = 0;
+  cgsleep_ms (300);
+  pthread_join (info->write_thr, NULL);
+  
+  pthread_mutex_destroy (&info->lock);
+  pthread_mutex_destroy (&info->power);
+  cgsem_destroy (&info->qsem);
+
+  while (i < HEXMINERC_ARRAY_SIZE)
+    {
+      free_work (info->hexworks[i]);
+      i++;
+    }
+  free (info->hexworks);
+  free (info->readbuf);
+  free (info->array_nonce_cache);
+  free (info->wr);
+  //Hotplug Story
+  //free (hexminerc->device_data);
+  //hexminerc->device_data = NULL;
+  //thr->cgpu = usb_free_cgpu(hexminerc);
+}
+
+static void
+hexminerc_shutdown (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerc = thr->cgpu;
+  struct hexminerc_info *info = hexminerc->device_data;
+
+  cgsem_post (&info->qsem);
+  
+  do_hexminerc_close (thr);
+  
+  usb_nodev(hexminerc);
+}
+
+
+
+static bool
+hexminerc_thread_init (struct thr_info *thr)
+{
+  struct cgpu_info *hexminerc = thr->cgpu;
+  struct hexminerc_info *info = hexminerc->device_data;
+  info->thr = thr;
+  mutex_init (&info->lock);
+  mutex_init (&info->power);
+  cgsem_init (&info->qsem);
+
+  if (pthread_create
+      (&info->write_thr, NULL, hexminerc_send_tasks, (void *) hexminerc))
+    quit (1, "Failed to create hexminerc write_thr");
+
+  return true;
+}
+
+
+static int64_t
+hexminerc_scanhash (struct thr_info *thr)
+{
+
+  struct cgpu_info *hexminerc = thr->cgpu;
+  struct hexminerc_info *info = hexminerc->device_data;
+  
+  uint32_t nonce;
+  int notdupe, found, i, lastchippos;
+ 
+  int ret_r = 0;
+  
+  int64_t hash_count = 0;
+   if (libhexc_usb_dead (hexminerc))
+    return -1;
+    
+    if (info->hash_write_pos + HEXC_USB_R_SIZE >= HEXC_HASH_BUF_SIZE)
+        {
+          info->hash_write_pos = info->hash_write_pos - info->hash_read_pos;
+          memcpy (info->readbuf, info->readbuf + info->hash_read_pos, info->hash_write_pos);
+          info->hash_read_pos = 0;
+   }
+   
+   if (info->hash_write_pos - info->hash_read_pos > 7)
+        {
+        again:
+          ret_r =
+            libhexc_eatHashData (info->wr, info->readbuf, &info->hash_read_pos,
+                                 &info->hash_write_pos);
+          if (ret_r > HEXC_BUF_DATA)
+            goto out;
+
+          info->wr_status = info->wr->status;
+          if (info->wr->datalength == 1)
+            goto done;
+
+          if (info->wr->lastnonceid > HEXMINERC_ARRAY_SIZE_REAL)
+            info->wr->lastnonceid = 0;
+
+          nonce = htole32 (info->wr->lastnonce);
+          i = 0;
+          while (i < info->asic_count)
+            {
+              if (nonce < info->nonces_range[++i])
+                {
+                  lastchippos = --i;
+                  break;
+                }
+            }
+
+            if (i == info->asic_count)
+            lastchippos = info->asic_count - 1;
+
+          notdupe =
+            libhexc_cachenonce (&info->array_nonce_cache[lastchippos], nonce);
+          if (lastchippos > 0)
+            notdupe &= libhexc_cachenonce (&info->array_nonce_cache[0], nonce);
+            
+          if (notdupe)
+            {
+              found = hexminerc_predecode_nonce (hexminerc, thr, nonce,
+                                                 info->wr->lastnonceid);
+              if (found > 0)
+                {
+                	
+                	mutex_lock(&info->power);
+                  info->matching_work[lastchippos]++;
+                  info->last_chip_valid_work[(uint8_t) lastchippos] = time (NULL);
+                  mutex_unlock(&info->power);
+                  if (hash_count == 0)
+                    libhexc_getvoltage (htole16 (info->wr->lastvoltage),
+                                        &info->pic_voltage_readings);
+                  hash_count += found;
+                  
+                }
+              else
+                {
+                  inc_hw_errors (thr);
+                }
+            }
+          else
+            {
+              info->dupe[lastchippos]++;
+            }  
+            
+            
+             out:
+          if (ret_r == HEXC_BUF_ERR)
+            {
+              info->usb_r_errors++;
+            }
+        done:
+          if (info->hash_write_pos - info->hash_read_pos >= HEXC_MAX_WORK_SIZE)
+            goto again;
+        }
+
+      ret_r =
+        libhexc_readHashData (hexminerc, info->readbuf, &info->hash_write_pos,
+                              HEXMINERC_BULK_READ_TIMEOUT, true);
+                              
+
+ 
+   
+  
+      hash_count = (int64_t) (0xffffffffull * hash_count);
+      
+ 
+    
+  if (libhexc_usb_dead (hexminerc))
+    return -1;
+    
+    return hash_count;
+}
+
+
+static void
+get_hexminerc_statline_before (char *buf, size_t bufsiz,
+                               struct cgpu_info *hexminerc)
+{
+	if (!hexminerc->device_data)
+		return;
+  struct hexminerc_info *info = hexminerc->device_data;
+  tailsprintf (buf, bufsiz, "%3d %4d/%4dmV", info->frequency,
+               info->core_voltage, info->pic_voltage_readings);
+}
+
+static struct api_data *
+hexminerc_api_stats (struct cgpu_info *cgpu)
+{
+  struct api_data *root = NULL;
+  struct hexminerc_info *info = cgpu->device_data;
+  if (!info)
+		return NULL;
+  uint64_t dh64, dr64;
+  double dev_runtime;
+  struct timeval now;
+  int i;
+  char displayed_hashes[16], displayed_rolling[16];
+  double hwp =
+    (cgpu->hw_errors +
+     cgpu->diff1) ? (double) (cgpu->hw_errors) / (double) (cgpu->hw_errors +
+                                                           cgpu->diff1) : 0;
+  if (cgpu->dev_start_tv.tv_sec == 0)
+    dev_runtime = total_secs;
+  else
+    {
+      cgtime (&now);
+      dev_runtime = tdiff (&now, &(cgpu->dev_start_tv));
+    }
+  if (dev_runtime < 1.0)
+    dev_runtime = 1.0;
+  dh64 = (double) cgpu->total_mhashes / dev_runtime * 1000000ull;
+  dr64 = (double) cgpu->rolling * 1000000ull;
+  suffix_string (dh64, displayed_hashes, sizeof (displayed_hashes), 4);
+  suffix_string (dr64, displayed_rolling, sizeof (displayed_rolling), 4);
+  root = api_add_string (root, "MHS 5s", displayed_rolling, true);
+  root = api_add_string (root, "MHS av", displayed_hashes, true);
+  root = api_add_int (root, "Hardware Errors", &(cgpu->hw_errors), true);
+  root = api_add_percent (root, "Hardware Errors%", &hwp, true);
+  root = api_add_int (root, "USB Read Errors", &(info->usb_r_errors), true);
+  root = api_add_int (root, "USB Write Errors", &(info->usb_w_errors), true);
+  root =
+    api_add_int (root, "USB Reset Count", &(info->usb_reset_count), true);
+  root =
+    api_add_time (root, "Last Share Time", &(cgpu->last_share_pool_time),
+                  true);
+  root = api_add_int (root, "Chip Count", &(info->asic_count), true);
+  root = api_add_int (root, "Frequency", &(info->frequency), true);
+  root = api_add_int (root, "Core Voltage", &(info->core_voltage), true);
+  root =
+    api_add_int (root, "PIC Voltage Readings", &(info->pic_voltage_readings),
+                 true);
+  for (i = 0; i < info->asic_count; i++)
+    {
+      /*~ */
+      char mcw[24];
+      /*~ */
+      sprintf (mcw, "Chip%d Nonces", i + 1);
+      root = api_add_int (root, mcw, &(info->matching_work[i]), true);
+      sprintf (mcw, "Chip%d Dupes", i + 1);
+      root = api_add_int (root, mcw, &(info->dupe[i]), true);
+    }
+  return root;
+}
+
+
+
+struct device_drv hexminerc_drv = {
+  .drv_id = DRIVER_hexminerc,
+  .dname = "hexminerc",
+  .name = "HEXc",
+  .drv_detect = hexminerc_detect,
+  .thread_init = hexminerc_thread_init,
+  .hash_work = hash_queued_work,
+  .scanwork = hexminerc_scanhash,
+  .flush_work = hexminerc_flush_work,
+  .get_api_stats = hexminerc_api_stats,
+  .get_statline_before = get_hexminerc_statline_before,
+  .thread_shutdown = hexminerc_shutdown,
+};
--- cg_o/driver-hexminerc.h	1970-01-01 02:00:00.000000000 +0200
+++ cgminer/driver-hexminerc.h	2014-04-11 11:33:18.853851446 +0300
@@ -0,0 +1,159 @@
+/*$T indentinput.h GC 1.140 10/16/13 10:20:01 */
+
+/*
+ * Copyright 2013 Avalon project Copyright 2013 Con Kolivas <kernel@kolivas.org>
+ * This program is free software;
+ * you can redistribute it and/or modify it under the terms of the GNU General
+ * Public License as published by the Free Software Foundation;
+ * either version 3 of the License, or (at your option) any later version. See
+ * COPYING for more details. Thank you guys!
+ */
+#ifndef HEXC_H
+#define HEXC_H
+
+#ifdef USE_HEXMINERC
+#include "util.h"
+
+#define HEXC_USB_WR_TIME_OUT				500
+#define HEXMINERC_BULK_READ_TIMEOUT		1000
+#define HEXC_USB_R_SIZE					64
+
+/* hexminerc_task/work_reply status Definitions: */
+#define HEXC_STAT_IDLE					0       /* Idle or data already Sent to the buffer */
+#define HEXC_STAT_NEW_WORK				1       /* Request for write in the buffer */
+#define HEXC_STAT_WAITING				2       /* Wait For Buffer Empty Position */
+#define HEXC_STAT_CLR_BUFF				3       /* Force Buffer Empty */
+#define HEXC_STAT_STOP_REQ				4       /* Stop Request */
+#define HEXC_STAT_NEW_WORK_CLEAR_OLD		5       /* Clear Buffers and after that fill the first buffer */
+#define HEXC_STAT_UNUSED					6
+/* libhexc_eatHashData/BUF_reply status Definitions: */
+#define HEXC_BUF_DATA 0
+#define HEXC_BUF_ERR  1
+#define HEXC_BUF_SKIP 2
+//#define HEXC_USB_RES_THRESH				7000    //about 1 sec
+#define HEXC_DEFAULT_XCLKIN_CLOCK		32      /* In MHz */
+#define HEXC_CLOCK_LOW_CFG				0x00030017
+#define HEXC_CLOCK_HIGH_CFG				(0x0000002e << 3)       /* = 0x00000170 */
+#define HEXMINERC_ARRAY_PIC_SIZE		64
+#define HEXMINERC_ARRAY_SIZE			HEXMINERC_ARRAY_PIC_SIZE * 4
+#define HEXMINERC_ARRAY_SIZE_REAL	HEXMINERC_ARRAY_SIZE - 2
+#define HEXC_NONCE_CASH_SIZE				6
+
+#define HEXMINERC_WORK_FACTOR		0.9
+
+
+#define HEXC_USB_WR_SIZE					64
+#define HEXC_HASH_BUF_SIZE				2048
+
+
+//#define HEXC_MAX_START_DELAY_MS			500
+#define HEXC_MINER_THREADS			1
+#define HEXC_DEFAULT_MINER_NUM		0x01
+#define HEXC_DEFAULT_ASIC_NUM		0x10
+#define HEXC_MIN_FREQUENCY			100
+#define HEXC_MAX_FREQUENCY			2500
+#define HEXC_DEFAULT_FREQUENCY		1500
+#define HEXC_DEFAULT_CORE_VOLTAGE	1100    /* in millivolts */
+#define HEXC_MIN_COREMV				100     /* in millivolts */
+
+/* Do not touch it!!! 1.6V is above the chip specs already */
+#define HEXC_MAX_COREMV	1630    /* in millivolts */
+
+struct chip_resultsc
+{
+  uint8_t nonce_cache_write_pos;
+  uint32_t nonces[HEXC_NONCE_CASH_SIZE];
+};
+
+struct workc_result
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint32_t lastnonce;
+  uint8_t lastnonceid;
+  uint8_t status;
+  uint16_t lastvoltage;
+  uint16_t lasttemperature;
+  uint16_t lastfanrpm;
+  uint8_t csum;
+  uint8_t pad[2];
+} __attribute__ ((packed, aligned (4)));
+
+struct hexminerc_info
+{
+  int miner_count;
+  int asic_count;
+  int core_voltage;
+  int frequency;
+  int hash_read_pos;
+  int hash_write_pos;
+  int usb_r_errors;
+  int usb_w_errors;
+  int usb_reset_count;
+  int pic_voltage_readings;
+  bool shut_read;
+  bool shut_write;
+  bool shut_reset;
+  int64_t usb_timing;
+  int dupe[HEXC_DEFAULT_ASIC_NUM];
+  int matching_work[HEXC_DEFAULT_ASIC_NUM];
+  time_t last_chip_valid_work[HEXC_DEFAULT_ASIC_NUM];
+  time_t power_checked;
+  unsigned char *readbuf;
+  struct workc_result *wr;
+  struct chip_resultsc *array_nonce_cache;
+  uint8_t wr_status;
+  uint32_t nonces_range[HEXC_DEFAULT_ASIC_NUM];
+  pthread_t write_thr;
+  pthread_mutex_t lock;
+  pthread_mutex_t power;
+  cgsem_t qsem;
+  struct thr_info *thr;
+  struct work **hexworks;
+};
+
+struct hexminerc_task
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint32_t clockcfg[2];
+  uint32_t merkle[3];
+  uint32_t a1;
+  uint32_t a0;
+  uint32_t e2;
+  uint32_t e1;
+  uint32_t e0;
+  uint8_t midstate[32];
+  uint32_t a2;
+  uint32_t startnonce;
+  uint8_t id;
+  uint8_t status;
+  uint16_t hashclock;
+  uint16_t chipcount;
+  uint16_t refvoltage;
+  uint16_t reftemperature;
+  uint16_t reffanrpm;
+  uint8_t csum;
+  uint8_t pad[2];
+} __attribute__ ((packed, aligned (4)));
+
+#define HEXC_WORKANSWER_ADR	0x3000
+#define HEXC_WORKANSWER_STAT_ADR HEXC_WORKANSWER_ADR + 4
+#define HEXC_WORKQUEUE_ADR	0x4000
+#define HEXC_PTCON_ADR		0x0C00
+#define HEXC_START_STOP_ADR	0x646E
+#define HEXMINERC_TASK_SIZE	(sizeof(struct hexminerc_task)-2)
+#define HEXC_MAX_WORK_SIZE		(sizeof(struct workc_result) - 2)
+#define HEXC_BASE_WORK_SIZE		6       /* Min uint8_t startbyte + uint8_t datalength + uint8_t command + uint16_t
+                                                 * address;
+                                                 * + uint8_t csum */
+
+extern int opt_hexminerc_core_voltage;
+extern char *libhexc_set_config_voltage (char *arg);
+extern struct hexminerc_info **hexminerc_info;
+#endif /* USE_HEXMINERC */
+#endif /* HEXC_H */
--- cg_o/libhexc.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer/libhexc.c	2014-04-11 11:33:09.005309322 +0300
@@ -0,0 +1,433 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:20:34 */
+#define rotate(x, y)	((x << y) | (x >> (sizeof(x) * 8 - y)))
+#define rotr(x, y)		((x >> y) | (x << (sizeof(x) * 8 - y)))
+#define R(a, b, c, d, e, f, g, h, w, k) \
+		h = h + \
+		(rotate(e, 26) ^ rotate(e, 21) ^ rotate(e, 7)) + \
+		(g ^ (e & (f ^ g))) + \
+		k + \
+		w; \
+	d = d + h; \
+	h = h + (rotate(a, 30) ^ rotate(a, 19) ^ rotate(a, 10)) + ((a & b) | (c & (a | b)))
+extern const uint32_t SHA256_K[64];
+
+static bool
+libhexc_cachenonce (struct chip_resultsc *nonce_cache, uint32_t nonce)
+{
+  int i = 0;
+  while (i < HEXC_NONCE_CASH_SIZE && nonce_cache->nonces[i] != nonce)
+    i++;
+  if (i < HEXC_NONCE_CASH_SIZE)
+    return false;
+  //Rotate
+  if (nonce_cache->nonce_cache_write_pos == HEXC_NONCE_CASH_SIZE)
+    nonce_cache->nonce_cache_write_pos = 0;
+  nonce_cache->nonces[nonce_cache->nonce_cache_write_pos++] = nonce;
+  return true;
+}
+
+static void
+libhexc_generatenrange_new (unsigned char *buf, int asic_num)
+{
+  uint32_t nonceAdd;
+  int noncePos;
+  int64_t nonceCalc = 0x100000000ll;
+  nonceCalc /= asic_num;
+  nonceAdd = (uint32_t) nonceCalc;
+  uint32_t chip_noce;
+  for (noncePos = 0; noncePos < asic_num; noncePos++)
+    {
+      /*
+       * chip_noce = htole32(noncePos * nonceAdd);
+       */
+      chip_noce = noncePos * nonceAdd;
+      memcpy (buf + noncePos * 4, &chip_noce, 4);
+    }
+}
+
+char *
+libhexc_set_config_voltage (char *arg)
+{
+  int val1, ret;
+  ret = sscanf (arg, "%d", &val1);
+  if (ret < 1)
+    return "No values passed to hexminerc-voltage";
+  if (val1 < HEXC_MIN_COREMV || val1 > HEXC_MAX_COREMV)
+    return "Invalid value passed to hexminerc-voltage";
+  opt_hexminerc_core_voltage = val1;
+  return NULL;
+}
+
+/*
+    Thanks to BkkCoins & devileraser!
+ */
+
+static void
+libhexc_calc_hexminer (struct work *work, struct hexminerc_task *ht)
+{
+  uint32_t a0a1a2e0e1e2[6];
+  uint32_t A, B, C, D, E, F, G, H, T;
+  uint32_t state[8];
+  uint32_t data[3];
+  memcpy (&state, work->midstate, 32);
+  memcpy (&data, work->data + 64, 12);
+#if defined(__BIG_ENDIAN__) || defined(MIPSEB)
+  int i;
+  for (i = 0; i < 8; i++)
+    state[i] = htole32 (state[i]);
+  for (i = 0; i < 3; i++)
+    data[i] = htole32 (data[i]);
+#endif
+  A = state[0];
+  B = state[1];
+  C = state[2];
+  D = state[3];
+  E = state[4];
+  F = state[5];
+  G = state[6];
+  H = state[7];
+  R (A, B, C, D, E, F, G, H, data[0], SHA256_K[0]);
+  a0a1a2e0e1e2[0] = htole32 (H);
+  a0a1a2e0e1e2[3] = htole32 (D);
+  R (H, A, B, C, D, E, F, G, data[1], SHA256_K[1]);
+  a0a1a2e0e1e2[1] = htole32 (G);
+  a0a1a2e0e1e2[4] = htole32 (C);
+  R (G, H, A, B, C, D, E, F, data[2], SHA256_K[2]);
+  a0a1a2e0e1e2[2] = htole32 (F);
+  a0a1a2e0e1e2[5] = htole32 (B);
+  memcpy (&ht->a0, &a0a1a2e0e1e2[0], 4);
+  memcpy (&ht->a1, &a0a1a2e0e1e2[1], 4);
+  memcpy (&ht->a2, &a0a1a2e0e1e2[2], 4);
+  memcpy (&ht->e0, &a0a1a2e0e1e2[3], 4);
+  memcpy (&ht->e1, &a0a1a2e0e1e2[4], 4);
+  memcpy (&ht->e2, &a0a1a2e0e1e2[5], 4);
+}
+
+/*
+    From Hexminer core developer Thanks!
+ */
+
+static void
+libhexc_generateclk (uint16_t HashClock, uint16_t XCLKIN, uint32_t * res)
+{
+  uint32_t configL = 0;
+  uint32_t configH = 0;
+  int RValue = XCLKIN;
+  int NValue = (HashClock * 2 * RValue / XCLKIN);
+  configL =
+    ((uint32_t) RValue << 29) | ((uint32_t) NValue << 18) |
+    HEXC_CLOCK_LOW_CFG;
+  configH = ((uint32_t) RValue >> 3) | HEXC_CLOCK_HIGH_CFG;
+  res[0] = htole32 (configL);
+  res[1] = htole32 (configH);
+}
+
+static void
+libhexc_csum (unsigned char *startptr, unsigned char *endptr,
+              unsigned char *resptr)
+{
+  unsigned char *b = startptr;
+  uint8_t sum = 0;
+  while (b < endptr)
+    sum += *b++;
+  memcpy (resptr, &sum, 1);
+}
+
+static bool
+libhexc_get_options (int this_option_offset, int *asic_count, int *frequency)
+{
+  char buf[BUFSIZ + 1];
+  char *ptr, *comma, *colon, *colon2, *colon3, *colon4;
+  bool timeout_default;
+  size_t max;
+  int i, tmp;
+  if (opt_hexminerc_options == NULL)
+    buf[0] = '\0';
+  else
+    {
+      ptr = opt_hexminerc_options;
+      for (i = 0; i < this_option_offset; i++)
+        {
+          comma = strchr (ptr, ',');
+          if (comma == NULL)
+            break;
+          ptr = comma + 1;
+        }
+      comma = strchr (ptr, ',');
+      if (comma == NULL)
+        max = strlen (ptr);
+      else
+        max = comma - ptr;
+      if (max > BUFSIZ)
+        max = BUFSIZ;
+      strncpy (buf, ptr, max);
+      buf[max] = '\0';
+    }
+  if (!(*buf))
+    return false;
+  colon = strchr (buf, ':');
+  if (colon)
+    *(colon++) = '\0';
+  tmp = atoi (buf);
+  if (tmp > 0 && tmp <= HEXC_DEFAULT_ASIC_NUM)
+    *asic_count = tmp;
+  else
+    {
+      quit (1,
+            "Invalid hexminerc-options for " "asic_count (%s) must be 1 ~ %d",
+            buf, HEXC_DEFAULT_ASIC_NUM);
+    }
+  if (colon && *colon)
+    {
+      tmp = atoi (colon);
+      if (tmp < HEXC_MIN_FREQUENCY || tmp > HEXC_MAX_FREQUENCY)
+        {
+          quit
+            (1,
+             "Invalid hexminerc-options for frequency (%s) must be %d <= frequency <= %d",
+             colon, HEXC_MIN_FREQUENCY, HEXC_MAX_FREQUENCY);
+        }
+      *frequency = tmp;
+    }
+  return true;
+}
+static bool
+libhexc_usb_dead (struct cgpu_info *hexminerc)
+{
+  struct cg_usb_device *usbdev;
+  struct hexminerc_info *info = hexminerc->device_data;
+  
+  usbdev = hexminerc->usbdev;
+  bool ret = (usbdev == NULL
+          || usbdev->handle == NULL
+          || hexminerc->shutdown
+          || info->shut_read  || info->shut_write || info->shut_reset
+          || hexminerc->usbinfo.nodev || hexminerc->deven != DEV_ENABLED);
+  if(ret)        
+  	hexminerc->shutdown = true;
+  	
+  return ret;
+}
+
+static int
+libhexc_sendHashData (struct cgpu_info *hexminerc, unsigned char *sendbuf,
+                      size_t buf_len)
+{
+  struct hexminerc_info *info = hexminerc->device_data;
+  struct cg_usb_device *usbdev;
+  int wrote = 0, written = 0;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminerc->usbdev;
+  if (libhexc_usb_dead (hexminerc))
+    goto out;
+  while (written < buf_len && err == LIBUSB_SUCCESS)
+    {
+      err = libusb_bulk_transfer
+        (usbdev->handle,
+         0x02,
+         sendbuf + written,
+         MIN (HEXC_USB_WR_SIZE, buf_len - written), &wrote,
+         HEXC_USB_WR_TIME_OUT);
+      if (err == LIBUSB_SUCCESS)
+        written += wrote;
+    }
+out:
+  
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+  	info->shut_write = true; 
+  	
+  return written;
+}
+
+static void
+libhexc_reset (struct cgpu_info *hexminerc)
+{
+  struct hexminerc_info *info = hexminerc->device_data;
+  struct cg_usb_device *usbdev;
+  int err = LIBUSB_SUCCESS;
+  usbdev = hexminerc->usbdev;
+  if (libhexc_usb_dead (hexminerc))
+    goto out;
+  err = libusb_reset_device (usbdev->handle);
+out:
+
+	if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+	   info->shut_reset = true; 
+
+	info->usb_reset_count++;
+}
+
+static int libhexc_readHashData
+  (struct cgpu_info *hexminerc,
+   unsigned char *hash, int *hash_write_pos, int timeout, bool read_once)
+{
+  struct hexminerc_info *info = hexminerc->device_data;
+  struct cg_usb_device *usbdev;
+  int read = 0, total = 0;
+  int err = LIBUSB_SUCCESS;
+
+  usbdev = hexminerc->usbdev;
+  if (libhexc_usb_dead (hexminerc))
+    goto out;
+  while (*hash_write_pos + HEXC_USB_R_SIZE < HEXC_HASH_BUF_SIZE
+         && err == LIBUSB_SUCCESS)
+    {
+      err =
+        libusb_bulk_transfer (usbdev->handle, 0x82, hash + *hash_write_pos,
+                              HEXC_USB_R_SIZE, &read, timeout);
+      if (err == LIBUSB_SUCCESS)
+        {
+          *hash_write_pos += read;
+          total += read;
+        }
+      if (read_once)
+        break;
+    }
+out:
+
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    {
+      info->shut_read = true; 
+      cgsem_post (&info->qsem);    
+    }
+    
+  return err;
+}
+static int
+hexminerc_predecode_nonce (struct cgpu_info *hexminerc, struct thr_info *thr,
+                           uint32_t nonce, uint8_t work_id)
+{
+  struct hexminerc_info *info = hexminerc->device_data;
+  struct work *work_sub;
+
+ mutex_lock (&info->lock);
+  if(info->hexworks[work_id]->pool==NULL) {
+  	mutex_unlock (&info->lock);
+  	return 0;
+	}
+
+  work_sub = copy_work_noffset_fast_no_id (info->hexworks[work_id], 0);
+  mutex_unlock (&info->lock);
+ 
+  if (test_nonce (work_sub, nonce))
+    {
+      submit_tested_work_no_clone (thr, work_sub, true);
+      return 1;
+    }
+      free_work (work_sub);
+ 
+  return 0;
+}
+
+/*
+    From Hexminer core developer Thanks!
+ */
+
+static void
+libhexc_getvoltage (uint16_t wr_bukvoltage, int *info_pic_voltage_readings)
+{
+  float voltagehuman;
+  voltagehuman =
+    (float) ((float) wr_bukvoltage * (float) 1000 * (float) 3.3 /
+             ((1 << 12) - 1));
+  *info_pic_voltage_readings = (int) voltagehuman;
+}
+
+/*
+    From Hexminer core developer Thanks!
+ */
+
+static void
+libhexc_setvoltage (int info_voltage, uint16_t * refvoltage)
+{
+  uint16_t voltageadc;
+  voltageadc =
+    (uint16_t) ((float) info_voltage / (float) 1000 / (float) 3.3 *
+                ((1 << 12) - 1));
+  *refvoltage = htole16 (voltageadc);
+}
+
+static int
+libhexc_eatHashData (struct workc_result *wr, unsigned char *hash,
+                     int *hash_read_pos, int *hash_write_pos)
+{
+  uint8_t psum;
+  int wrpos;
+  unsigned char *csum_pos;
+  bool ok;
+eat:
+  while (*hash_read_pos < *hash_write_pos && hash[*hash_read_pos] != 0x53)
+    {
+      *hash_read_pos += 1;
+    }
+  if (*hash_write_pos - *hash_read_pos < HEXC_BASE_WORK_SIZE + 2)
+    return HEXC_BUF_SKIP;
+  memcpy ((char *) &wr->startbyte, &hash[*hash_read_pos],
+          HEXC_BASE_WORK_SIZE - 1);
+  wr->address = htole16 (wr->address);
+  /* Address is outside be strict to avoid mem corruption - not fancy but it works */
+  ok = (wr->command == 0x52) &&
+    ((wr->address == HEXC_WORKANSWER_ADR && wr->datalength == 0x06)
+     || (wr->address == HEXC_WORKANSWER_STAT_ADR && wr->datalength == 1));
+  if (!ok)
+    {
+      *hash_read_pos += 1;
+      goto eat;
+    }
+  if (*hash_write_pos - *hash_read_pos <
+      HEXC_BASE_WORK_SIZE + wr->datalength * 2)
+    return HEXC_BUF_SKIP;
+  csum_pos =
+    hash + *hash_read_pos + HEXC_BASE_WORK_SIZE + wr->datalength * 2 - 1;
+  //Crap?
+  if (csum_pos - hash < HEXC_HASH_BUF_SIZE)
+    {
+      //That was writing somewhere and corrupting memory because of faulty usb reads....
+      libhexc_csum (hash + *hash_read_pos, csum_pos, &psum);
+      if (psum != *csum_pos)
+        {
+          *hash_read_pos += 1;
+          return HEXC_BUF_ERR;
+        }
+    }
+  else
+    {
+#ifdef DBG_HEXC_BUF
+      applog (LOG_ERR,
+              "Lost Nonce/Status due to incomplete usb read?? wr->datalength = %i csum_pos=%i, *hash_write_pos%i, left=%i",
+              wr->datalength, csum_pos, *hash_write_pos,
+              HEXC_HASH_BUF_SIZE - *hash_write_pos);
+#endif
+      *hash_read_pos += 1;
+      return HEXC_BUF_ERR;
+    }
+  wrpos = (wr->address - HEXC_WORKANSWER_ADR) + HEXC_BASE_WORK_SIZE - 1;
+
+  memcpy
+    ((char *) &wr->startbyte + wrpos,
+     &hash[*hash_read_pos + HEXC_BASE_WORK_SIZE - 1], wr->datalength * 2);
+  *hash_read_pos += HEXC_BASE_WORK_SIZE + wr->datalength * 2;
+
+
+  return HEXC_BUF_DATA;
+
+
+}
+
+
+static void
+libhexc_set_word (struct cgpu_info *hexminerc, uint16_t address,
+                  uint16_t word)
+{
+  unsigned char status[10];
+  uint16_t wr_adr = htole16 (address);
+  uint16_t ledata = htole16 (word);
+  status[0] = 0x53;
+  status[1] = 0x01;
+  status[2] = 0x57;
+  memcpy (status + 3, &wr_adr, 2);
+  memcpy (status + 5, &ledata, 2);
+  libhexc_csum (status, status + 7, status + 7);
+  libhexc_sendHashData (hexminerc, status, 8);
+}
+
--- cg_o/driver-hexmineru.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer/driver-hexmineru.c	2014-04-11 11:33:18.853851446 +0300
@@ -0,0 +1,436 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:19:47 */
+/*
+ * Copyright 2013 Con Kolivas <kernel@kolivas.org> Copyright 2012-2013 Xiangfu
+ * <xiangfu@openmobilefree.com> Copyright 2012 Luke Dashjr Copyright 2012 Andrew
+ * Smith This program is free software;
+ * you can redistribute it and/or modify it under the terms of the GNU General
+ * Public License as published by the Free Software Foundation;
+ * either version 3 of the License, or (at your option) any later version. See
+ * COPYING for more details. Thank you guys!
+ */
+
+#include "config.h"
+#include <limits.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <ctype.h>
+#include <dirent.h>
+#include <unistd.h>
+#ifndef WIN32
+#include <sys/select.h>
+#include <termios.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#ifndef O_CLOEXEC
+#define O_CLOEXEC	0
+#endif
+#else
+#include "compat.h"
+#include <windows.h>
+#include <io.h>
+#endif
+#include "elist.h"
+#include "miner.h"
+#include "usbutils.h"
+#include "driver-hexmineru.h"
+#include "util.h"
+//static int option_offset = -1;
+extern struct work *copy_work_noffset_fast_no_id(struct work *base_work, int noffset);
+struct device_drv hexmineru_drv;
+#include "libhexu.c"
+#include "lib_mcp2210_hexu.c"
+extern unsigned int work_block;
+
+
+/*
+    We use a replacement algorithm to only remove references to work done from the buffer when we need the extra space
+    for new work. Thanks to Avalon code with some mods
+ */
+
+
+static inline void
+hexmineru_create_task (uint32_t * vec, struct hexmineru_task *ht,
+                       struct work *work)
+{
+  libhexu_work_to_bitfury_payload (ht, work);
+  libhexu_bitfury_payload_to_atrvec (vec, ht);
+}
+
+
+static struct cgpu_info *
+hexmineru_detect_one (libusb_device * dev, struct usb_find_devices *found)
+{
+
+  struct hexmineru_info *info;
+  struct cgpu_info *hexmineru;
+  unsigned char buf[1024];
+  unsigned char trash[1024];
+  uint64_t freq;
+  const uint8_t *osc6 = (unsigned char *) &freq;
+  int i = 0;
+
+  hexmineru = usb_alloc_cgpu (&hexmineru_drv, HEXU_MINER_THREADS);
+  if (!usb_init (hexmineru, dev, found))
+    {
+      usb_uninit (hexmineru);
+      return NULL;
+    }
+  hexmineru->device_data = calloc (sizeof (struct hexmineru_info), 1);
+
+  if (unlikely (!(hexmineru->device_data)))
+    {
+      hexmineru->device_data = NULL;
+      usb_uninit (hexmineru);
+      return NULL;
+    }
+
+  info = hexmineru->device_data;
+  info->hexworks = calloc (sizeof (struct work *), HEXMINERU_ARRAY_SIZE);
+  if (unlikely (!(info->hexworks)))
+    {
+      free (hexmineru->device_data);
+      hexmineru->device_data = NULL;
+      usb_uninit (hexmineru);
+      return NULL;
+    }
+  info->spipos = 0;
+  info->job_switch = true;
+  info->shut_read = false;
+  info->shut_write = false;
+  info->work = NULL;
+  info->c_job_id = 0;
+  info->l_job_id = 0;
+  info->array_nonce_cache = calloc (1, sizeof (struct chip_resultsu));
+  //bzero (info->array_nonce_cache, 1 * sizeof (struct chip_resultsu));
+  info->buf_switch = 0xffffffff;
+  info->spipos = 0;
+  info->read_pos = 0;
+  info->frequency = (uint8_t) HEXU_DEFAULT_FREQUENCY;
+  if (opt_hexmineru_options != NULL
+      && atoi (opt_hexmineru_options) > HEXU_MIN_FREQUENCY
+      && atoi (opt_hexmineru_options) < HEXU_MAX_FREQUENCY)
+    {
+      info->frequency = (uint8_t) atoi (opt_hexmineru_options);
+    }
+  if (!add_cgpu (hexmineru))
+    goto out;
+
+ // libhexu_reset (hexmineru);
+  if (!libhexu_mcp2210_get_configs (hexmineru))
+    goto out;
+  if (!hex_nanofury_checkport (hexmineru))
+    goto out;
+
+  freq = htole64 ((1ULL << info->frequency) - 1ULL);
+
+  libhexu_spi_emit_break (&info->spipos, (unsigned char *) buf);
+  libhexu_spi_emit_data (&info->spipos, (unsigned char *) buf, 0x6000, osc6, 8);      // Program internal on-die slow oscillator frequency 
+  libhexu_spi_send_conf (&info->spipos, (unsigned char *) buf);
+  libhexu_spi_send_init (&info->spipos, (unsigned char *) buf);
+  libhexu_nanofury_spi_reset (hexmineru);
+  if (!libhexu_nanofury_spi_txrx
+      (hexmineru, &info->spipos, (unsigned char *) buf, (unsigned char *) trash,
+       true))
+    goto out;
+    i = 0;
+      while (i < HEXMINERU_ARRAY_SIZE)
+    {
+      info->hexworks[i] = calloc (1, sizeof (struct work));
+      info->hexworks[i]->pool = NULL;
+      i++;
+    }  
+    info->spipos = 0;
+  
+  libhexu_spi_emit_break (&info->spipos, (unsigned char *) info->wr_spi);
+  
+  return hexmineru;
+
+out:
+  free (info->hexworks);
+  free (hexmineru->device_data);
+  hexmineru->device_data = NULL;
+  hexmineru = usb_free_cgpu (hexmineru);
+  usb_uninit (hexmineru);
+  return NULL;
+}
+
+static void
+hexmineru_detect (bool __maybe_unused hotplug)
+{
+  usb_detect (&hexmineru_drv, hexmineru_detect_one);
+}
+
+static void
+do_hexmineru_close (struct thr_info *thr)
+{
+  struct cgpu_info *hexmineru = thr->cgpu;
+  struct hexmineru_info *info = hexmineru->device_data;
+  int i = 0;
+
+	cgsleep_ms (300);
+  cgsem_destroy (&info->qsem);
+  
+  while (i < HEXMINERU_ARRAY_SIZE)
+    {
+      free_work (info->hexworks[i]);
+      i++;
+    }
+  free (info->hexworks);
+  free (info->array_nonce_cache);
+ // free (info->wr);
+  //usb_uninit(hexmineru);
+  //Hotplug fucks on full mem free :) 
+  //free (hexmineru->device_data);
+  //hexmineru->device_data = NULL;
+  //thr->cgpu = usb_free_cgpu(hexmineru);
+
+}
+
+static void
+hexmineru_shutdown (struct thr_info *thr)
+{
+  struct cgpu_info *hexmineru = thr->cgpu;
+  struct hexmineru_info *info = hexmineru->device_data;
+
+ cgsem_post (&info->qsem);
+
+  
+  do_hexmineru_close (thr);
+  
+  usb_nodev(hexmineru);
+}
+
+static bool
+hexmineru_thread_init (struct thr_info *thr)
+{
+	  struct cgpu_info *hexmineru = thr->cgpu;
+  struct hexmineru_info *info = hexmineru->device_data;
+ cgsem_init (&info->qsem);
+  return true;
+}
+
+static int64_t
+hexmineru_scanhash (struct thr_info *thr)
+{
+  struct cgpu_info *hexmineru = thr->cgpu;
+  struct hexmineru_info *info = hexmineru->device_data;
+  bool reset_work = false;
+  int64_t hash_count = 0;
+  if (libhexu_usb_dead (hexmineru))
+    {
+      return -1;
+    }
+    
+  
+  struct hexmineru_task ht;
+  uint32_t nonce;
+ 
+
+  int i, found, c_found;
+
+again:
+    if (!info->work)
+            {
+              info->roll = 0;
+              info->work = get_work (thr, thr->id);
+              info->work->ping = 1;
+							if(work_block != info->work_block) {
+  							reset_work = true;
+  							info->work_block = work_block;
+  						}
+            }
+      if (stale_work (info->work, false))
+        {
+          free_work (info->work);
+          info->work = NULL;
+          goto again;
+        }       
+            
+      if (info->job_switch || reset_work)
+        {
+          info->spipos = 1;
+          info->l_job_id = info->c_job_id;
+          info->c_job_id = info->read_pos;
+          free_work (info->hexworks[info->read_pos]);
+          info->hexworks[info->read_pos] = copy_work_noffset_fast_no_id (info->work, info->roll++);
+          hexmineru_create_task (&info->atrvecs[info->read_pos][0], &ht, info->hexworks[info->read_pos]);
+          memcpy (&info->atrvec[0], &info->atrvecs[info->read_pos][0], 76);
+          info->read_pos++;
+          if (info->read_pos >= HEXMINERU_ARRAY_SIZE_REAL)
+           info->read_pos = 0;
+          libhexu_spi_emit_data (&info->spipos, (unsigned char *) info->wr_spi, 0x3000,
+                                 &info->atrvec[0], 76);
+                                 
+             if (info->work->drv_rolllimit)
+                {
+                  info->work->drv_rolllimit--;
+                }
+              else
+                {
+                  free_work (info->work);
+                  info->work = NULL;
+                }
+        }
+      if (libhexu_nanofury_spi_txrx
+          (hexmineru, &info->spipos, (unsigned char *) info->wr_spi,
+           (unsigned char *) info->read_spi, false))
+        {
+          if (info->read_spi[17] == info->buf_switch)
+            {
+              info->job_switch = false;
+            }
+          else
+            {
+              info->job_switch = true;
+              info->buf_switch = info->read_spi[17];
+            }
+
+          //Skip first and last - only crap there 
+
+          found = 0;
+          
+          for (i = 1; i < 17; i++)
+            {
+              if (libhexu_cachenonce (&info->array_nonce_cache[0], info->read_spi[i]))
+                {
+          
+#if defined(__BIG_ENDIAN__) || defined(MIPSEB)
+                  nonce = libhexu_decnonce (htole32 (info->read_spi[i]));
+#else
+                  nonce = libhexu_decnonce (info->read_spi[i]);
+#endif
+                  c_found = 0;
+                  c_found +=
+                    hexmineru_predecode_nonce (hexmineru, thr, nonce,
+                                               info->c_job_id);
+                  if (c_found == 0 && info->c_job_id != info->l_job_id)
+                    c_found +=
+                      hexmineru_predecode_nonce (hexmineru, thr, nonce,
+                                                 info->l_job_id);
+
+                  found += c_found;
+                }
+              else
+                {
+                  
+                  info->dupe[0]++;
+                  
+                }
+            }
+
+          if (found > 0)
+            {
+              
+              hash_count += found;
+              
+            }
+          else
+            {
+              //Due to implementation there is no way for now to count them. 
+              //The number is inaccurate and too big!
+
+              // if (n_cache) inc_hw_errors (thr);
+            }
+
+        }
+      else
+        {
+          //applog (LOG_ERR, "WTF??");
+          //libhexu_reset (hexmineru);
+          //libhexu_nanofury_spi_reset (hexmineru);
+          //info->dev_reset_count++;
+          info->shut_read = true;
+          
+          
+
+        }
+      info->spipos = 80;
+       hash_count = (int64_t) (0xffffffffull * hash_count);
+        if (libhexu_usb_dead (hexmineru))
+      return -1;
+    
+   cgsem_mswait (&info->qsem, 40 );
+  return hash_count;
+}
+
+static void
+get_hexmineru_statline_before (char *buf, size_t bufsiz,
+                               struct cgpu_info *hexmineru)
+{
+	 if (!hexmineru->device_data)
+		return;
+  struct hexmineru_info *info = hexmineru->device_data;
+  tailsprintf (buf, bufsiz, "%3d %4d/%4dmV", info->frequency, 0, 0);
+}
+
+static struct api_data *
+hexmineru_api_stats (struct cgpu_info *cgpu)
+{
+
+  struct api_data *root = NULL;
+  struct hexmineru_info *info = cgpu->device_data;
+  if (!info)
+		return NULL;
+  uint64_t dh64, dr64;
+  double dev_runtime;
+  struct timeval now;
+  char displayed_hashes[16], displayed_rolling[16];
+  double hwp =
+    (cgpu->hw_errors +
+     cgpu->diff1) ? (double) (cgpu->hw_errors) / (double) (cgpu->hw_errors +
+                                                           cgpu->diff1) : 0;
+  if (cgpu->dev_start_tv.tv_sec == 0)
+    dev_runtime = total_secs;
+  else
+    {
+      cgtime (&now);
+      dev_runtime = tdiff (&now, &(cgpu->dev_start_tv));
+    }
+  if (dev_runtime < 1.0)
+    dev_runtime = 1.0;
+  dh64 = (double) cgpu->total_mhashes / dev_runtime * 1000000ull;
+  dr64 = (double) cgpu->rolling * 1000000ull;
+  suffix_string (dh64, displayed_hashes, sizeof (displayed_hashes), 4);
+  suffix_string (dr64, displayed_rolling, sizeof (displayed_rolling), 4);
+  root = api_add_string (root, "MHS 5s", displayed_rolling, true);
+  root = api_add_string (root, "MHS av", displayed_hashes, true);
+  root = api_add_int (root, "Hardware Errors", &(cgpu->hw_errors), true);
+  root = api_add_percent (root, "Hardware Errors%", &hwp, true);
+  root = api_add_int (root, "Reset Count", &(info->dev_reset_count), true);
+  root =
+    api_add_time (root, "Last Share Time", &(cgpu->last_share_pool_time),
+                  true);
+  root = api_add_uint8 (root, "Frequency", &(info->frequency), true);
+  char mcw[24];
+  sprintf (mcw, "Chip1 Dupes");
+  root = api_add_int (root, mcw, &(info->dupe[0]), true);
+
+  return root;
+}
+
+
+static void
+hexmineru_flush_work (struct cgpu_info *hexmineru)
+{
+  struct hexmineru_info *info = hexmineru->device_data;
+
+
+
+  cgsem_post (&info->qsem);
+
+}
+struct device_drv hexmineru_drv = {
+  .drv_id = DRIVER_hexmineru,
+  .dname = "hexmineru",
+  .name = "HEXu",
+  .drv_detect = hexmineru_detect,
+  .thread_init = hexmineru_thread_init,
+  .hash_work = hash_queued_work,
+  .scanwork = hexmineru_scanhash,
+  .flush_work = hexmineru_flush_work,
+  .get_api_stats = hexmineru_api_stats,
+  .get_statline_before = get_hexmineru_statline_before,
+  .thread_shutdown = hexmineru_shutdown,
+};
--- cg_o/driver-hexmineru.h	1970-01-01 02:00:00.000000000 +0200
+++ cgminer/driver-hexmineru.h	2014-04-11 11:33:18.857851691 +0300
@@ -0,0 +1,84 @@
+/*$T indentinput.h GC 1.140 10/16/13 10:20:01 */
+/*
+ * Copyright 2013 Avalon project Copyright 2013 Con Kolivas <kernel@kolivas.org>
+ * This program is free software;
+ * you can redistribute it and/or modify it under the terms of the GNU General
+ * Public License as published by the Free Software Foundation;
+ * either version 3 of the License, or (at your option) any later version. See
+ * COPYING for more details. Thank you guys!
+ */
+#ifndef HEXU_H
+#define HEXU_H
+#ifdef USE_HEXMINERU
+#include "util.h"
+enum mcp2210_gpio_value {
+	MGV_LOW,
+	MGV_HIGH,
+	MGV_ERROR,
+};
+#define NANOFURY_GP_PIN_LED 0
+#define NANOFURY_GP_PIN_SCK_OVR 5
+#define NANOFURY_GP_PIN_PWR_EN 6
+#define NANOFURY_MAX_BYTES_PER_SPI_TRANSFER 60			// due to MCP2210 limitation
+
+#define HEXMINERU_ARRAY_SIZE 9
+#define HEXMINERU_ARRAY_SIZE_REAL	HEXMINERU_ARRAY_SIZE - 2
+
+#define HEXU_NONCE_CASH_SIZE				256
+#define HEXMINERU_PUSH_THRESH		2       /* At least 2 queued works available to be written to PIC */
+#define HEXMINERU_ARRAY_MAX_POP		1
+#define HEXU_USB_R_SIZE					64
+#define HEXU_USB_WR_SIZE					64
+#define HEXU_HASH_BUF_SIZE				1024
+#define HEXU_MINER_THREADS			1
+#define HEXU_MIN_FREQUENCY			0       //Bits 
+#define HEXU_MAX_FREQUENCY			64     //Bits 
+#define HEXU_DEFAULT_FREQUENCY		54     //Bits Stable which works 2.5 GHs for 1 chip
+#define HEXU_DEFAULT_CORE_VOLTAGE	0     /* in millivolts */
+
+struct chip_resultsu
+{
+  uint8_t nonce_cache_write_pos;
+  uint32_t nonces[HEXU_NONCE_CASH_SIZE];
+};
+
+struct hexmineru_info
+{
+  uint8_t frequency;
+  uint8_t ltsz;
+  int dev_reset_count;
+  int dupe[1];
+  int  roll;
+  struct thr_info *thr;
+  struct work **hexworks;
+  unsigned char wr_spi[80];
+  uint32_t read_spi[256];
+  uint32_t atrvecs[HEXMINERU_ARRAY_SIZE][19];
+  struct chip_resultsu *array_nonce_cache;
+  uint32_t buf_switch;
+  size_t spipos;
+  uint32_t atrvec[19];
+  bool job_switch;
+  bool shut_read;
+  bool shut_write;
+  struct work *work;
+  unsigned int work_block;
+  int c_job_id;
+  int l_job_id;
+  int read_pos;
+  cgsem_t qsem;
+};
+
+struct hexmineru_task {
+	unsigned char midstate[32];
+	unsigned int junk[8];
+	unsigned m7;
+	unsigned ntime;
+	unsigned nbits;
+} __attribute__ ((packed, aligned (4)));
+
+#define HEXMINERU_TASK_SIZE	(sizeof(struct hexmineru_task))
+
+extern struct hexmineru_info **hexmineru_info;
+#endif /* USE_HEXMINERU */
+#endif /* HEXU_H */
--- cg_o/libhexu.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer/libhexu.c	2014-04-11 11:33:09.005309322 +0300
@@ -0,0 +1,255 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:20:34 */
+/*
+Special thanks to Luke Dashjr - Nanofory code was adopted from bfgminer - mcp2210.c
+*/
+
+#define FIRST_BASE 61
+#define SECOND_BASE 4
+static const int8_t bitfury_counters[16] = { 64, 64,
+  SECOND_BASE, SECOND_BASE + 4, SECOND_BASE + 2, SECOND_BASE + 2 + 16,
+  SECOND_BASE, SECOND_BASE + 1,
+  (FIRST_BASE) % 65, (FIRST_BASE + 1) % 65, (FIRST_BASE + 3) % 65,
+  (FIRST_BASE + 3 + 16) % 65, (FIRST_BASE + 4) % 65,
+  (FIRST_BASE + 4 + 4) % 65, (FIRST_BASE + 3 + 3) % 65,
+  (FIRST_BASE + 3 + 1 + 3) % 65
+};
+const uint32_t SHA_U[64] = {
+  0x428a2f98, 0x71374491, 0xb5c0fbcf
+};
+
+#define Ch(x, y, z) ((x & (y ^ z)) ^ z)
+#define Maj(x, y, z) ((x & (y | z)) | (y & z))
+#define ROTR(x, n) ((x >> n) | (x << (32 - n)))
+#define S0(x) (ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22))
+#define S1(x) (ROTR(x, 6) ^ ROTR(x, 11) ^ ROTR(x, 25))
+
+#define BT_OFFSETS_U 7
+
+static const uint32_t bf_offsetsu[] =
+  { -0x800000, 0, 0xffc00000, 0xff800000, 0x02800000, 0x02C00000,
+  0x00400000
+};
+
+static bool
+libhexu_usb_dead (struct cgpu_info *hexmineru)
+{
+  struct cg_usb_device *usbdev;
+  struct hexmineru_info *info = hexmineru->device_data;
+  
+  usbdev = hexmineru->usbdev;
+  bool ret = (usbdev == NULL
+          || usbdev->handle == NULL
+          || hexmineru->shutdown
+          || info->shut_read  || info->shut_write
+          || hexmineru->usbinfo.nodev || hexmineru->deven != DEV_ENABLED);
+  if(ret)        
+  	hexmineru->shutdown = true;
+  	
+  return ret;
+}
+
+
+static int
+libhexu_sendHashData (struct cgpu_info *hexmineru, unsigned char *sendbuf,
+                      size_t buf_len, int timeout)
+{
+
+  struct hexmineru_info *info = hexmineru->device_data;
+  struct cg_usb_device *usbdev;
+  int wrote = 0, written = 0;
+  int err = LIBUSB_SUCCESS;
+
+  usbdev = hexmineru->usbdev;
+  if (libhexu_usb_dead (hexmineru))
+    goto out;
+  while (written < buf_len && err == LIBUSB_SUCCESS)
+    {
+      err = libusb_interrupt_transfer
+        (usbdev->handle,
+         0x01,
+         sendbuf + written,
+         MIN (HEXU_USB_WR_SIZE, buf_len - written), &wrote, timeout);
+      if (err == LIBUSB_SUCCESS)
+        written += wrote;
+    }
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+  	info->shut_write = true; 
+	    
+  return written;
+
+}
+
+static int
+  libhexu_readHashData
+  (struct cgpu_info *hexmineru,
+   unsigned char *hash, int *hash_write_pos, int timeout, bool read_once)
+{
+  struct hexmineru_info *info = hexmineru->device_data;
+  struct cg_usb_device *usbdev;
+  int read = 0, total = 0;
+  int err = LIBUSB_SUCCESS;
+
+  usbdev = hexmineru->usbdev;
+  if (libhexu_usb_dead (hexmineru))
+    goto out;
+  while (*hash_write_pos + HEXU_USB_R_SIZE < HEXU_HASH_BUF_SIZE
+         && err == LIBUSB_SUCCESS)
+    {
+      err =
+        libusb_interrupt_transfer (usbdev->handle, 0x81,
+                                   hash + *hash_write_pos, HEXU_USB_R_SIZE,
+                                   &read, timeout);
+      if (err == LIBUSB_SUCCESS)
+        {
+          *hash_write_pos += read;
+          total += read;
+        }
+      if (read_once)
+        break;
+    }
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    {
+      info->shut_read = true;    
+    }
+  
+ return total;
+}
+
+static void
+libhexu_libbitfury_ms3_compute (unsigned *p)
+{
+  unsigned a, b, c, d, e, f, g, h, ne, na, i;
+//Buggy on init but who cares :)
+#if defined(__BIG_ENDIAN__) || defined(MIPSEB)
+  for (i = 0; i < 8; i++)
+    p[i] = htole32 (p[i]);
+#endif
+  a = p[0];
+  b = p[1];
+  c = p[2];
+  d = p[3];
+  e = p[4];
+  f = p[5];
+  g = p[6];
+  h = p[7];
+
+  for (i = 0; i < 3; i++)
+    {
+#if defined(__BIG_ENDIAN__) || defined(MIPSEB)
+      p[i + 16] = htole32 (p[i + 16]);
+#endif
+      ne = p[i + 16] + SHA_U[i] + h + Ch (e, f, g) + S1 (e) + d;
+      na =
+        p[i + 16] + SHA_U[i] + h + Ch (e, f, g) + S1 (e) + S0 (a) + Maj (a, b,
+                                                                         c);
+      d = c;
+      c = b;
+      b = a;
+      a = na;
+      h = g;
+      g = f;
+      f = e;
+      e = ne;
+    }
+  p[15] = a;
+  p[14] = b;
+  p[13] = c;
+  p[12] = d;
+  p[11] = e;
+  p[10] = f;
+  p[9] = g;
+  p[8] = h;
+
+
+#if defined(__BIG_ENDIAN__) || defined(MIPSEB)
+  for (i = 0; i < 19; i++)
+    p[i] = htole32 (p[i]);
+#endif
+}
+
+static void
+libhexu_work_to_bitfury_payload (struct hexmineru_task *p, struct work *w)
+{
+  //memset(p, 0, HEXMINERU_TASK_SIZE);
+  memcpy (&p->midstate[0], w->midstate, 32);
+  memcpy (&p->m7, w->data + 64, 12);
+}
+static void
+libhexu_bitfury_payload_to_atrvec (uint32_t * atrvec,
+                                   struct hexmineru_task *p)
+{
+/* Programming next value */
+
+  memcpy (atrvec, p, 76);
+  libhexu_libbitfury_ms3_compute (atrvec);
+}
+
+static bool
+libhexu_cachenonce (struct chip_resultsu *nonce_cache, uint32_t nonce)
+{
+  int i = 0;
+  while (i < HEXU_NONCE_CASH_SIZE && nonce_cache->nonces[i] != nonce)
+    i++;
+  if (i < HEXU_NONCE_CASH_SIZE)
+    return false;
+  //Rotate
+  if (nonce_cache->nonce_cache_write_pos == HEXU_NONCE_CASH_SIZE)
+    nonce_cache->nonce_cache_write_pos = 0;
+  nonce_cache->nonces[nonce_cache->nonce_cache_write_pos++] = nonce;
+  return true;
+}
+
+static uint32_t
+libhexu_decnonce (uint32_t in)
+{
+  uint32_t out;
+  /* First part load */
+  out = (in & 0xFF) << 24;
+  in >>= 8;
+  /* Byte reversal */
+  in = (((in & 0xaaaaaaaa) >> 1) | ((in & 0x55555555) << 1));
+  in = (((in & 0xcccccccc) >> 2) | ((in & 0x33333333) << 2));
+  in = (((in & 0xf0f0f0f0) >> 4) | ((in & 0x0f0f0f0f) << 4));
+  out |= (in >> 2) & 0x3FFFFF;
+  /* Extraction */
+  if (in & 1)
+    out |= (1 << 23);
+  if (in & 2)
+    out |= (1 << 22);
+  out -= 0x800004;
+  return out;
+}
+
+static int
+libhexu_bitfury_checkresults (struct thr_info *thr, struct work *work,
+                              uint32_t nonce)
+{
+  int i;
+  for (i = 0; i < BT_OFFSETS_U; i++)
+    {
+      if (test_nonce (work, nonce + bf_offsetsu[i]))
+        {
+          submit_tested_work_no_clone (thr, work, true);
+          return 1;
+        }
+    }
+  free_work (work);
+  return 0;
+}
+
+static int
+hexmineru_predecode_nonce (struct cgpu_info *hexmineru, struct thr_info *thr,
+                           uint32_t nonce, int work_id)
+{
+	//applog(LOG_ERR, "work_id %i",work_id);
+	//return 0;
+  struct hexmineru_info *info = hexmineru->device_data;
+  struct work *work_sub;
+  if(info->hexworks[work_id]->pool==NULL)
+  return 0;
+  //work_sub = copy_work (info->hexworks[work_id]);
+  work_sub = copy_work_noffset_fast_no_id (info->hexworks[work_id], 0);
+  return libhexu_bitfury_checkresults (thr, work_sub, nonce);
+}
--- cg_o/driver-hexminer8.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer/driver-hexminer8.c	2014-04-11 11:33:18.849851190 +0300
@@ -0,0 +1,780 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:19:47 */
+/*
+ * Copyright 2013 Con Kolivas <kernel@kolivas.org> Copyright 2012-2013 Xiangfu
+ * <xiangfu@openmobilefree.com> Copyright 2012 Luke Dashjr Copyright 2012 Andrew
+ * Smith This program is free software;
+ * you can redistribute it and/or modify it under the terms of the GNU General
+ * Public License as published by the Free Software Foundation;
+ * either version 3 of the License, or (at your option) any later version. See
+ * COPYING for more details. Thank you guys!
+ */
+#include "config.h"
+#include <limits.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <ctype.h>
+#include <dirent.h>
+#include <unistd.h>
+#ifndef WIN32
+#include <sys/select.h>
+#include <termios.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#ifndef O_CLOEXEC
+#define O_CLOEXEC	0
+#endif
+#else
+#include "compat.h"
+#include <windows.h>
+#include <io.h>
+#endif
+#include "elist.h"
+#include "miner.h"
+#include "usbutils.h"
+#include "driver-hexminer8.h"
+
+#include "util.h"
+extern unsigned int work_block;
+extern struct work *copy_work_noffset_fast_no_id (struct work *base_work,
+                                                  int noffset);
+static int option_offset = -1;
+struct device_drv hexminer8_drv;
+extern bool no_work;
+int opt_hexminer8_chip_mask = 0xFF;
+int opt_hexminer8_set_config_diff_to_one = 1;
+int opt_hexminer8_core_voltage = HEX8_DEFAULT_CORE_VOLTAGE;
+
+#include "libhex8.c"
+
+/*
+    We use a replacement algorithm to only remove references to work done from the buffer when we need the extra space
+    for new work. Thanks to Avalon code with some mods
+ */
+
+static void
+hexminer8_flush_work (struct cgpu_info *hexminer8)
+{
+  struct hexminer8_info *info = hexminer8->device_data;
+
+  cgsem_post (&info->wsem);
+#ifdef DBG_HEX8
+  applog (LOG_ERR, "HEX8 %i  hexminer8_flush_work !", hexminer8->device_id);
+#endif
+
+}
+
+static int
+hexminer8_send_task (struct hexminer8_task *ht, struct cgpu_info *hexminer8)
+{
+  int ret = 0;
+  size_t nr_len = HEXMINER8_TASK_SIZE;
+  struct hexminer8_info *info;
+  info = hexminer8->device_data;
+
+  libhex8_csum (&ht->startbyte, &ht->csum, &ht->csum);
+
+  ret = libhex8_sendHashData (hexminer8, &ht->startbyte, nr_len);
+
+  if (ret != nr_len)
+    {
+      libhex8_reset (hexminer8);
+      info->usb_w_errors++;
+      return -1;
+    }
+
+  return ret;
+}
+
+static inline void
+hexminer8_create_task (bool reset_work, struct hexminer8_task *ht,
+                       struct work *work, bool diff1,
+                       uint32_t * asic_difficulty, double *cached_diff)
+{
+  if (reset_work)
+    {
+      ht->status = htole16 ((uint16_t) HEX8_STAT_NEW_WORK_CLEAR_OLD);
+    }
+  else
+    {
+      ht->status = htole16 ((uint16_t) HEX8_STAT_NEW_WORK);
+    }
+  memcpy (ht->midstate, work->midstate, 32);
+  memcpy (ht->merkle, work->data + 64, 12);
+  ht->id = htole16 ((uint16_t) work->subid);
+  //Try to save some CPU cycles not fancy primary/backup scenarios... 
+  if (!diff1)
+    {
+      if (work->ping)
+        {
+          ht->difficulty = htole32 (0xFFFF001D);
+          return;
+        }
+      if (*cached_diff != work->work_difficulty)
+        {
+          *cached_diff = work->work_difficulty;
+#if defined(__BIG_ENDIAN__) || defined(MIPSEB)
+          *asic_difficulty = libhex8_get_target (work->work_difficulty);
+#else
+          *asic_difficulty =
+            be32toh (libhex8_get_target (work->work_difficulty));
+#endif
+        }
+      ht->difficulty = *asic_difficulty;
+    }
+
+}
+
+static inline void
+hexminer8_init_task_c (struct hexminer8_config_task *htc,
+                       struct hexminer8_info *info)
+{
+  htc->startbyte = 0x53;
+  htc->datalength =
+    (uint8_t) ((sizeof (struct hexminer8_config_task) - 6) / 2);
+  htc->command = 0x57;
+  htc->address = htole16 (0x30C0);
+  htc->hashclock = htole16 ((uint16_t) info->frequency);
+  libhex8_setvoltage (info->core_voltage, &htc->refvoltage);
+  htc->difficulty = htole32 (0xFFFF001D);
+  htc->chip_mask = (uint8_t) info->chip_mask;
+
+  libhex8_csum (&htc->startbyte, &htc->csum, &htc->csum);
+}
+
+static inline void
+hexminer8_init_task (struct hexminer8_task *ht, struct hexminer8_info *info)
+{
+  
+  ht->startbyte = 0x53;
+  ht->datalength = (uint8_t) ((HEXMINER8_TASK_SIZE - 6) / 2);
+  ht->command = 0x57;
+  ht->address = htole16 (0x3080);
+  ht->difficulty = htole32 (0xFFFF001D);
+}
+
+static bool
+need_reset (struct cgpu_info *hexminer8)
+{
+
+  struct hexminer8_info *info = hexminer8->device_data;
+
+  time_t now = time (NULL);
+  bool ret = false;
+  int i = 0;
+  int secs = 20;
+
+  if (!info->diff1)
+    secs = 60;
+  while (i < HEX8_DEFAULT_ASIC_NUM)
+    {
+      //Up to diff 1024 900 secs double
+      if (info->engines[i]
+          && (info->last_chip_valid_work[i] +
+              (int) (secs * 32 / info->engines[i]) < now))
+        {
+          //applog(LOG_ERR, "HEX8 %i Chip[%i] last valid work %i secs ago", hexminer8->device_id, i + 1, (int)(now-info->last_chip_valid_work[i]));
+          ret = true;
+          break;
+        }
+      i++;
+    }
+
+  if (ret || no_work)
+    {
+      ret = !no_work;
+      i = 0;
+      while (i < HEX8_DEFAULT_ASIC_NUM)
+        info->last_chip_valid_work[i++] = now;
+    }
+
+  return ret;
+}
+
+static void *
+hexminer8_send_tasks (void *userdata)
+{
+  struct cgpu_info *hexminer8 = (struct cgpu_info *) userdata;
+  struct hexminer8_info *info = hexminer8->device_data;
+  struct hexminer8_task *ht;
+  struct thr_info *thr = info->thr;
+  struct hexminer8_config_task *htc;
+  struct work *work = NULL;
+  struct work *tmpwork = NULL;
+  char threadname[24];
+  int write_pos = 0;
+  int jobs_to_send = 15;
+  int ping_period =
+    (int) (1000 / info->wsem_timing * 60 / info->asic_count / 14);
+  int ping_counter = 0;
+  int random_job = 0;
+  int send_jobs, roll, ret;
+  struct timeval tm;
+  unsigned int work_block_local;
+  double cached_diff = -1;
+  uint32_t asic_difficulty;
+  bool reset_work = true;
+  bool power = false;
+  snprintf (threadname, 24, "hex8_send/%d", hexminer8->device_id);
+  RenameThread (threadname);
+  htc = calloc (sizeof (struct hexminer8_config_task), 1);
+
+  hexminer8_init_task_c (htc, info);
+
+  ret =
+    libhex8_sendHashData (hexminer8, &htc->startbyte,
+                          sizeof (struct hexminer8_config_task));
+
+  if (ret != sizeof (struct hexminer8_config_task))
+    applog (LOG_ERR, "HEX8 %i Send config failed", hexminer8->device_id);
+  ht = calloc (sizeof (struct hexminer8_task), 1);
+  
+  hexminer8_init_task (ht, info);
+
+  while (!libhex8_usb_dead (hexminer8))
+    {
+      if (time (NULL) - info->power_checked > 30)
+        {
+
+          info->power_checked = time (NULL);
+          mutex_lock (&info->power);
+          power = need_reset (hexminer8);
+          mutex_unlock (&info->power);
+          if (power)
+            {
+              libhex8_set_word (hexminer8, 0x3080 + HEXMINER8_TASK_SIZE - 8,
+                                0x0004);
+              reset_work = true;
+              cgsleep_ms (200);
+            }
+        }
+      send_jobs = 0;
+
+
+      while ((work_block_local != work_block)
+             || (info->buf_empty_space > 30 && send_jobs < jobs_to_send)
+             || reset_work)
+        {
+        again:
+          if (!work)
+            {
+              roll = 0;
+              work = get_work (thr, thr->id);
+              work->ping = info->diff1;
+              if (work_block_local != work_block)
+                {
+                  reset_work = true;
+                  work_block_local = work_block;
+                }
+#ifdef DBG_HEX8
+              info->totworks++;
+#endif
+            }
+
+          if (stale_work (work, false))
+            {
+              free_work (work);
+              work = NULL;
+              goto again;
+            }
+
+          if (write_pos >= HEXMINER8_ARRAY_SIZE_REAL || reset_work)
+            write_pos = 0;
+
+          work->subid = write_pos;
+          tmpwork = copy_work_noffset_fast_no_id (work, roll++);
+          if (ping_counter == random_job)
+            tmpwork->ping = 1;
+          hexminer8_create_task (reset_work, ht,
+                                 tmpwork,
+                                 info->diff1, &asic_difficulty, &cached_diff);
+          mutex_lock (&info->lock);
+          free_work (info->hexworks[write_pos]);
+          info->hexworks[write_pos] = tmpwork;
+          mutex_unlock (&info->lock);
+
+          if (!info->diff1)
+            {
+              ping_counter++;
+              if (ping_counter == ping_period)
+                {
+                  ping_counter = 0;
+                  gettimeofday (&tm, NULL);
+                  srandom (tm.tv_sec + tm.tv_usec * 1000000ul);
+                  random_job = rand () % ping_period;
+                }
+            }
+          if (work->drv_rolllimit)
+            {
+              work->drv_rolllimit--;
+#ifdef DBG_HEX8
+              info->roled++;
+#endif
+            }
+          else
+            {
+              free_work (work);
+              work = NULL;
+            }
+
+#ifdef DBG_HEX8
+          if (reset_work)
+            applog (LOG_ERR, "HEX8 %i  Reset Work Task!",
+                    hexminer8->device_id);
+#endif
+
+
+          ret = hexminer8_send_task (ht, hexminer8);
+          write_pos++;
+          send_jobs++;
+          if (ret == HEXMINER8_TASK_SIZE && reset_work)
+            {
+              reset_work = false;
+              send_jobs-=4;
+            }
+        }
+      if (!reset_work)
+        cgsem_mswait (&info->wsem, info->wsem_timing);
+    }
+  if (work)
+    free_work (work);
+  free (ht);
+  free (htc);
+  pthread_exit (NULL);
+}
+
+static struct cgpu_info *
+hexminer8_detect_one (libusb_device * dev, struct usb_find_devices *found)
+{
+  int miner_count, asic_count, frequency;
+  int this_option_offset = ++option_offset;
+  struct hexminer8_info *info;
+  struct cgpu_info *hexminer8;
+
+  bool configured;
+  int i = 0;
+
+  hexminer8 = usb_alloc_cgpu (&hexminer8_drv, HEX8_MINER_THREADS);
+  if (!usb_init (hexminer8, dev, found))
+    {
+      usb_uninit (hexminer8);
+      return NULL;
+    }
+  hexminer8->device_data = calloc (sizeof (struct hexminer8_info), 1);
+
+  if (unlikely (!(hexminer8->device_data)))
+    {
+      hexminer8->device_data = NULL;
+      usb_uninit (hexminer8);
+      return NULL;
+    }
+  configured =
+    libhex8_get_options (this_option_offset, &asic_count, &frequency);
+  if (opt_hexminer8_core_voltage < HEX8_MIN_COREMV
+      || opt_hexminer8_core_voltage > HEX8_MAX_COREMV)
+    {
+
+      applog
+        (LOG_ERR,
+         "Invalid hexminer8-voltage %d must be %dmV - %dmV",
+         opt_hexminer8_core_voltage, HEX8_MIN_COREMV, HEX8_MAX_COREMV);
+      free (hexminer8->device_data);
+      hexminer8->device_data = NULL;
+      usb_uninit (hexminer8);
+      return NULL;
+    }
+  info = hexminer8->device_data;
+  info->hexworks = calloc (sizeof (struct work *), HEXMINER8_ARRAY_SIZE);
+  if (unlikely (!(info->hexworks)))
+    {
+      free (hexminer8->device_data);
+      hexminer8->device_data = NULL;
+      usb_uninit (hexminer8);
+      return NULL;
+    }
+
+  info->wr = (struct work8_result *) malloc (sizeof (struct work8_result));
+  info->array_nonce_cache = calloc (16, sizeof (struct chip_results8));
+  info->readbuf = calloc (HEX8_HASH_BUF_SIZE, sizeof (unsigned char));
+  
+  info->hash_read_pos = 0;
+  info->hash_write_pos = 0;
+  info->shut_read = false;
+  info->shut_write = false;
+  info->shut_reset = false;
+  info->miner_count = HEX8_DEFAULT_MINER_NUM;
+  info->asic_count = HEX8_DEFAULT_ASIC_NUM;
+  info->frequency = HEX8_DEFAULT_FREQUENCY;
+  info->pic_voltage_readings = HEX8_DEFAULT_CORE_VOLTAGE;
+  info->core_voltage = opt_hexminer8_core_voltage;
+  info->chip_mask = opt_hexminer8_chip_mask;
+  info->diff1 = (bool) opt_hexminer8_set_config_diff_to_one;
+  info->buf_empty_space = 63;
+  //info->dead_chip = false;
+
+  if (configured)
+    {
+      info->asic_count = asic_count;
+      info->frequency = frequency;
+    }
+
+  info->wsem_timing =
+    (int) (0x80000000ll / (info->asic_count * info->frequency * 4 * 32) /
+           1000 * 2);
+
+  if (!add_cgpu (hexminer8))
+    {
+      free (info->hexworks);
+      free (hexminer8->device_data);
+      hexminer8->device_data = NULL;
+      hexminer8 = usb_free_cgpu (hexminer8);
+      usb_uninit (hexminer8);
+      return NULL;
+    }
+
+  while (i < HEXMINER8_ARRAY_SIZE)
+    info->hexworks[i++] = calloc (1, sizeof (struct work));
+
+  i = 0;
+  info->power_checked = time (NULL);
+  while (i < HEX8_DEFAULT_ASIC_NUM)
+    {
+      info->engines[i] = 0;
+      info->last_chip_valid_work[i++] = time (NULL);
+    }
+
+  return hexminer8;
+}
+
+static void
+hexminer8_detect (bool __maybe_unused hotplug)
+{
+  usb_detect (&hexminer8_drv, hexminer8_detect_one);
+}
+
+static void
+do_hexminer8_close (struct thr_info *thr)
+{
+  struct cgpu_info *hexminer8 = thr->cgpu;
+  struct hexminer8_info *info = hexminer8->device_data;
+  int i = 0;
+  cgsleep_ms (300);
+
+  pthread_join (info->write_thr, NULL);
+#ifdef DBG_HEX8
+  pthread_join (info->dbg_thr, NULL);
+#endif
+
+  pthread_mutex_destroy (&info->lock);
+  pthread_mutex_destroy (&info->power);
+  cgsem_destroy (&info->wsem);
+
+
+  while (i < HEXMINER8_ARRAY_SIZE)
+    {
+      free_work (info->hexworks[i]);
+      i++;
+    }
+  free (info->hexworks);
+  free (info->readbuf);
+  free (info->array_nonce_cache);
+  free (info->wr);
+  //usb_uninit(hexminer8);
+  //Hotplug fucks on full mem free :) 
+  //free (hexminer8->device_data);
+  //hexminer8->device_data = NULL;
+  //thr->cgpu = usb_free_cgpu(hexminer8);
+
+}
+
+static void
+hexminer8_shutdown (struct thr_info *thr)
+{
+  struct cgpu_info *hexminer8 = thr->cgpu;
+  struct hexminer8_info *info = hexminer8->device_data;
+
+  cgsem_post (&info->wsem);
+
+  do_hexminer8_close (thr);
+
+  usb_nodev (hexminer8);
+}
+
+#ifdef DBG_HEX8
+static void *
+hexminer8_get_stats (void *userdata)
+{
+  struct cgpu_info *hexminer8 = (struct cgpu_info *) userdata;
+  struct hexminer8_info *info = hexminer8->device_data;
+  char threadname[24];
+  snprintf (threadname, 24, "hex8_dbg/%d", hexminer8->device_id);
+  RenameThread (threadname);
+  while (!libhex8_usb_dead (hexminer8))
+    {
+
+      cgsleep_ms (30 * 1000);
+
+      applog (LOG_ERR,
+              "HEX8 %i was_64 %i, was_above_60 %i was_zero %i, was_below_5 %i",
+              hexminer8->device_id, info->buf_empty_was_64,
+              info->buf_empty_was_above_60, info->buf_empty_was_zero,
+              info->buf_empty_was_below_5);
+
+      applog (LOG_ERR,
+              "HEX8 %i roled %i, getworks %i", hexminer8->device_id,
+              info->roled, info->totworks);
+
+
+      if (info->buf_empty_was_above_60 > 0)
+        {
+          mutex_lock (&info->lock);
+          info->buf_empty_was_64 = 0;
+          info->buf_empty_was_above_60 = 0;
+          mutex_unlock (&info->lock);
+        }
+
+      if (info->buf_empty_was_below_5 > 0)
+        {
+          mutex_lock (&info->lock);
+          info->buf_empty_was_below_5 = 0;
+          info->buf_empty_was_zero = 0;
+          mutex_unlock (&info->lock);
+        }
+    }
+  pthread_exit (NULL);
+}
+#endif
+
+
+
+static bool
+hexminer8_thread_init (struct thr_info *thr)
+{
+  struct cgpu_info *hexminer8 = thr->cgpu;
+  struct hexminer8_info *info = hexminer8->device_data;
+
+  info->thr = thr;
+
+  mutex_init (&info->lock);
+  mutex_init (&info->power);
+  cgsem_init (&info->wsem);
+
+  if (pthread_create
+      (&info->write_thr, NULL, hexminer8_send_tasks, (void *) hexminer8))
+    quit (1, "Failed to create hexminer8 write_thr");
+
+#ifdef DBG_HEX8
+  if (pthread_create
+      (&info->dbg_thr, NULL, hexminer8_get_stats, (void *) hexminer8))
+    quit (1, "Failed to create hexminer8 dbg_thr");
+#endif
+
+
+  return true;
+}
+
+static int64_t
+hexminer8_scanhash (struct thr_info *thr)
+{
+  struct cgpu_info *hexminer8 = thr->cgpu;
+  struct hexminer8_info *info = hexminer8->device_data;
+
+  uint32_t nonce;
+  double found;
+  double hash_count = 0;
+  int i = 0;
+  int ret_r = 0;
+  int64_t rethash_count = 0;
+
+  if (libhex8_usb_dead (hexminer8))
+    return -1;
+
+  if (info->hash_write_pos + HEX8_USB_R_SIZE >= HEX8_HASH_BUF_SIZE)
+    {
+      info->hash_write_pos = info->hash_write_pos - info->hash_read_pos;
+      memcpy (info->readbuf, info->readbuf + info->hash_read_pos,
+              info->hash_write_pos);
+      info->hash_read_pos = 0;
+    }
+  if (info->hash_write_pos - info->hash_read_pos > 7)
+    {
+    again:
+      ret_r =
+        libhex8_eatHashData (info->wr, info->readbuf, &info->hash_read_pos,
+                             &info->hash_write_pos);
+      if (ret_r > HEX8_BUF_DATA)
+        goto out;
+
+      info->buf_empty_space = info->wr->buf_empty_space;
+
+#ifdef DBG_HEX8
+      if (info->wr->buf_empty_space > 60)
+        {
+          mutex_lock (&info->lock);
+          if (info->wr->buf_empty_space == 64)
+            info->buf_empty_was_64++;
+          info->buf_empty_was_above_60++;
+          mutex_unlock (&info->lock);
+        }
+      if (info->wr->buf_empty_space < 5)
+        {
+          mutex_lock (&info->lock);
+          info->buf_empty_was_below_5++;
+          if (info->wr->buf_empty_space == 0)
+            info->buf_empty_was_zero++;
+          mutex_unlock (&info->lock);
+        }
+#endif
+
+
+      if (info->wr->datalength == 1)
+        goto done;
+
+      if (info->wr->lastnonceid > HEXMINER8_ARRAY_SIZE_REAL)
+        info->wr->lastnonceid = 0;
+
+      if (info->wr->lastchippos >= HEX8_DEFAULT_ASIC_NUM)
+        info->wr->lastchippos = 7;
+
+      if (libhex8_cachenonce
+          (&info->array_nonce_cache[info->wr->lastchippos],
+           info->wr->lastnonce))
+        {
+          nonce = htole32 (info->wr->lastnonce);
+
+          found = hexminer8_predecode_nonce (hexminer8, thr, nonce,
+                                             info->wr->lastnonceid,
+                                             info->diff1);
+
+          if (found > 0)
+            {
+              mutex_lock (&info->power);
+              info->engines[(uint8_t) info->wr->lastchippos] =
+                info->wr->good_engines;
+              info->last_chip_valid_work[(uint8_t) info->wr->lastchippos] =
+                time (NULL);
+              mutex_unlock (&info->power);
+              if (hash_count == 0)
+                libhex8_getvoltage (htole16 (info->wr->lastvoltage),
+                                    &info->pic_voltage_readings);
+
+              hash_count += found;
+              info->matching_work[info->wr->lastchippos]++;
+            }
+          else
+            {
+              inc_hw_errors_hex8 (thr, (int) found);
+            }
+        }
+      else
+        {
+          info->dupe[info->wr->lastchippos]++;
+        }
+    out:
+      if (ret_r == HEX8_BUF_ERR)
+        {
+          info->usb_r_errors++;
+        }
+    done:
+      if (info->hash_write_pos - info->hash_read_pos >= HEX8_MAX_WORK_SIZE)
+        goto again;
+    }
+
+  ret_r =
+    libhex8_readHashData (hexminer8, info->readbuf, &info->hash_write_pos,
+                          HEXMINER8_BULK_READ_TIMEOUT, true);
+
+  rethash_count = (0xffffffffull * (int64_t) hash_count);
+
+  if (libhex8_usb_dead (hexminer8))
+    return -1;
+
+  return rethash_count;
+}
+
+static void
+get_hexminer8_statline_before (char *buf, size_t bufsiz,
+                               struct cgpu_info *hexminer8)
+{
+  if (!hexminer8->device_data)
+    return;
+  struct hexminer8_info *info = hexminer8->device_data;
+  tailsprintf (buf, bufsiz, "%3d %4d/%4dmV", info->frequency,
+               info->core_voltage, info->pic_voltage_readings);
+}
+
+static struct api_data *
+hexminer8_api_stats (struct cgpu_info *cgpu)
+{
+
+  struct api_data *root = NULL;
+  struct hexminer8_info *info = cgpu->device_data;
+  if (!info)
+    return NULL;
+  uint64_t dh64, dr64;
+  double dev_runtime;
+  struct timeval now;
+  int i;
+  char displayed_hashes[16], displayed_rolling[16];
+  double hwp =
+    (cgpu->hw_errors +
+     cgpu->diff1) ? (double) (cgpu->hw_errors) / (double) (cgpu->hw_errors +
+                                                           cgpu->diff1) : 0;
+  if (cgpu->dev_start_tv.tv_sec == 0)
+    dev_runtime = total_secs;
+  else
+    {
+      cgtime (&now);
+      dev_runtime = tdiff (&now, &(cgpu->dev_start_tv));
+    }
+  if (dev_runtime < 1.0)
+    dev_runtime = 1.0;
+  dh64 = (double) cgpu->total_mhashes / dev_runtime * 1000000ull;
+  dr64 = (double) cgpu->rolling * 1000000ull;
+  suffix_string (dh64, displayed_hashes, sizeof (displayed_hashes), 4);
+  suffix_string (dr64, displayed_rolling, sizeof (displayed_rolling), 4);
+  root = api_add_string (root, "MHS 5s", displayed_rolling, true);
+  root = api_add_string (root, "MHS av", displayed_hashes, true);
+  root = api_add_int (root, "Hardware Errors", &(cgpu->hw_errors), true);
+  root = api_add_percent (root, "Hardware Errors%", &hwp, true);
+  root = api_add_int (root, "USB Read Errors", &(info->usb_r_errors), true);
+  root = api_add_int (root, "USB Write Errors", &(info->usb_w_errors), true);
+  root =
+    api_add_int (root, "USB Reset Count", &(info->usb_reset_count), true);
+  root =
+    api_add_time (root, "Last Share Time", &(cgpu->last_share_pool_time),
+                  true);
+  root = api_add_int (root, "Chip Count", &(info->asic_count), true);
+  root = api_add_int (root, "Frequency", &(info->frequency), true);
+  root = api_add_int (root, "Core Voltage", &(info->core_voltage), true);
+  root =
+    api_add_int (root, "PIC Voltage Readings", &(info->pic_voltage_readings),
+                 true);
+  for (i = 0; i < info->asic_count; i++)
+    {
+      char mcw[24];
+      sprintf (mcw, "Chip%d Nonces", i + 1);
+      root = api_add_int (root, mcw, &(info->matching_work[i]), true);
+      sprintf (mcw, "Chip%d Engines", i + 1);
+      root = api_add_int (root, mcw, &(info->engines[i]), true);
+      sprintf (mcw, "Chip%d Dupes", i + 1);
+      root = api_add_int (root, mcw, &(info->dupe[i]), true);
+    }
+
+  return root;
+}
+
+struct device_drv hexminer8_drv = {
+  .drv_id = DRIVER_hexminer8,
+  .dname = "hexminer8",
+  .name = "HEX8",
+  .drv_detect = hexminer8_detect,
+  .thread_init = hexminer8_thread_init,
+  .hash_work = hash_queued_work,
+  .scanwork = hexminer8_scanhash,
+  .flush_work = hexminer8_flush_work,
+  .get_api_stats = hexminer8_api_stats,
+  .get_statline_before = get_hexminer8_statline_before,
+  .thread_shutdown = hexminer8_shutdown,
+};
--- cg_o/driver-hexminer8.h	1970-01-01 02:00:00.000000000 +0200
+++ cgminer/driver-hexminer8.h	2014-04-11 11:33:18.849851190 +0300
@@ -0,0 +1,167 @@
+/*$T indentinput.h GC 1.140 10/16/13 10:20:01 */
+/*
+ * Copyright 2013 Avalon project Copyright 2013 Con Kolivas <kernel@kolivas.org>
+ * This program is free software;
+ * you can redistribute it and/or modify it under the terms of the GNU General
+ * Public License as published by the Free Software Foundation;
+ * either version 3 of the License, or (at your option) any later version. See
+ * COPYING for more details. Thank you guys!
+ */
+#ifndef HEX8_H
+#define HEX8_H
+#ifdef USE_HEXMINER8
+#include "util.h"
+/* hexminer8_task/work_reply status Definitions: */
+//#define DBG_HEX8
+
+#define HEX8_STAT_IDLE					0       /* Idle or data already Sent to the buffer */
+#define HEX8_STAT_NEW_WORK				1       /* Request for write in the buffer */
+#define HEX8_STAT_WAITING				2       /* Wait For Buffer Empty Position */
+#define HEX8_STAT_CLR_BUFF				3       /* Force Buffer Empty */
+#define HEX8_STAT_STOP_REQ				4       /* Stop Request */
+#define HEX8_STAT_NEW_WORK_CLEAR_OLD		5       /* Clear Buffers and after that fill the first buffer */
+#define HEX8_STAT_UNUSED					6
+/* libhex8_eatHashData/BUF_reply status Definitions: */
+#define HEX8_BUF_DATA 0
+#define HEX8_BUF_ERR  1
+#define HEX8_BUF_SKIP 2
+
+#define HEXMINER8_ARRAY_PIC_SIZE		64
+#define HEXMINER8_ARRAY_SIZE                  HEXMINER8_ARRAY_PIC_SIZE * 4
+#define HEXMINER8_ARRAY_SIZE_REAL	HEXMINER8_ARRAY_SIZE - 2
+
+#define HEX8_NONCE_CASH_SIZE				1
+
+#define HEX8_USB_R_SIZE					64
+#define HEX8_USB_WR_SIZE					64
+#define HEX8_HASH_BUF_SIZE				2048*4
+
+#define HEXMINER8_BULK_READ_TIMEOUT 1000
+#define HEX8_USB_WR_TIME_OUT				500
+
+#define HEX8_MINER_THREADS			1
+#define HEX8_DEFAULT_MINER_NUM		0x01
+#define HEX8_DEFAULT_ASIC_NUM		0x08
+#define HEX8_MIN_FREQUENCY			0
+#define HEX8_MAX_FREQUENCY			511
+#define HEX8_DEFAULT_FREQUENCY		200
+#define HEX8_DEFAULT_CORE_VOLTAGE	800     /* in millivolts */
+#define HEX8_MIN_COREMV				300     /* in millivolts */
+#define HEX8_MAX_COREMV	2101    /* in millivolts */
+struct chip_results8
+{
+  uint8_t nonce_cache_write_pos;
+  uint32_t nonces[HEX8_NONCE_CASH_SIZE];
+};
+
+struct work8_result
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint32_t lastnonce;           //1x32
+  uint8_t lastnonceid;          //1x32
+  uint8_t status;
+  uint16_t lastvoltage;         //1x32
+  uint8_t lastchippos;          //1x32
+  uint8_t buf_empty_space;      //16 bit words aligned with lastchippos
+  uint8_t good_engines;
+  uint8_t dum;                  //7
+  uint8_t csum;
+  uint8_t pad[2];
+} __attribute__ ((packed, aligned (4)));
+
+struct hexminer8_info
+{
+  bool shut_read;
+  bool shut_write;
+  bool shut_reset;
+  bool diff1;
+  int wsem_timing;
+  int chip_mask;
+  int miner_count;
+  int asic_count;
+  int core_voltage;
+  int frequency;
+  int usb_r_errors;
+  int usb_w_errors;
+  int usb_reset_count;
+  int pic_voltage_readings;
+  int hash_read_pos;
+  int hash_write_pos;
+  int dupe[HEX8_DEFAULT_ASIC_NUM];
+  int matching_work[HEX8_DEFAULT_ASIC_NUM];
+  int engines[HEX8_DEFAULT_ASIC_NUM];
+  uint8_t wr_lastnonceid;
+  uint8_t buf_empty_space;
+  unsigned char *readbuf;
+  struct work8_result *wr;
+  struct chip_results8 *array_nonce_cache;
+  struct thr_info *thr;
+  struct work **hexworks;
+  time_t last_chip_valid_work[HEX8_DEFAULT_ASIC_NUM];
+  time_t power_checked;
+  pthread_t write_thr;
+  pthread_mutex_t lock;
+  pthread_mutex_t power;
+  cgsem_t wsem;
+
+#ifdef DBG_HEX8
+  pthread_t dbg_thr;
+  int roled;
+  int totworks;
+  int read_pos;
+  int buf_empty_was_64;
+  int buf_empty_was_above_60;
+  int buf_empty_was_below_5;
+  int buf_empty_was_zero;
+#endif
+
+};
+
+struct hexminer8_task
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint8_t midstate[32];         //8x32
+  uint32_t merkle[3];           //3x32
+  uint32_t difficulty;          //1x32
+  uint16_t id;
+  uint16_t status;              //1x32
+  uint8_t csum;                 //1x32
+  uint8_t pad[2];               //1x32
+} __attribute__ ((packed, aligned (4)));
+
+struct hexminer8_config_task
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint16_t hashclock;           //1x32
+  uint16_t refvoltage;
+  uint32_t difficulty;          //1x32
+  uint8_t chip_mask;
+  uint8_t wr_interwal;
+  uint8_t csum;                 //1x32
+} __attribute__ ((packed, aligned (4)));
+
+#define HEX8_WORKANSWER_ADR	0x3000
+#define HEXMINER8_TASK_SIZE	(sizeof(struct hexminer8_task)-2)
+#define HEX8_MAX_WORK_SIZE		(sizeof(struct work8_result)-2)
+#define HEX8_BASE_WORK_SIZE		6
+
+extern int opt_hexminer8_core_voltage;
+extern int opt_hexminer8_chip_mask;
+extern int opt_hexminer8_set_config_diff_to_one;
+
+extern char *libhex8_set_config_voltage (char *arg);
+extern char *libhex8_set_config_chip_mask (char *arg);
+extern char *libhex8_set_config_diff_to_one (char *arg);
+
+extern struct hexminer8_info **hexminer8_info;
+#endif /* USE_HEXMINER8 */
+#endif /* HEX8_H */
--- cg_o/libhex3.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer/libhex3.c	2014-04-11 11:33:08.941305701 +0300
@@ -0,0 +1,433 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:20:34 */
+#define rotate(x, y)	((x << y) | (x >> (sizeof(x) * 8 - y)))
+#define rotr(x, y)		((x >> y) | (x << (sizeof(x) * 8 - y)))
+#define R(a, b, c, d, e, f, g, h, w, k) \
+		h = h + \
+		(rotate(e, 26) ^ rotate(e, 21) ^ rotate(e, 7)) + \
+		(g ^ (e & (f ^ g))) + \
+		k + \
+		w; \
+	d = d + h; \
+	h = h + (rotate(a, 30) ^ rotate(a, 19) ^ rotate(a, 10)) + ((a & b) | (c & (a | b)))
+extern const uint32_t SHA256_K[64];
+
+static bool
+libhex3_cachenonce (struct chip_results3 *nonce_cache, uint32_t nonce)
+{
+  int i = 0;
+  while (i < HEX3_NONCE_CASH_SIZE && nonce_cache->nonces[i] != nonce)
+    i++;
+  if (i < HEX3_NONCE_CASH_SIZE)
+    return false;
+  //Rotate
+  if (nonce_cache->nonce_cache_write_pos == HEX3_NONCE_CASH_SIZE)
+    nonce_cache->nonce_cache_write_pos = 0;
+  nonce_cache->nonces[nonce_cache->nonce_cache_write_pos++] = nonce;
+  return true;
+}
+
+char *
+libhex3_set_config_voltage (char *arg)
+{
+  int val1, ret;
+  ret = sscanf (arg, "%d", &val1);
+  if (ret < 1)
+    return "No values passed to hexminer3-voltage";
+  if (val1 < HEX3_MIN_COREMV || val1 > HEX3_MAX_COREMV)
+    return "Invalid value passed to hexminer3-voltage";
+  opt_hexminer3_core_voltage = val1;
+  return NULL;
+}
+
+/*
+    Thanks to BkkCoins & devileraser!
+ */
+
+static void
+libhex3_calc_hexminer (struct work *work, struct hexminer3_task *ht)
+{
+  uint32_t a0a1a2e0e1e2[6];
+  uint32_t A, B, C, D, E, F, G, H, T;
+  uint32_t state[8];
+  uint32_t data[3];
+  memcpy (&state, work->midstate, 32);
+  memcpy (&data, work->data + 64, 12);
+#if defined(__BIG_ENDIAN__) || defined(MIPSEB)
+  int i;
+  for (i = 0; i < 8; i++)
+    state[i] = htole32 (state[i]);
+  for (i = 0; i < 3; i++)
+    data[i] = htole32 (data[i]);
+#endif
+  A = state[0];
+  B = state[1];
+  C = state[2];
+  D = state[3];
+  E = state[4];
+  F = state[5];
+  G = state[6];
+  H = state[7];
+  R (A, B, C, D, E, F, G, H, data[0], SHA256_K[0]);
+  a0a1a2e0e1e2[0] = htole32 (H);
+  a0a1a2e0e1e2[3] = htole32 (D);
+  R (H, A, B, C, D, E, F, G, data[1], SHA256_K[1]);
+  a0a1a2e0e1e2[1] = htole32 (G);
+  a0a1a2e0e1e2[4] = htole32 (C);
+  R (G, H, A, B, C, D, E, F, data[2], SHA256_K[2]);
+  a0a1a2e0e1e2[2] = htole32 (F);
+  a0a1a2e0e1e2[5] = htole32 (B);
+  memcpy (&ht->a0, &a0a1a2e0e1e2[0], 4);
+  memcpy (&ht->a1, &a0a1a2e0e1e2[1], 4);
+  memcpy (&ht->a2, &a0a1a2e0e1e2[2], 4);
+  memcpy (&ht->e0, &a0a1a2e0e1e2[3], 4);
+  memcpy (&ht->e1, &a0a1a2e0e1e2[4], 4);
+  memcpy (&ht->e2, &a0a1a2e0e1e2[5], 4);
+}
+
+
+char *
+libhex3_set_config_chip_mask (char *arg)
+{
+  int val1, ret;
+  ret = sscanf (arg, "%d", &val1);
+  if (ret < 1)
+    return "No values passed to hexminer3-chip-mask";
+  opt_hexminer3_chip_mask = val1;
+  return NULL;
+}
+
+static void
+libhex3_csum (unsigned char *startptr, unsigned char *endptr,
+              unsigned char *resptr)
+{
+  unsigned char *b = startptr;
+  uint8_t sum = 0;
+  while (b < endptr)
+    sum += *b++;
+  memcpy (resptr, &sum, 1);
+}
+
+static bool
+libhex3_get_options (int this_option_offset, int *asic_count, int *frequency)
+{
+  char buf[BUFSIZ + 1];
+  char *ptr, *comma, *colon, *colon2, *colon3, *colon4;
+  bool timeout_default;
+  size_t max;
+  int i, tmp;
+  if (opt_hexminer3_options == NULL)
+    buf[0] = '\0';
+  else
+    {
+      ptr = opt_hexminer3_options;
+      for (i = 0; i < this_option_offset; i++)
+        {
+          comma = strchr (ptr, ',');
+          if (comma == NULL)
+            break;
+          ptr = comma + 1;
+        }
+      comma = strchr (ptr, ',');
+      if (comma == NULL)
+        max = strlen (ptr);
+      else
+        max = comma - ptr;
+      if (max > BUFSIZ)
+        max = BUFSIZ;
+      strncpy (buf, ptr, max);
+      buf[max] = '\0';
+    }
+  if (!(*buf))
+    return false;
+  colon = strchr (buf, ':');
+  if (colon)
+    *(colon++) = '\0';
+  tmp = atoi (buf);
+  if (tmp > 0 && tmp <= HEX3_DEFAULT_ASIC_NUM)
+    *asic_count = tmp;
+  else
+    {
+      quit (1,
+            "Invalid hexminer3-options for " "asic_count (%s) must be 1 ~ %d",
+            buf, HEX3_DEFAULT_ASIC_NUM);
+    }
+  if (colon && *colon)
+    {
+      tmp = atoi (colon);
+      if (tmp < HEX3_MIN_FREQUENCY || tmp > HEX3_MAX_FREQUENCY)
+        {
+          quit
+            (1,
+             "Invalid hexminer3-options for frequency (%s) must be %d <= frequency <= %d",
+             colon, HEX3_MIN_FREQUENCY, HEX3_MAX_FREQUENCY);
+        }
+      *frequency = tmp;
+    }
+  return true;
+}
+
+static bool
+libhex3_usb_dead (struct cgpu_info *hexminer3)
+{
+  struct cg_usb_device *usbdev;
+  struct hexminer3_info *info = hexminer3->device_data;
+
+  usbdev = hexminer3->usbdev;
+  bool ret = (usbdev == NULL
+              || usbdev->handle == NULL
+              || hexminer3->shutdown
+              || info->shut_read || info->shut_write || info->shut_reset
+              || hexminer3->usbinfo.nodev || hexminer3->deven != DEV_ENABLED);
+  if (ret)
+    hexminer3->shutdown = true;
+
+  return ret;
+}
+
+static int
+libhex3_sendHashData (struct cgpu_info *hexminer3, unsigned char *sendbuf,
+                      size_t buf_len)
+{
+  struct hexminer3_info *info = hexminer3->device_data;
+  struct cg_usb_device *usbdev;
+  int wrote = 0, written = 0;
+  int err = LIBUSB_SUCCESS;
+
+  usbdev = hexminer3->usbdev;
+  if (libhex3_usb_dead (hexminer3))
+    goto out;
+  while (written < buf_len && err == LIBUSB_SUCCESS)
+    {
+      err = libusb_bulk_transfer
+        (usbdev->handle,
+         0x02,
+         sendbuf + written,
+         MIN (HEX3_USB_WR_SIZE, buf_len - written), &wrote,
+         HEX3_USB_WR_TIME_OUT);
+      if (err == LIBUSB_SUCCESS)
+        written += wrote;
+    }
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_write = true;
+
+  return written;
+}
+
+static void
+libhex3_reset (struct cgpu_info *hexminer3)
+{
+
+  struct hexminer3_info *info = hexminer3->device_data;
+  struct cg_usb_device *usbdev;
+  int err = LIBUSB_SUCCESS;
+
+  usbdev = hexminer3->usbdev;
+  if (libhex3_usb_dead (hexminer3))
+    goto out;
+  err = libusb_reset_device (usbdev->handle);
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_reset = true;
+
+  info->usb_reset_count++;
+}
+
+static int libhex3_readHashData
+  (struct cgpu_info *hexminer3,
+   unsigned char *hash, int *hash_write_pos, int timeout, bool read_once)
+{
+  struct hexminer3_info *info = hexminer3->device_data;
+  struct cg_usb_device *usbdev;
+  int read = 0, total = 0;
+  int err = LIBUSB_SUCCESS;
+
+  usbdev = hexminer3->usbdev;
+  if (libhex3_usb_dead (hexminer3))
+    goto out;
+  while (*hash_write_pos + HEX3_USB_R_SIZE < HEX3_HASH_BUF_SIZE
+         && err == LIBUSB_SUCCESS)
+    {
+      err =
+        libusb_bulk_transfer (usbdev->handle, 0x82, hash + *hash_write_pos,
+                              HEX3_USB_R_SIZE, &read, timeout);
+      if (err == LIBUSB_SUCCESS)
+        {
+          *hash_write_pos += read;
+          total += read;
+        }
+      if (read_once)
+        break;
+    }
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    {
+      info->shut_read = true;
+      cgsem_post (&info->wsem);
+    }
+
+  return err;
+}
+
+static double
+hexminer3_predecode_nonce (struct cgpu_info *hexminer3, struct thr_info *thr,
+                           uint32_t nonce, uint8_t work_id)
+{
+  struct hexminer3_info *info = hexminer3->device_data;
+  struct work *work_sub;
+  mutex_lock (&info->lock);
+  if (info->hexworks[work_id]->pool == NULL)
+    {
+      mutex_unlock (&info->lock);
+      return 0;
+    }
+
+  work_sub = copy_work_noffset_fast_no_id (info->hexworks[work_id], 0);
+  mutex_unlock (&info->lock);
+
+
+
+  if (test_nonce (work_sub, nonce))
+    {
+      //work_sub->device_diff = diff1;
+      submit_tested_work_no_clone (thr, work_sub, 1);
+      return 1;
+    }
+  free_work (work_sub);
+  return 0;
+}
+
+static void
+libhex3_getvoltage (uint16_t wr_bukvoltage, int *info_pic_voltage_readings)
+{
+  float voltagehuman;
+  voltagehuman =
+    (float) ((float) wr_bukvoltage * (float) 3300 / (float) ((1 << 12) - 1));
+  *info_pic_voltage_readings = (int) voltagehuman;
+}
+
+static void
+libhex3_setvoltage (int info_voltage, uint16_t * refvoltage)
+{
+  uint16_t voltageadc;
+  voltageadc =
+    (uint16_t) ((float) info_voltage / (float) 1000 / (float) 3.3 *
+                ((1 << 12) - 1));
+  *refvoltage = htole16 (voltageadc);
+}
+
+static void
+libhex3_generatenrange_new (unsigned char *buf, int asic_num)
+{
+  uint32_t nonceAdd;
+  int noncePos;
+  int64_t nonceCalc = 0x100000000ll;
+  nonceCalc /= asic_num;
+  nonceAdd = (uint32_t) nonceCalc;
+  uint32_t chip_noce;
+  for (noncePos = 0; noncePos < asic_num; noncePos++)
+    {
+      /*
+       * chip_noce = htole32(noncePos * nonceAdd);
+       */
+      chip_noce = noncePos * nonceAdd;
+      memcpy (buf + noncePos * 4, &chip_noce, 4);
+    }
+}
+
+static int
+libhex3_eatHashData (struct work3_result *wr, unsigned char *hash,
+                     int *hash_read_pos, int *hash_write_pos)
+{
+  uint8_t psum;
+  int wrpos;
+  unsigned char *csum_pos;
+  bool ok;
+eat:
+  while (*hash_read_pos < *hash_write_pos && hash[*hash_read_pos] != 0x53)
+    {
+#ifdef DBG_HEX3
+      //  applog (LOG_ERR, "%x", hash[*hash_read_pos]);
+#endif
+
+      *hash_read_pos += 1;
+    }
+  if (*hash_write_pos - *hash_read_pos < 8)
+    return HEX3_BUF_SKIP;
+  memcpy ((char *) &wr->startbyte, &hash[*hash_read_pos],
+          HEX3_BASE_WORK_SIZE - 1);
+  wr->address = htole16 (wr->address);
+  /* Address is outside be strict to avoid mem corruption - not fancy but it works */
+
+  //applog(LOG_ERR,"wr->address= %x, wr->command = %x, wr->datalength=%x",wr->address,wr->command,wr->datalength);
+#ifdef DBG_HEX3
+  ok = (wr->command == 0x52) &&
+    ((wr->address == HEX3_WORKANSWER_ADR && wr->datalength == 0x05)
+     || (wr->address == 0x3008 && wr->datalength == 1)
+     || (wr->address == 0x300C && wr->datalength == 4));
+#else
+  ok = (wr->command == 0x52) &&
+    ((wr->address == HEX3_WORKANSWER_ADR && wr->datalength == 0x05)
+     || (wr->address == 0x3008 && wr->datalength == 1));
+#endif
+  if (!ok)
+    {
+#ifdef DBG_HEX3
+      //applog (LOG_ERR, "%x", hash[*hash_read_pos]);
+#endif
+      *hash_read_pos += 1;
+      goto eat;
+    }
+  if (*hash_write_pos - *hash_read_pos <
+      HEX3_BASE_WORK_SIZE + wr->datalength * 2)
+    return HEX3_BUF_SKIP;
+  csum_pos =
+    hash + *hash_read_pos + HEX3_BASE_WORK_SIZE + wr->datalength * 2 - 1;
+  //Crap?
+  if (csum_pos - hash < HEX3_HASH_BUF_SIZE)
+    {
+//That was writing somewhere and corrupting memory because of faulty usb reads....
+      libhex3_csum (hash + *hash_read_pos, csum_pos, &psum);
+      if (psum != *csum_pos)
+        {
+#ifdef DBG_HEX3
+          //applog (LOG_ERR, "%x", hash[*hash_read_pos]);
+#endif
+          *hash_read_pos += 1;
+          return HEX3_BUF_ERR;
+        }
+    }
+  else
+    {
+#ifdef DBG_HEX3
+      //applog (LOG_ERR, "%x", hash[*hash_read_pos]);
+#endif
+      *hash_read_pos += 1;
+      return HEX3_BUF_ERR;
+    }
+  wrpos = (wr->address - HEX3_WORKANSWER_ADR) + HEX3_BASE_WORK_SIZE - 1;
+  memcpy
+    ((char *) &wr->startbyte + wrpos,
+     &hash[*hash_read_pos + HEX3_BASE_WORK_SIZE - 1], wr->datalength * 2);
+  *hash_read_pos += HEX3_BASE_WORK_SIZE + wr->datalength * 2;
+
+
+  return HEX3_BUF_DATA;
+}
+
+
+static void
+libhex3_set_word (struct cgpu_info *hexminer3, uint16_t address,
+                  uint16_t word)
+{
+  unsigned char status[10];
+  uint16_t wr_adr = htole16 (address);
+  uint16_t ledata = htole16 (word);
+  status[0] = 0x53;
+  status[1] = 0x01;
+  status[2] = 0x57;
+  memcpy (status + 3, &wr_adr, 2);
+  memcpy (status + 5, &ledata, 2);
+  libhex3_csum (status, status + 7, status + 7);
+  libhex3_sendHashData (hexminer3, status, 8);
+}
--- cg_o/driver-hexminer3.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer/driver-hexminer3.c	2014-04-11 11:33:18.825850034 +0300
@@ -0,0 +1,805 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:19:47 */
+/*
+ * Copyright 2013 Con Kolivas <kernel@kolivas.org> Copyright 2012-2013 Xiangfu
+ * <xiangfu@openmobilefree.com> Copyright 2012 Luke Dashjr Copyright 2012 Andrew
+ * Smith This program is free software;
+ * you can redistribute it and/or modify it under the terms of the GNU General
+ * Public License as published by the Free Software Foundation;
+ * either version 3 of the License, or (at your option) any later version. See
+ * COPYING for more details. Thank you guys!
+ */
+#include "config.h"
+#include <limits.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <ctype.h>
+#include <dirent.h>
+#include <unistd.h>
+#ifndef WIN32
+#include <sys/select.h>
+#include <termios.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#ifndef O_CLOEXEC
+#define O_CLOEXEC	0
+#endif
+#else
+#include "compat.h"
+#include <windows.h>
+#include <io.h>
+#endif
+#include "elist.h"
+#include "miner.h"
+#include "usbutils.h"
+#include "driver-hexminer3.h"
+
+#include "util.h"
+extern unsigned int work_block;
+extern struct work *copy_work_noffset_fast_no_id (struct work *base_work,
+                                                  int noffset);
+static int option_offset = -1;
+struct device_drv hexminer3_drv;
+extern bool no_work;
+int opt_hexminer3_chip_mask = 0xFF;
+//int opt_hexminer3_set_config_diff_to_one = 1;
+int opt_hexminer3_core_voltage = HEX3_DEFAULT_CORE_VOLTAGE;
+
+#include "libhex3.c"
+
+/*
+    We use a replacement algorithm to only remove references to work done from the buffer when we need the extra space
+    for new work. Thanks to Avalon code with some mods
+ */
+
+static void
+hexminer3_flush_work (struct cgpu_info *hexminer3)
+{
+  struct hexminer3_info *info = hexminer3->device_data;
+
+  cgsem_post (&info->wsem);
+#ifdef DBG_HEX3
+  applog (LOG_ERR, "HEX3 %i  hexminer3_flush_work !", hexminer3->device_id);
+#endif
+
+}
+
+static int
+hexminer3_send_task (struct hexminer3_task *ht, struct cgpu_info *hexminer3)
+{
+  int ret = 0;
+  size_t nr_len = HEXMINER3_TASK_SIZE;
+  struct hexminer3_info *info;
+  info = hexminer3->device_data;
+
+  libhex3_csum (&ht->startbyte, &ht->csum, &ht->csum);
+
+  ret = libhex3_sendHashData (hexminer3, &ht->startbyte, nr_len);
+
+  if (ret != nr_len)
+    {
+      libhex3_reset (hexminer3);
+      info->usb_w_errors++;
+      return -1;
+    }
+
+  return ret;
+}
+
+static inline void
+hexminer3_create_task (bool reset_work, struct hexminer3_task *ht,
+                       struct work *work)
+{
+  if (reset_work)
+    {
+      ht->status = HEX3_STAT_NEW_WORK_CLEAR_OLD;
+    }
+  else
+    {
+      ht->status = HEX3_STAT_NEW_WORK;
+    }
+  memcpy (ht->midstate, work->midstate, 32);
+  memcpy (ht->merkle, work->data + 64, 12);
+  ht->id = (uint8_t) work->subid;
+  libhex3_calc_hexminer (work, ht);
+
+}
+
+static inline void
+hexminer3_init_task_c (struct hexminer3_config_task *htc,
+                       struct hexminer3_info *info)
+{
+  htc->startbyte = 0x53;
+  htc->datalength =
+    (uint8_t) ((sizeof (struct hexminer3_config_task) - 6 - 2) / 2);
+  htc->command = 0x57;
+  htc->address = htole16 (0x30C0);
+  htc->hashclock = htole16 ((uint16_t) info->frequency);
+
+  libhex3_setvoltage (info->core_voltage, &htc->refvoltage);
+  htc->chip_mask = (uint8_t) info->chip_mask;
+  htc->chipcount = htole16 (info->asic_count);
+  libhex3_csum (&htc->startbyte, &htc->csum, &htc->csum);
+}
+
+static inline void
+hexminer3_init_task (struct hexminer3_task *ht, struct hexminer3_info *info)
+{
+  ht->startbyte = 0x53;
+  ht->datalength = (uint8_t) ((HEXMINER3_TASK_SIZE - 6) / 2);
+  ht->command = 0x57;
+  ht->address = htole16 (0x3080);
+
+}
+
+#ifdef PWR_HEX3
+static bool
+need_reset (struct cgpu_info *hexminer3)
+{
+
+  struct hexminer3_info *info = hexminer3->device_data;
+
+  time_t now = time (NULL);
+  bool ret = false;
+  int i = 0;
+  int secs = 20;
+
+
+  while (i < HEX3_DEFAULT_ASIC_NUM)
+    {
+
+      if ((info->last_chip_valid_work[i] + secs < now))
+        {
+#ifdef DBG_HEX3
+          applog (LOG_ERR, "HEX3 %i Chip[%i] last valid work %i secs ago",
+                  hexminer3->device_id, i + 1,
+                  (int) (now - info->last_chip_valid_work[i]));
+#endif
+          ret = true;
+          break;
+        }
+      i++;
+    }
+
+  if (ret || no_work)
+    {
+      ret = !no_work;
+      i = 0;
+      while (i < HEX3_DEFAULT_ASIC_NUM)
+        info->last_chip_valid_work[i++] = now;
+    }
+
+  return ret;
+}
+#endif
+
+static void *
+hexminer3_send_tasks (void *userdata)
+{
+  struct cgpu_info *hexminer3 = (struct cgpu_info *) userdata;
+  struct hexminer3_info *info = hexminer3->device_data;
+  struct hexminer3_task *ht;
+  struct thr_info *thr = info->thr;
+  struct hexminer3_config_task *htc;
+  struct work *work = NULL;
+  struct work *tmpwork = NULL;
+  char threadname[24];
+  int write_pos = 0;
+  int jobs_to_send = 2;
+
+  int send_jobs, roll, ret;
+  struct timeval tm;
+  unsigned int work_block_local;
+
+  bool reset_work = true;
+  bool power = false;
+  snprintf (threadname, 24, "hex3_send/%d", hexminer3->device_id);
+  RenameThread (threadname);
+  htc = calloc (sizeof (struct hexminer3_config_task), 1);
+
+  hexminer3_init_task_c (htc, info);
+  //Wait for asic reset
+  cgsleep_ms (100);
+
+  ret =
+    libhex3_sendHashData (hexminer3, &htc->startbyte,
+                          sizeof (struct hexminer3_config_task) - 2);
+
+  if (ret != sizeof (struct hexminer3_config_task) - 2)
+    applog (LOG_ERR, "HEX3 %i Send config failed", hexminer3->device_id);
+
+  ht = calloc (sizeof (struct hexminer3_task), 1);
+  hexminer3_init_task (ht, info);
+
+  while (!libhex3_usb_dead (hexminer3))
+    {
+#ifdef PWR_HEX3
+      if (time (NULL) - info->power_checked > 30)
+        {
+
+          info->power_checked = time (NULL);
+          mutex_lock (&info->power);
+          power = need_reset (hexminer3);
+          mutex_unlock (&info->power);
+          if (power)
+            {
+#ifdef DBG_HEX3
+              applog (LOG_ERR, "hex3 %i RES", hexminer3->device_id);
+#endif
+#ifndef DBG_HEX3
+              libhex3_set_word (hexminer3, 0x3080 + HEXMINER3_TASK_SIZE - 8,
+                                0x0004);
+#endif
+              reset_work = true;
+              cgsleep_ms (200);
+            }
+        }
+#endif
+      send_jobs = 0;
+
+
+      while ((work_block_local != work_block)
+             || (info->buf_empty_space > 30 && send_jobs < jobs_to_send)
+             || reset_work)
+        {
+        again:
+          if (!work)
+            {
+              roll = 0;
+              work = get_work (thr, thr->id);
+              work->ping = 1;
+              if (work_block_local != work_block)
+                {
+                  reset_work = true;
+                  work_block_local = work_block;
+                }
+            }
+
+          if (stale_work (work, false))
+            {
+              free_work (work);
+              work = NULL;
+              goto again;
+            }
+
+          if (write_pos >= HEXMINER3_ARRAY_SIZE_REAL || reset_work)
+            write_pos = 0;
+
+          work->subid = write_pos;
+          tmpwork = copy_work_noffset_fast_no_id (work, roll++);
+#ifdef DBG_HEX3
+          info->send_j++;
+#endif
+          hexminer3_create_task (reset_work, ht, tmpwork);
+          mutex_lock (&info->lock);
+          free_work (info->hexworks[write_pos]);
+          info->hexworks[write_pos] = tmpwork;
+          mutex_unlock (&info->lock);
+
+          if (work->drv_rolllimit)
+            {
+              work->drv_rolllimit--;
+#ifdef DBG_HEX3
+              info->roled++;
+#endif
+            }
+          else
+            {
+              free_work (work);
+              work = NULL;
+            }
+
+#ifdef DBG_HEX3
+          if (reset_work)
+            applog (LOG_ERR, "HEX3 %i  Reset Work Task!",
+                    hexminer3->device_id);
+#endif
+          ret = hexminer3_send_task (ht, hexminer3);
+          write_pos++;
+          send_jobs++;
+          if (ret == HEXMINER3_TASK_SIZE && reset_work)
+            {
+              reset_work = false;
+              send_jobs -= 4;
+            }
+        }
+      if (!reset_work)
+        cgsem_mswait (&info->wsem, info->wsem_timing);
+    }
+  if (work)
+    free_work (work);
+  free (ht);
+  free (htc);
+  pthread_exit (NULL);
+}
+
+static struct cgpu_info *
+hexminer3_detect_one (libusb_device * dev, struct usb_find_devices *found)
+{
+  int miner_count, asic_count, frequency;
+  int this_option_offset = ++option_offset;
+  struct hexminer3_info *info;
+  struct cgpu_info *hexminer3;
+
+  bool configured;
+  int i = 0;
+
+  hexminer3 = usb_alloc_cgpu (&hexminer3_drv, HEX3_MINER_THREADS);
+  if (!usb_init (hexminer3, dev, found))
+    {
+      usb_uninit (hexminer3);
+      return NULL;
+    }
+  hexminer3->device_data = calloc (sizeof (struct hexminer3_info), 1);
+
+  if (unlikely (!(hexminer3->device_data)))
+    {
+      hexminer3->device_data = NULL;
+      usb_uninit (hexminer3);
+      return NULL;
+    }
+  configured =
+    libhex3_get_options (this_option_offset, &asic_count, &frequency);
+  if (opt_hexminer3_core_voltage < HEX3_MIN_COREMV
+      || opt_hexminer3_core_voltage > HEX3_MAX_COREMV)
+    {
+
+      applog
+        (LOG_ERR,
+         "Invalid hexminer3-voltage %d must be %dmV - %dmV",
+         opt_hexminer3_core_voltage, HEX3_MIN_COREMV, HEX3_MAX_COREMV);
+      free (hexminer3->device_data);
+      hexminer3->device_data = NULL;
+      usb_uninit (hexminer3);
+      return NULL;
+    }
+  info = hexminer3->device_data;
+  info->hexworks = calloc (sizeof (struct work *), HEXMINER3_ARRAY_SIZE);
+  if (unlikely (!(info->hexworks)))
+    {
+      free (hexminer3->device_data);
+      hexminer3->device_data = NULL;
+      usb_uninit (hexminer3);
+      return NULL;
+    }
+
+  info->wr = (struct work3_result *) malloc (sizeof (struct work3_result));
+  info->array_nonce_cache = calloc (16, sizeof (struct chip_results3));
+  info->readbuf = calloc (HEX3_HASH_BUF_SIZE, sizeof (unsigned char));
+
+
+  info->hash_read_pos = 0;
+  info->hash_write_pos = 0;
+  info->shut_read = false;
+  info->shut_write = false;
+  info->shut_reset = false;
+  info->miner_count = HEX3_DEFAULT_MINER_NUM;
+  info->asic_count = HEX3_DEFAULT_ASIC_NUM;
+  info->frequency = HEX3_DEFAULT_FREQUENCY;
+  info->pic_voltage_readings = HEX3_DEFAULT_CORE_VOLTAGE;
+  info->core_voltage = opt_hexminer3_core_voltage;
+  info->chip_mask = opt_hexminer3_chip_mask;
+  info->buf_empty_space = 63;
+
+  if (configured)
+    {
+      info->asic_count = asic_count;
+      info->frequency = frequency;
+    }
+
+  info->wsem_timing =
+    (int) (0x80000000ll / (info->asic_count * info->frequency) /
+           1000 * 2 * 0.93);
+
+  if (!add_cgpu (hexminer3))
+    {
+      free (info->hexworks);
+      free (hexminer3->device_data);
+      hexminer3->device_data = NULL;
+      hexminer3 = usb_free_cgpu (hexminer3);
+      usb_uninit (hexminer3);
+      return NULL;
+    }
+
+  while (i < HEXMINER3_ARRAY_SIZE)
+    info->hexworks[i++] = calloc (1, sizeof (struct work));
+
+  i = 0;
+  info->power_checked = time (NULL);
+  while (i < HEX3_DEFAULT_ASIC_NUM)
+    {
+      info->last_chip_valid_work[i++] = time (NULL);
+    }
+  libhex3_generatenrange_new ((unsigned char *) &info->nonces_range,
+                              info->asic_count);
+  return hexminer3;
+}
+
+static void
+hexminer3_detect (bool __maybe_unused hotplug)
+{
+  usb_detect (&hexminer3_drv, hexminer3_detect_one);
+}
+
+static void
+do_hexminer3_close (struct thr_info *thr)
+{
+  struct cgpu_info *hexminer3 = thr->cgpu;
+  struct hexminer3_info *info = hexminer3->device_data;
+  int i = 0;
+  cgsleep_ms (300);
+
+  pthread_join (info->write_thr, NULL);
+#ifdef DBG_HEX3
+  pthread_join (info->dbg_thr, NULL);
+#endif
+
+  pthread_mutex_destroy (&info->lock);
+#ifdef PWR_HEX3
+  pthread_mutex_destroy (&info->power);
+#endif
+  cgsem_destroy (&info->wsem);
+
+
+  while (i < HEXMINER3_ARRAY_SIZE)
+    {
+      free_work (info->hexworks[i]);
+      i++;
+    }
+  free (info->hexworks);
+  free (info->readbuf);
+  free (info->array_nonce_cache);
+  free (info->wr);
+  //usb_uninit(hexminer3);
+  //Hotplug fucks on full mem free :) 
+  //free (hexminer3->device_data);
+  //hexminer3->device_data = NULL;
+  //thr->cgpu = usb_free_cgpu(hexminer3);
+
+}
+
+static void
+hexminer3_shutdown (struct thr_info *thr)
+{
+  struct cgpu_info *hexminer3 = thr->cgpu;
+  struct hexminer3_info *info = hexminer3->device_data;
+
+  cgsem_post (&info->wsem);
+
+  do_hexminer3_close (thr);
+
+  usb_nodev (hexminer3);
+}
+
+#ifdef DBG_HEX3
+static void *
+hexminer3_get_stats (void *userdata)
+{
+  struct cgpu_info *hexminer3 = (struct cgpu_info *) userdata;
+  struct hexminer3_info *info = hexminer3->device_data;
+  char threadname[24];
+  snprintf (threadname, 24, "hex3_dbg/%d", hexminer3->device_id);
+  RenameThread (threadname);
+  while (!libhex3_usb_dead (hexminer3))
+    {
+
+      cgsleep_ms (30 * 1000);
+
+      applog (LOG_ERR,
+              "HEX3 %i was_64 %i, was_above_60 %i was_zero %i, was_below_5 %i",
+              hexminer3->device_id, info->buf_empty_was_64,
+              info->buf_empty_was_above_60, info->buf_empty_was_zero,
+              info->buf_empty_was_below_5);
+
+      applog (LOG_ERR,
+              "HEX3 %i PIC received jobs %i, PIC sent nonces %i",
+              hexminer3->device_id, info->word1, info->word2);
+
+      applog (LOG_ERR,
+              "HEX3 %i CGM sent jobs %i, CGM received nonces %i",
+              hexminer3->device_id, info->send_j, info->r_j);
+
+
+      if (info->buf_empty_was_above_60 > 0)
+        {
+          mutex_lock (&info->lock);
+          info->buf_empty_was_64 = 0;
+          info->buf_empty_was_above_60 = 0;
+          mutex_unlock (&info->lock);
+        }
+
+      if (info->buf_empty_was_below_5 > 0)
+        {
+          mutex_lock (&info->lock);
+          info->buf_empty_was_below_5 = 0;
+          info->buf_empty_was_zero = 0;
+          mutex_unlock (&info->lock);
+        }
+    }
+  pthread_exit (NULL);
+}
+#endif
+
+static bool
+hexminer3_thread_init (struct thr_info *thr)
+{
+  struct cgpu_info *hexminer3 = thr->cgpu;
+  struct hexminer3_info *info = hexminer3->device_data;
+
+  info->thr = thr;
+
+  mutex_init (&info->lock);
+#ifdef PWR_HEX3
+  mutex_init (&info->power);
+#endif
+  cgsem_init (&info->wsem);
+
+  if (pthread_create
+      (&info->write_thr, NULL, hexminer3_send_tasks, (void *) hexminer3))
+    quit (1, "Failed to create hexminer3 write_thr");
+
+#ifdef DBG_HEX3
+  if (pthread_create
+      (&info->dbg_thr, NULL, hexminer3_get_stats, (void *) hexminer3))
+    quit (1, "Failed to create hexminer3 dbg_thr");
+#endif
+
+
+  return true;
+}
+
+static int64_t
+hexminer3_scanhash (struct thr_info *thr)
+{
+  struct cgpu_info *hexminer3 = thr->cgpu;
+  struct hexminer3_info *info = hexminer3->device_data;
+
+  uint32_t nonce;
+  double found;
+  double hash_count = 0;
+  int i = 0, lastchippos;
+  int ret_r = 0;
+  int64_t rethash_count = 0;
+
+  if (libhex3_usb_dead (hexminer3))
+    return -1;
+
+  if (info->hash_write_pos + HEX3_USB_R_SIZE >= HEX3_HASH_BUF_SIZE)
+    {
+      info->hash_write_pos = info->hash_write_pos - info->hash_read_pos;
+      memcpy (info->readbuf, info->readbuf + info->hash_read_pos,
+              info->hash_write_pos);
+      info->hash_read_pos = 0;
+    }
+  if (info->hash_write_pos - info->hash_read_pos > 7)
+    {
+    again:
+      ret_r =
+        libhex3_eatHashData (info->wr, info->readbuf, &info->hash_read_pos,
+                             &info->hash_write_pos);
+      if (ret_r > HEX3_BUF_DATA)
+        goto out;
+#ifdef DBG_HEX3
+      if (info->wr->address == 0x300C)
+        {
+          info->word1 = htole32 (info->wr->word1);
+          info->word2 = htole32 (info->wr->word2);
+          goto out;
+        }
+#endif
+      info->buf_empty_space = info->wr->buf_empty_space;
+
+#ifdef DBG_HEX3
+      if (info->wr->buf_empty_space > 60)
+        {
+          mutex_lock (&info->lock);
+          if (info->wr->buf_empty_space == 64)
+            info->buf_empty_was_64++;
+          info->buf_empty_was_above_60++;
+          mutex_unlock (&info->lock);
+        }
+      if (info->wr->buf_empty_space < 5)
+        {
+          mutex_lock (&info->lock);
+          info->buf_empty_was_below_5++;
+          if (info->wr->buf_empty_space == 0)
+            info->buf_empty_was_zero++;
+          mutex_unlock (&info->lock);
+        }
+#endif
+
+
+      if (info->wr->datalength == 1)
+        goto done;
+#ifdef DBG_HEX3
+      info->r_j++;
+#endif
+      if (info->wr->lastnonceid > HEXMINER3_ARRAY_SIZE_REAL)
+        info->wr->lastnonceid = 0;
+
+      nonce = htole32 (info->wr->lastnonce);
+      i = 0;
+      while (i < info->asic_count)
+        {
+          if (nonce < info->nonces_range[++i])
+            {
+              lastchippos = --i;
+              break;
+            }
+        }
+
+      if (i == info->asic_count)
+        lastchippos = info->asic_count - 1;
+
+      if (libhex3_cachenonce
+          (&info->array_nonce_cache[lastchippos], info->wr->lastnonce))
+        {
+
+          found = hexminer3_predecode_nonce (hexminer3, thr, nonce,
+                                             info->wr->lastnonceid);
+
+          if (found > 0)
+            {
+#ifdef PWR_HEX3
+              mutex_lock (&info->power);
+
+              info->last_chip_valid_work[(uint8_t) lastchippos] = time (NULL);
+              mutex_unlock (&info->power);
+#endif
+              if (hash_count == 0)
+                libhex3_getvoltage (htole16 (info->wr->lastvoltage),
+                                    &info->pic_voltage_readings);
+
+              hash_count += found;
+              info->matching_work[(uint8_t) lastchippos]++;
+            }
+          else
+            {
+              inc_hw_errors (thr);
+            }
+        }
+      else
+        {
+          info->dupe[(uint8_t) lastchippos]++;
+        }
+    out:
+      if (ret_r == HEX3_BUF_ERR)
+        {
+          info->usb_r_errors++;
+        }
+    done:
+      if (info->hash_write_pos - info->hash_read_pos >= HEX3_MAX_WORK_SIZE)
+        goto again;
+    }
+
+  ret_r =
+    libhex3_readHashData (hexminer3, info->readbuf, &info->hash_write_pos,
+                          HEXMINER3_BULK_READ_TIMEOUT, true);
+
+  rethash_count = (0xffffffffull * (int64_t) hash_count);
+
+  if (libhex3_usb_dead (hexminer3))
+    return -1;
+
+  return rethash_count;
+}
+
+#ifdef DBG_HEX3
+static void
+zero_hexminer3_stats (struct cgpu_info *hexminer3)
+{
+  if (!hexminer3->device_data)
+    return;
+  struct hexminer3_info *info = hexminer3->device_data;
+  int i;
+  for (i = 0; i < info->asic_count; i++)
+    {
+      info->matching_work[i] = 0;
+      info->dupe[i] = 0;
+
+    }
+
+}
+#endif
+static void
+get_hexminer3_statline_before (char *buf, size_t bufsiz,
+                               struct cgpu_info *hexminer3)
+{
+  if (!hexminer3->device_data)
+    return;
+  struct hexminer3_info *info = hexminer3->device_data;
+  tailsprintf (buf, bufsiz, "%3d %4d/%4dmV", info->frequency,
+               info->core_voltage, info->pic_voltage_readings);
+}
+
+static struct api_data *
+hexminer3_api_stats (struct cgpu_info *cgpu)
+{
+
+  struct api_data *root = NULL;
+  struct hexminer3_info *info = cgpu->device_data;
+  if (!info)
+    return NULL;
+  uint64_t dh64, dr64;
+
+#ifdef DBG_HEX3
+  uint32_t du32, no32;
+#endif
+  double dev_runtime;
+  struct timeval now;
+  int i;
+  char displayed_hashes[16], displayed_rolling[16];
+  double hwp =
+    (cgpu->hw_errors +
+     cgpu->diff1) ? (double) (cgpu->hw_errors) / (double) (cgpu->hw_errors +
+                                                           cgpu->diff1) : 0;
+  if (cgpu->dev_start_tv.tv_sec == 0)
+    dev_runtime = total_secs;
+  else
+    {
+      cgtime (&now);
+      dev_runtime = tdiff (&now, &(cgpu->dev_start_tv));
+    }
+  if (dev_runtime < 1.0)
+    dev_runtime = 1.0;
+  dh64 = (double) cgpu->total_mhashes / dev_runtime * 1000000ull;
+  dr64 = (double) cgpu->rolling * 1000000ull;
+  suffix_string (dh64, displayed_hashes, sizeof (displayed_hashes), 4);
+  suffix_string (dr64, displayed_rolling, sizeof (displayed_rolling), 4);
+  root = api_add_string (root, "MHS 5s", displayed_rolling, true);
+  root = api_add_string (root, "MHS av", displayed_hashes, true);
+  root = api_add_int (root, "Hardware Errors", &(cgpu->hw_errors), true);
+  root = api_add_percent (root, "Hardware Errors%", &hwp, true);
+  root = api_add_int (root, "USB Read Errors", &(info->usb_r_errors), true);
+  root = api_add_int (root, "USB Write Errors", &(info->usb_w_errors), true);
+  root =
+    api_add_int (root, "USB Reset Count", &(info->usb_reset_count), true);
+  root =
+    api_add_time (root, "Last Share Time", &(cgpu->last_share_pool_time),
+                  true);
+  root = api_add_int (root, "Chip Count", &(info->asic_count), true);
+  root = api_add_int (root, "Frequency", &(info->frequency), true);
+  root = api_add_int (root, "Core Voltage", &(info->core_voltage), true);
+  root =
+    api_add_int (root, "PIC Voltage Readings", &(info->pic_voltage_readings),
+                 true);
+#ifdef DBG_HEX3
+  du32 = 0;
+  no32 = 0;
+#endif
+  for (i = 0; i < info->asic_count; i++)
+    {
+      char mcw[24];
+      sprintf (mcw, "Chip%d Nonces", i + 1);
+      root = api_add_int (root, mcw, &(info->matching_work[i]), true);
+      sprintf (mcw, "Chip%d Dupes", i + 1);
+      root = api_add_int (root, mcw, &(info->dupe[i]), true);
+#ifdef DBG_HEX3
+      no32 += info->matching_work[i];
+      du32 += info->dupe[i];
+#endif
+    }
+#ifdef DBG_HEX3
+  double dpr = (double) (du32) / (double) (no32);
+  root = api_add_percent (root, "Dupes%", &dpr, true);
+#endif
+  return root;
+}
+
+struct device_drv hexminer3_drv = {
+  .drv_id = DRIVER_hexminer3,
+  .dname = "hexminer3",
+  .name = "HEX3",
+  .drv_detect = hexminer3_detect,
+  .thread_init = hexminer3_thread_init,
+  .hash_work = hash_queued_work,
+  .scanwork = hexminer3_scanhash,
+  .flush_work = hexminer3_flush_work,
+  .get_api_stats = hexminer3_api_stats,
+  .get_statline_before = get_hexminer3_statline_before,
+#ifdef DBG_HEX3
+  .zero_stats = zero_hexminer3_stats,
+#endif
+  .thread_shutdown = hexminer3_shutdown,
+};
--- cg_o/driver-hexminer3.h	1970-01-01 02:00:00.000000000 +0200
+++ cgminer/driver-hexminer3.h	2014-04-11 11:33:18.849851190 +0300
@@ -0,0 +1,176 @@
+/*$T indentinput.h GC 1.140 10/16/13 10:20:01 */
+/*
+ * Copyright 2013 Avalon project Copyright 2013 Con Kolivas <kernel@kolivas.org>
+ * This program is free software;
+ * you can redistribute it and/or modify it under the terms of the GNU General
+ * Public License as published by the Free Software Foundation;
+ * either version 3 of the License, or (at your option) any later version. See
+ * COPYING for more details. Thank you guys!
+ */
+#ifndef HEX3_H
+#define HEX3_H
+#ifdef USE_HEXMINER3
+#include "util.h"
+/* hexminer3_task/work_reply status Definitions: */
+//#define DBG_HEX3
+#define PWR_HEX3
+
+#define HEX3_STAT_IDLE					0       /* Idle or data already Sent to the buffer */
+#define HEX3_STAT_NEW_WORK				1       /* Request for write in the buffer */
+#define HEX3_STAT_WAITING				2       /* Wait For Buffer Empty Position */
+#define HEX3_STAT_CLR_BUFF				3       /* Force Buffer Empty */
+#define HEX3_STAT_STOP_REQ				4       /* Stop Request */
+#define HEX3_STAT_NEW_WORK_CLEAR_OLD		5       /* Clear Buffers and after that fill the first buffer */
+#define HEX3_STAT_UNUSED					6
+/* libhex3_eatHashData/BUF_reply status Definitions: */
+#define HEX3_BUF_DATA 0
+#define HEX3_BUF_ERR  1
+#define HEX3_BUF_SKIP 2
+
+#define HEXMINER3_ARRAY_PIC_SIZE		64
+#define HEXMINER3_ARRAY_SIZE                  HEXMINER3_ARRAY_PIC_SIZE * 4
+#define HEXMINER3_ARRAY_SIZE_REAL	HEXMINER3_ARRAY_SIZE - 2
+
+#define HEX3_NONCE_CASH_SIZE				16
+
+#define HEX3_USB_R_SIZE					64
+#define HEX3_USB_WR_SIZE					64
+#define HEX3_HASH_BUF_SIZE				2048*2
+
+#define HEXMINER3_BULK_READ_TIMEOUT 1000
+#define HEX3_USB_WR_TIME_OUT				500
+
+#define HEX3_MINER_THREADS			1
+#define HEX3_DEFAULT_MINER_NUM		0x01
+#define HEX3_DEFAULT_ASIC_NUM		0x10
+#define HEX3_MIN_FREQUENCY			5000
+#define HEX3_MAX_FREQUENCY			10000
+#define HEX3_DEFAULT_FREQUENCY		7000
+#define HEX3_DEFAULT_CORE_VOLTAGE	850     /* in millivolts */
+#define HEX3_MIN_COREMV				600     /* in millivolts */
+#define HEX3_MAX_COREMV	1100    /* in millivolts */
+struct chip_results3
+{
+  uint8_t nonce_cache_write_pos;
+  uint32_t nonces[HEX3_NONCE_CASH_SIZE];
+};
+
+struct work3_result
+{
+  uint8_t startbyte;
+  uint8_t datalength; //16
+  uint8_t command;
+  uint16_t address;     //16
+  uint32_t lastnonce;           //32
+  uint8_t lastnonceid;          //16
+  uint8_t status;                 //16
+  uint16_t lastvoltage;         
+  uint8_t lastchippos;      //3008    
+  uint8_t buf_empty_space;      //3009
+  uint16_t dum;               ///A,B
+  uint32_t word1;
+  uint32_t word2;
+  uint8_t csum;             //16
+  uint16_t dum1;
+ 
+} __attribute__ ((packed, aligned (4)));
+
+struct hexminer3_info
+{
+  bool shut_read;
+  bool shut_write;
+  bool shut_reset;
+  int wsem_timing;
+  int chip_mask;
+  int miner_count;
+  int asic_count;
+  int core_voltage;
+  int frequency;
+  int usb_r_errors;
+  int usb_w_errors;
+  int usb_reset_count;
+  int pic_voltage_readings;
+  int hash_read_pos;
+  int hash_write_pos;
+  int dupe[HEX3_DEFAULT_ASIC_NUM];
+  int matching_work[HEX3_DEFAULT_ASIC_NUM];
+  uint8_t wr_lastnonceid;
+  uint8_t buf_empty_space;
+  unsigned char *readbuf;
+  struct work3_result *wr;
+  struct chip_results3 *array_nonce_cache;
+  struct thr_info *thr;
+  struct work **hexworks;
+  time_t last_chip_valid_work[HEX3_DEFAULT_ASIC_NUM];
+  uint32_t nonces_range[HEX3_DEFAULT_ASIC_NUM];
+  time_t power_checked;
+  pthread_t write_thr;
+  pthread_mutex_t lock;
+  pthread_mutex_t power;
+  cgsem_t wsem;
+#ifdef DBG_HEX3
+  pthread_t dbg_thr;
+  int roled;
+  int read_pos;
+  int buf_empty_was_64;
+  int buf_empty_was_above_60;
+  int buf_empty_was_below_5;
+  int buf_empty_was_zero;
+  uint32_t word1;
+  uint32_t word2;
+  uint32_t send_j;
+  uint32_t r_j;
+#endif
+};
+
+struct hexminer3_task
+{
+  uint8_t startbyte;
+  uint8_t datalength;
+  uint8_t command;
+  uint16_t address;
+  uint32_t merkle[3];
+  uint32_t a1;
+  uint32_t a0;
+  uint32_t e2;
+  uint32_t e1;
+  uint32_t e0;
+  uint8_t midstate[32];
+  uint32_t a2;
+  uint8_t id;
+  uint8_t status;
+  uint8_t csum;
+} __attribute__ ((packed, aligned (4)));
+
+
+struct hexminer3_config_task
+{
+  uint8_t startbyte;
+  uint8_t datalength; //16
+  uint8_t command;
+  uint16_t address;
+  uint16_t hashclock;           
+  uint16_t refvoltage;
+  uint32_t startnonce;
+  uint16_t chipcount; //6x16
+  uint8_t chip_mask;  //16
+  uint8_t pad;
+  uint8_t csum;                 //16
+  uint8_t pad1[2];
+} __attribute__ ((packed, aligned (4)));
+
+ 
+#define HEX3_WORKANSWER_ADR	0x3000
+#define HEXMINER3_TASK_SIZE	(sizeof(struct hexminer3_task))
+#define HEX3_MAX_WORK_SIZE		(sizeof(struct work3_result) - 2)
+#define HEX3_BASE_WORK_SIZE		6
+
+extern int opt_hexminer3_core_voltage;
+extern int opt_hexminer3_chip_mask;
+
+extern char *libhex3_set_config_voltage (char *arg);
+extern char *libhex3_set_config_chip_mask (char *arg);
+
+extern struct hexminer3_info **hexminer3_info;
+#endif /* USE_HEXMINER3 */
+#endif /* HEX3_H */
--- cg_o/libhex8.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer/libhex8.c	2014-04-11 11:33:09.005309322 +0300
@@ -0,0 +1,382 @@
+//Thank you Zefir !!!!
+static uint32_t
+libhex8_get_target (double diff)
+{
+  unsigned nBits;
+  int shift = 29;
+  double ftarg = (double) 0x0000ffff / diff;
+  while (ftarg < (double) 0x00008000)
+    {
+      shift--;
+      ftarg *= 256.0;
+    }
+  while (ftarg >= (double) 0x00800000)
+    {
+      shift++;
+      ftarg /= 256.0;
+    }
+  nBits = (int) ftarg + (shift << 24);
+  
+  return nBits;
+}
+
+//Once More - Thank you Zefir :)
+
+static bool
+libhex8_cachenonce (struct chip_results8 *nonce_cache, uint32_t nonce)
+{
+  int i = 0;
+  while (i < HEX8_NONCE_CASH_SIZE && nonce_cache->nonces[i] != nonce)
+    i++;
+  if (i < HEX8_NONCE_CASH_SIZE)
+    return false;
+  //Rotate
+  if (nonce_cache->nonce_cache_write_pos == HEX8_NONCE_CASH_SIZE)
+    nonce_cache->nonce_cache_write_pos = 0;
+  nonce_cache->nonces[nonce_cache->nonce_cache_write_pos++] = nonce;
+  return true;
+}
+
+char *
+libhex8_set_config_voltage (char *arg)
+{
+  int val1, ret;
+  ret = sscanf (arg, "%d", &val1);
+  if (ret < 1)
+    return "No values passed to hexminer8-voltage";
+  if (val1 < HEX8_MIN_COREMV || val1 > HEX8_MAX_COREMV)
+    return "Invalid value passed to hexminer8-voltage";
+  opt_hexminer8_core_voltage = val1;
+  return NULL;
+}
+
+char *
+libhex8_set_config_chip_mask (char *arg)
+{
+  int val1, ret;
+  ret = sscanf (arg, "%d", &val1);
+  if (ret < 1)
+    return "No values passed to hexminer8-chip-mask";
+  opt_hexminer8_chip_mask = val1;
+  return NULL;
+}
+
+char *
+libhex8_set_config_diff_to_one (char *arg)
+{
+  int val1, ret;
+  ret = sscanf (arg, "%d", &val1);
+  if (ret < 1)
+    return "No values passed to hexminer8-set-diff-to-one";
+  opt_hexminer8_set_config_diff_to_one = val1;
+  return NULL;
+}
+
+static void
+libhex8_csum (unsigned char *startptr, unsigned char *endptr,
+              unsigned char *resptr)
+{
+  unsigned char *b = startptr;
+  uint8_t sum = 0;
+  while (b < endptr)
+    sum += *b++;
+  memcpy (resptr, &sum, 1);
+}
+
+static bool
+libhex8_get_options (int this_option_offset, int *asic_count, int *frequency)
+{
+  char buf[BUFSIZ + 1];
+  char *ptr, *comma, *colon, *colon2, *colon3, *colon4;
+  bool timeout_default;
+  size_t max;
+  int i, tmp;
+  if (opt_hexminer8_options == NULL)
+    buf[0] = '\0';
+  else
+    {
+      ptr = opt_hexminer8_options;
+      for (i = 0; i < this_option_offset; i++)
+        {
+          comma = strchr (ptr, ',');
+          if (comma == NULL)
+            break;
+          ptr = comma + 1;
+        }
+      comma = strchr (ptr, ',');
+      if (comma == NULL)
+        max = strlen (ptr);
+      else
+        max = comma - ptr;
+      if (max > BUFSIZ)
+        max = BUFSIZ;
+      strncpy (buf, ptr, max);
+      buf[max] = '\0';
+    }
+  if (!(*buf))
+    return false;
+  colon = strchr (buf, ':');
+  if (colon)
+    *(colon++) = '\0';
+  tmp = atoi (buf);
+  if (tmp > 0 && tmp <= HEX8_DEFAULT_ASIC_NUM)
+    *asic_count = tmp;
+  else
+    {
+      quit (1,
+            "Invalid hexminer8-options for " "asic_count (%s) must be 1 ~ %d",
+            buf, HEX8_DEFAULT_ASIC_NUM);
+    }
+  if (colon && *colon)
+    {
+      tmp = atoi (colon);
+      if (tmp < HEX8_MIN_FREQUENCY || tmp > HEX8_MAX_FREQUENCY)
+        {
+          quit
+            (1,
+             "Invalid hexminer8-options for frequency (%s) must be %d <= frequency <= %d",
+             colon, HEX8_MIN_FREQUENCY, HEX8_MAX_FREQUENCY);
+        }
+      *frequency = tmp;
+    }
+  return true;
+}
+
+static bool
+libhex8_usb_dead (struct cgpu_info *hexminer8)
+{
+  struct cg_usb_device *usbdev;
+  struct hexminer8_info *info = hexminer8->device_data;
+
+  usbdev = hexminer8->usbdev;
+  bool ret = (usbdev == NULL
+              || usbdev->handle == NULL
+              || hexminer8->shutdown
+              || info->shut_read || info->shut_write || info->shut_reset
+              || hexminer8->usbinfo.nodev || hexminer8->deven != DEV_ENABLED);
+  if (ret)
+    hexminer8->shutdown = true;
+
+  return ret;
+}
+
+
+static int
+libhex8_sendHashData (struct cgpu_info *hexminer8, unsigned char *sendbuf,
+                      size_t buf_len)
+{
+  struct hexminer8_info *info = hexminer8->device_data;
+  struct cg_usb_device *usbdev;
+  int wrote = 0, written = 0;
+  int err = LIBUSB_SUCCESS;
+
+  usbdev = hexminer8->usbdev;
+  if (libhex8_usb_dead (hexminer8))
+    goto out;
+  while (written < buf_len && err == LIBUSB_SUCCESS)
+    {
+      err = libusb_bulk_transfer
+        (usbdev->handle,
+         0x02,
+         sendbuf + written,
+         MIN (HEX8_USB_WR_SIZE, buf_len - written), &wrote,
+         HEX8_USB_WR_TIME_OUT);
+      if (err == LIBUSB_SUCCESS)
+        written += wrote;
+    }
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_write = true;
+
+  return written;
+}
+
+static void
+libhex8_reset (struct cgpu_info *hexminer8)
+{
+
+  struct hexminer8_info *info = hexminer8->device_data;
+  struct cg_usb_device *usbdev;
+  int err = LIBUSB_SUCCESS;
+
+  usbdev = hexminer8->usbdev;
+  if (libhex8_usb_dead (hexminer8))
+    goto out;
+  err = libusb_reset_device (usbdev->handle);
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    info->shut_reset = true;
+
+  info->usb_reset_count++;
+}
+
+static int libhex8_readHashData
+  (struct cgpu_info *hexminer8,
+   unsigned char *hash, int *hash_write_pos, int timeout, bool read_once)
+{
+  struct hexminer8_info *info = hexminer8->device_data;
+  struct cg_usb_device *usbdev;
+  int read = 0, total = 0;
+  int err = LIBUSB_SUCCESS;
+
+  usbdev = hexminer8->usbdev;
+  if (libhex8_usb_dead (hexminer8))
+    goto out;
+  while (*hash_write_pos + HEX8_USB_R_SIZE < HEX8_HASH_BUF_SIZE
+         && err == LIBUSB_SUCCESS)
+    {
+      err =
+        libusb_bulk_transfer (usbdev->handle, 0x82, hash + *hash_write_pos,
+                              HEX8_USB_R_SIZE, &read, timeout);
+      if (err == LIBUSB_SUCCESS)
+        {
+          *hash_write_pos += read;
+          total += read;
+        }
+      if (read_once)
+        break;
+    }
+out:
+  if (err == LIBUSB_ERROR_NO_DEVICE || err == LIBUSB_ERROR_NOT_FOUND)
+    {
+      info->shut_read = true;
+      cgsem_post (&info->wsem);
+    }
+
+  return err;
+}
+
+static double
+hexminer8_predecode_nonce (struct cgpu_info *hexminer8, struct thr_info *thr,
+                           uint32_t nonce, uint8_t work_id, bool diff1)
+{
+  struct hexminer8_info *info = hexminer8->device_data;
+  struct work *work_sub;
+  mutex_lock (&info->lock);
+  if (info->hexworks[work_id]->pool == NULL)
+    {
+      mutex_unlock (&info->lock);
+      return 0;
+    }
+
+  work_sub = copy_work_noffset_fast_no_id (info->hexworks[work_id], 0);
+  mutex_unlock (&info->lock);
+
+  double diff = (diff1 || work_sub->ping ? 1 : work_sub->work_difficulty);
+
+  if (test_nonce (work_sub, nonce))
+    {
+      //work_sub->device_diff = diff1;
+      submit_tested_work_no_clone (thr, work_sub, diff1 || work_sub->ping);
+      return diff;
+    }
+  free_work (work_sub);
+  return -diff;
+}
+
+static void
+libhex8_getvoltage (uint16_t wr_bukvoltage, int *info_pic_voltage_readings)
+{
+  float voltagehuman;
+  voltagehuman =
+    (float) ((float) wr_bukvoltage * (float) 3300 / (float) ((1 << 12) - 1));
+  *info_pic_voltage_readings = (int) voltagehuman;
+}
+
+static void
+libhex8_setvoltage (int info_voltage, uint16_t * refvoltage)
+{
+  uint16_t voltageadc;
+  voltageadc =
+    (uint16_t) ((float) info_voltage / (float) 1000 / (float) 3.3 *
+                ((1 << 12) - 1));
+  *refvoltage = htole16 (voltageadc);
+}
+
+static int
+libhex8_eatHashData (struct work8_result *wr, unsigned char *hash,
+                     int *hash_read_pos, int *hash_write_pos)
+{
+  uint8_t psum;
+  int wrpos;
+  unsigned char *csum_pos;
+  bool ok;
+eat:
+  while (*hash_read_pos < *hash_write_pos && hash[*hash_read_pos] != 0x53)
+    {
+#ifdef DBG_HEX8
+      //  applog (LOG_ERR, "%x", hash[*hash_read_pos]);
+#endif
+
+      *hash_read_pos += 1;
+    }
+  if (*hash_write_pos - *hash_read_pos < 8)
+    return HEX8_BUF_SKIP;
+  memcpy ((char *) &wr->startbyte, &hash[*hash_read_pos],
+          HEX8_BASE_WORK_SIZE - 1);
+  wr->address = htole16 (wr->address);
+  /* Address is outside be strict to avoid mem corruption - not fancy but it works */
+
+  ok = (wr->command == 0x52) &&
+    ((wr->address == HEX8_WORKANSWER_ADR && wr->datalength == 0x06)
+     || (wr->address == 0x3008 && wr->datalength == 1));
+  if (!ok)
+    {
+#ifdef DBG_HEX8
+      //applog (LOG_ERR, "%x", hash[*hash_read_pos]);
+#endif
+      *hash_read_pos += 1;
+      goto eat;
+    }
+  if (*hash_write_pos - *hash_read_pos <
+      HEX8_BASE_WORK_SIZE + wr->datalength * 2)
+    return HEX8_BUF_SKIP;
+  csum_pos =
+    hash + *hash_read_pos + HEX8_BASE_WORK_SIZE + wr->datalength * 2 - 1;
+  //Crap?
+  if (csum_pos - hash < HEX8_HASH_BUF_SIZE)
+    {
+//That was writing somewhere and corrupting memory because of faulty usb reads....
+      libhex8_csum (hash + *hash_read_pos, csum_pos, &psum);
+      if (psum != *csum_pos)
+        {
+#ifdef DBG_HEX8
+          //applog (LOG_ERR, "%x", hash[*hash_read_pos]);
+#endif
+          *hash_read_pos += 1;
+          return HEX8_BUF_ERR;
+        }
+    }
+  else
+    {
+#ifdef DBG_HEX8
+      //applog (LOG_ERR, "%x", hash[*hash_read_pos]);
+#endif
+      *hash_read_pos += 1;
+      return HEX8_BUF_ERR;
+    }
+  wrpos = (wr->address - HEX8_WORKANSWER_ADR) + HEX8_BASE_WORK_SIZE - 1;
+  memcpy
+    ((char *) &wr->startbyte + wrpos,
+     &hash[*hash_read_pos + HEX8_BASE_WORK_SIZE - 1], wr->datalength * 2);
+  *hash_read_pos += HEX8_BASE_WORK_SIZE + wr->datalength * 2;
+
+  return HEX8_BUF_DATA;
+}
+
+
+static void
+libhex8_set_word (struct cgpu_info *hexminer8, uint16_t address,
+                  uint16_t word)
+{
+  unsigned char status[10];
+  uint16_t wr_adr = htole16 (address);
+  uint16_t ledata = htole16 (word);
+  status[0] = 0x53;
+  status[1] = 0x01;
+  status[2] = 0x57;
+  memcpy (status + 3, &wr_adr, 2);
+  memcpy (status + 5, &ledata, 2);
+  libhex8_csum (status, status + 7, status + 7);
+  libhex8_sendHashData (hexminer8, status, 8);
+}
--- cg_o/lib_mcp2210_hexu.c	1970-01-01 02:00:00.000000000 +0200
+++ cgminer/lib_mcp2210_hexu.c	2014-04-10 10:37:32.217862132 +0300
@@ -0,0 +1,459 @@
+/*$T indentinput.c GC 1.140 10/16/13 10:20:34 */
+/*
+Special thanks to Luke Dashjr - Nanofory code was adopted from bfgminer - mcp2210.c
+*/
+
+static
+void libhexu_spi_emit_buf_reverse(char *buf, const void *p, size_t sz)
+{
+	const unsigned char *str = p;
+  size_t i;
+	for (i = 0; i < sz; ++i)
+	{
+		// Reverse bit order in each byte!
+		unsigned char v = str[i];
+		v = ((v & 0xaa)>>1) | ((v & 0x55) << 1);
+		v = ((v & 0xcc)>>2) | ((v & 0x33) << 2);
+		v = ((v & 0xf0)>>4) | ((v & 0x0f) << 4);
+		*buf++ = v;
+	}
+	
+}
+
+static void
+libhexu_spi_emit_data(size_t *pos, unsigned char *where, uint16_t addr, const void *buf, size_t len)
+{
+	 unsigned char *b = where + *pos;
+	if (len < 4 || len > 128)
+		return;  // This cannot be programmed in single frame! 
+	*pos+= len + 3;
+	*b++ = (len / 4 - 1) | 0xE0;
+	*b++ = (addr >> 8)&0xFF;
+	*b++ = addr & 0xFF;
+	libhexu_spi_emit_buf_reverse(b, buf, len);   
+}
+static void
+libhexu_bitfury_config_reg(size_t *pos, unsigned char *where, int cfgreg, int ena)
+{
+	static const uint8_t enaconf[4] = { 0xc1, 0x6a, 0x59, 0xe3 };
+	static const uint8_t disconf[4] = { 0, 0, 0, 0 };
+	
+	if (ena) libhexu_spi_emit_data(pos, where, 0x7000+cfgreg*32, enaconf, 4);
+	else     libhexu_spi_emit_data(pos, where, 0x7000+cfgreg*32, disconf, 4);
+}
+
+static void
+libhexu_spi_send_conf(size_t *pos, unsigned char *where)
+{
+	int i;
+	for (i = 7; i <= 11; ++i)
+		libhexu_bitfury_config_reg(pos, where, i, 0);
+		
+	//libhexu_bitfury_config_reg(pos, where, 6, 0); /* disable OUTSLK */
+	//Con
+	libhexu_bitfury_config_reg(pos, where, 6, 1); /* disable OUTSLK */
+	libhexu_bitfury_config_reg(pos, where, 4, 1); /* Enable slow oscillator */
+	for (i = 1; i <= 3; ++i)
+		libhexu_bitfury_config_reg(pos, where, i, 0);
+		
+	libhexu_spi_emit_data(pos, where, 0x0100, bitfury_counters, 16); /* Program counters correctly for rounds processing, here baby should start consuming power */
+}	
+
+static void
+libhexu_spi_emit_break(size_t *pos, unsigned char *where)
+{
+  unsigned char *b = where + *pos;
+  *b= '\x4';
+	*pos+=1;
+}
+
+static bool
+hex_mcp2210_io(struct cgpu_info *hexmineru, uint8_t * const cmd, uint8_t * const buf)
+{
+	int r_b = 0;
+	return (64 == libhexu_sendHashData(hexmineru, cmd, 64, 300) &&
+					64 == libhexu_readHashData(hexmineru, buf, &r_b, 300, 1)
+				 );	
+}
+
+static bool
+libhexu_mcp2210_get_configs(struct cgpu_info *hexmineru)
+{
+	uint8_t cmd[64], buf[64];
+	
+	//memset (cmd, 0, 64);
+	//memset (buf, 0, 64);;
+	memset (cmd, 0, 64);
+	memset (buf, 0, 64);
+	cmd[0] = 0x41;
+	if (!hex_mcp2210_io(hexmineru, cmd, buf))
+	{
+		applog(LOG_ERR, "%s: Failed to get current %s config", __func__, "SPI");
+		return false;
+	}
+	memcpy(hexmineru->cfg_spi, &buf[4], sizeof(hexmineru->cfg_spi));
+	
+	cmd[0] = 0x20;
+	if (!hex_mcp2210_io(hexmineru, cmd, buf))
+	{
+		applog(LOG_ERR, "%s: Failed to get current %s config", __func__, "GPIO");
+		return false;
+	}
+	memcpy(hexmineru->cfg_gpio, &buf[4], sizeof(hexmineru->cfg_gpio));
+	
+	return true;
+}
+
+static bool
+hex_mcp2210_set_cfg_gpio(struct cgpu_info *hexmineru)
+{	
+	uint8_t cmd[64], buf[64];
+	
+	memset (cmd, 0, 64);
+	memset (buf, 0, 64);;
+	cmd[0] = 0x21;
+	
+	// NOTE: NVRAM chip params access control is not set here
+	memcpy(&cmd[4], hexmineru->cfg_gpio, 0xe);
+	if (!hex_mcp2210_io(hexmineru, cmd, buf))
+	{
+		applog(LOG_ERR, "%s: Failed to set current %s config", __func__, "GPIO");
+		return false;
+	}
+	
+	if (buf[1] != 0)
+	{
+		applog(LOG_ERR, "%s: Error setting current %s config (%d)", __func__, "GPIO", buf[1]);
+		return false;
+	}
+	
+	return true;
+}
+
+static enum
+mcp2210_gpio_value hex_mcp2210_get_gpio_input(struct cgpu_info *hexmineru, const int pin)
+{
+  uint8_t cmd[64], buf[64];
+	
+	memset (cmd, 0, 64);
+	memset (buf, 0, 64);;
+	cmd[0] = 0x31;
+	
+	const int bit = 1 << (pin % 8);
+	const int byte = (pin / 8);
+	
+	// Set pin to GPIO mode
+	hexmineru->cfg_gpio[pin] = 0;
+	
+	// Set GPIO to input mode
+	hexmineru->cfg_gpio[byte + 0xb] |= bit;
+	
+	if (!hex_mcp2210_set_cfg_gpio(hexmineru))
+		return MGV_ERROR;
+	
+	if (!hex_mcp2210_io(hexmineru, cmd, buf))
+	{
+		applog(LOG_ERR, "%s: Failed to get current GPIO input values", __func__);
+		return MGV_ERROR;
+	}
+	
+	if (buf[byte + 4] & bit)
+		return MGV_HIGH;
+	else
+		return MGV_LOW;
+}
+
+static bool
+hex_mcp2210_set_gpio_output(struct cgpu_info *hexmineru, const int pin, const enum mcp2210_gpio_value d)
+{
+	const int bit = 1 << (pin % 8);
+	const int byte = (pin / 8);
+	
+	// Set pin to GPIO mode
+	hexmineru->cfg_gpio[pin] = 0;
+	
+	// Set GPIO to output mode
+	hexmineru->cfg_gpio[byte + 0xb] &= ~bit;
+	
+	// Set value for GPIO output
+	if (d == MGV_HIGH)
+		hexmineru->cfg_gpio[byte + 9] |= bit;
+	else
+		hexmineru->cfg_gpio[byte + 9] &= ~bit;
+	
+	return hex_mcp2210_set_cfg_gpio(hexmineru);
+}
+
+static bool
+hex_mcp2210_spi_cancel(struct cgpu_info *hexmineru)
+{
+	uint8_t cmd[64], buf[64];
+	
+	memset (cmd, 0, 64);
+	memset (buf, 0, 64);;
+	cmd[0] = 0x11;
+	
+	if (!hex_mcp2210_io(hexmineru, cmd, buf))
+		return false;
+	
+	return (buf[1] == 0);
+}
+
+static bool 
+hex_mcp2210_set_cfg_spi(struct cgpu_info *hexmineru)
+{
+	uint8_t cmd[64], buf[64];
+	
+	memset (cmd, 0, 64);
+	memset (buf, 0, 64);;
+	cmd[0] = 0x40;
+	memcpy(&cmd[4], hexmineru->cfg_spi, sizeof(hexmineru->cfg_spi));
+	if (!hex_mcp2210_io(hexmineru, cmd, buf))
+	{
+		applog(LOG_ERR, "%s: Failed to set current %s config", __func__, "SPI");
+		return false;
+	}
+	
+	if (buf[1] != 0)
+	{
+		applog(LOG_ERR, "%s: Error setting current %s config (%d)", __func__, "SPI", buf[1]);
+		return false;
+	}
+	
+	return true;
+}
+
+static bool
+hex_mcp2210_configure_spi(struct cgpu_info *hexmineru, const uint32_t bitrate, const uint16_t idlechipsel, const uint16_t activechipsel, const uint16_t chipseltodatadelay, const uint16_t lastbytetocsdelay, const uint16_t midbytedelay)
+{
+	uint8_t * const cfg = hexmineru->cfg_spi;
+	
+	cfg[0] = (bitrate >> 0x00) & 0xff;
+	cfg[1] = (bitrate >> 0x08) & 0xff;
+	cfg[2] = (bitrate >> 0x10) & 0xff;
+	cfg[3] = (bitrate >> 0x18) & 0xff;
+	
+	cfg[4] = (  idlechipsel >> 0) & 0xff;
+	cfg[5] = (  idlechipsel >> 8) & 0xff;
+	
+	cfg[6] = (activechipsel >> 0) & 0xff;
+	cfg[7] = (activechipsel >> 8) & 0xff;
+	
+	cfg[8] = (chipseltodatadelay >> 0) & 0xff;
+	cfg[9] = (chipseltodatadelay >> 8) & 0xff;
+	
+	cfg[0xa] = (lastbytetocsdelay >> 0) & 0xff;
+	cfg[0xb] = (lastbytetocsdelay >> 8) & 0xff;
+	
+	cfg[0xc] = (midbytedelay >> 0) & 0xff;
+	cfg[0xd] = (midbytedelay >> 8) & 0xff;
+	
+	return hex_mcp2210_set_cfg_spi(hexmineru);
+}
+
+static bool
+hex_mcp2210_set_spimode(struct cgpu_info *hexmineru, const uint8_t spimode)
+{
+	uint8_t * const cfg = hexmineru->cfg_spi;
+	cfg[0x10] = spimode;
+	return hex_mcp2210_set_cfg_spi(hexmineru);
+}
+
+static bool
+hex_mcp2210_spi_transfer(struct cgpu_info *hexmineru, const void * const tx, void * const rx, uint8_t sz)
+{
+	uint8_t * const cfg = hexmineru->cfg_spi;
+	struct hexmineru_info *info = hexmineru->device_data;
+	uint8_t cmd[64], buf[64];
+	
+	memset (cmd, 0, 64);
+	memset (buf, 0, 64);;
+	cmd[0] = 0x42;
+	uint8_t *p = rx;
+	
+	if (unlikely(sz > 60))
+	{
+		applog(LOG_ERR, "%s: SPI transfer too long (%d bytes)", __func__, sz);
+		return false;
+	}
+	
+	cfg[0xe] = sz;
+	cfg[0xf] = 0;
+	if(sz!=info->ltsz) {
+		if (!hex_mcp2210_set_cfg_spi(hexmineru))
+			return false;
+		info->ltsz = sz; 
+	}
+
+	cmd[1] = sz;
+	memcpy(&cmd[4], tx, sz);
+	if (unlikely(!hex_mcp2210_io(hexmineru, cmd, buf)))
+	{
+		applog(LOG_ERR, "%s: Failed to issue SPI transfer", __func__);
+		return false;
+	}
+	
+	while (true)
+	{
+		switch (buf[1])
+		{
+			case 0:     // accepted
+				cmd[1] = 0;
+				break;
+			case 0xf8:  // transfer in progress
+				applog(LOG_DEBUG, "%s: SPI transfer rejected temporarily (%d bytes remaining)", __func__, sz);
+				goto retry;
+			default:
+				applog(LOG_ERR, "%s: SPI transfer error (%d) (%d bytes remaining)", __func__, buf[1], sz);
+				return false;
+		}
+		if (buf[2] >= sz)
+		{
+			if (buf[2] > sz)
+				applog(LOG_ERR, "%s: Received %d extra bytes in SPI transfer", __func__, sz - buf[2]);
+			memcpy(p, &buf[4], sz);
+			return true;
+		}
+		memcpy(p, &buf[4], buf[2]);
+		p += buf[2];
+		sz -= buf[2];
+retry:
+		if (unlikely(!hex_mcp2210_io(hexmineru, cmd, buf)))
+		{
+			applog(LOG_ERR, "%s: Failed to continue SPI transfer (%d bytes remaining)", __func__, sz);
+			return false;
+		}
+	}
+}
+
+static bool
+hex_nanofury_checkport(struct cgpu_info *hexmineru)
+{
+	int i;
+	const char tmp = 0;
+	char tmprx;
+	
+	// default: set everything to input
+	for (i = 0; i < 9; ++i)
+		if (MGV_ERROR == hex_mcp2210_get_gpio_input(hexmineru, i))
+			goto fail;
+	
+	// configure the pins that we need:
+	
+	// LED
+	if (!hex_mcp2210_set_gpio_output(hexmineru, NANOFURY_GP_PIN_LED, MGV_HIGH))
+		goto fail;
+	
+	// PWR_EN
+	if (!hex_mcp2210_set_gpio_output(hexmineru, NANOFURY_GP_PIN_PWR_EN, MGV_HIGH))
+		goto fail;
+	
+	// cancel any outstanding SPI transfers
+	hex_mcp2210_spi_cancel(hexmineru);
+	
+	// configure SPI
+	// This is the only place where speed, mode and other settings are configured!!!
+	if (!hex_mcp2210_configure_spi(hexmineru, 200000, 0xffff, 0xffef, 0, 0, 0))
+		goto fail;
+	if (!hex_mcp2210_set_spimode(hexmineru, 0))
+		goto fail;
+	
+	if (!hex_mcp2210_spi_transfer(hexmineru, &tmp, &tmprx, 1))
+		goto fail;
+	
+	// after this command SCK_OVRRIDE should read the same as current SCK value (which for mode 0 should be 0)
+	
+	if (hex_mcp2210_get_gpio_input(hexmineru, NANOFURY_GP_PIN_SCK_OVR) != MGV_LOW)
+		goto fail;
+	
+	// switch SCK to polarity (default SCK=1 in mode 2)
+	if (!hex_mcp2210_set_spimode(hexmineru, 2))
+		goto fail;
+	if (!hex_mcp2210_spi_transfer(hexmineru, &tmp, &tmprx, 1))
+		goto fail;
+	
+	// after this command SCK_OVRRIDE should read the same as current SCK value (which for mode 2 should be 1)
+	
+	if (hex_mcp2210_get_gpio_input(hexmineru, NANOFURY_GP_PIN_SCK_OVR) != MGV_HIGH)
+		goto fail;
+	
+	// switch SCK to polarity (default SCK=0 in mode 0)
+	if (!hex_mcp2210_set_spimode(hexmineru, 0))
+		goto fail;
+	if (!hex_mcp2210_spi_transfer(hexmineru, &tmp, &tmprx, 1))
+		goto fail;
+	
+	if (hex_mcp2210_get_gpio_input(hexmineru, NANOFURY_GP_PIN_SCK_OVR) != MGV_LOW)
+		goto fail;
+	
+	return true;
+fail:
+	
+	return false;
+}
+
+// Bit-banging reset, to reset more chips in chain - toggle for longer period... Each 3 reset cycles reset first chip in chain
+static bool
+libhexu_nanofury_spi_reset(struct cgpu_info *hexmineru)
+{
+	int r;
+	char tx[1] = {0x81};  // will send this waveform: - _ _ _  _ _ _ -
+	char buf[1];
+	
+	// SCK_OVRRIDE
+	if (!hex_mcp2210_set_gpio_output(hexmineru, NANOFURY_GP_PIN_SCK_OVR, MGV_HIGH))
+		return false;
+	
+	for (r = 0; r < 16; ++r)
+		if (!hex_mcp2210_spi_transfer(hexmineru, tx, buf, 1))
+			return false;
+	
+	if (hex_mcp2210_get_gpio_input(hexmineru, NANOFURY_GP_PIN_SCK_OVR) == MGV_ERROR)
+		return false;
+	
+	return true;
+}
+
+static bool
+libhexu_nanofury_spi_txrx(struct cgpu_info *hexmineru, size_t *bufsz, unsigned char *wrbuf, unsigned char *rdbuf, bool trash)
+{
+	const uint8_t *ptrwrbuf = wrbuf;
+	uint8_t *ptrrdbuf = rdbuf;
+	size_t speedup = NANOFURY_MAX_BYTES_PER_SPI_TRANSFER;
+	if(*bufsz == 80) speedup = 40; //avoid  seting trsize at all on sending work which we do mostly :)
+	//libhexu_nanofury_spi_reset(hexmineru); // Con code
+	
+	// start by sending chunks of 60 bytes...
+	while (*bufsz >= speedup)
+	{
+		if (!hex_mcp2210_spi_transfer(hexmineru, ptrwrbuf, ptrrdbuf, speedup))
+			goto err;
+		if(!trash) ptrrdbuf += speedup;
+		ptrwrbuf += speedup;
+		*bufsz -= speedup;
+	}
+	
+	// send any remaining bytes...
+	if (*bufsz > 0)
+	{
+		if (!hex_mcp2210_spi_transfer(hexmineru, ptrwrbuf, ptrrdbuf, *bufsz))
+			goto err;
+	}
+	
+	return true;
+err:
+	return false;
+}
+
+static void
+libhexu_spi_send_init(size_t *pos, unsigned char *where) {
+	/* Prepare internal buffers */
+	/* PREPARE BUFFERS (INITIAL PROGRAMMING) */
+	unsigned w[16];
+	memset(&w, 0, sizeof(w)); w[3] = htole32(0xffffffff); w[4] = htole32(0x80000000); w[15] = htole32(0x00000280);
+	libhexu_spi_emit_data(pos, where, 0x1000, w, 16*4);
+	libhexu_spi_emit_data(pos, where, 0x1400, w,  8*4);
+	memset(w, 0, sizeof(w)); w[0] = htole32(0x80000000); w[7] = htole32(0x100);
+	libhexu_spi_emit_data(pos, where, 0x1900, &w[0],8*4); /* Prepare MS and W buffers! */
+	
+}
\ No newline at end of file
